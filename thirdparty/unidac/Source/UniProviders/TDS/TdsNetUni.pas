//////////////////////////////////////////////////
//  SQL Server Data Access Components
//  Copyright © 1998-2021 Devart. All right reserved.
//  Access in Direct mode
//////////////////////////////////////////////////
{$I Tds.inc}
unit TdsNetUni;
interface
uses
{$IFDEF MSWINDOWS}
Windows,
{$ENDIF}
{$IFDEF LOG_PACKETS}
LogHandler,
{$ENDIF}
SysUtils,Classes,SyncObjs,
CLRClasses,CRTypes,CRFunctions,CRVio,MemData,
{$IFNDEF UNIDACPRO}
TdsConsts;
{$ELSE}
TdsConstsUni;
{$ENDIF}
type
OQQCC0COQ0=class;
OQQOO0COQ0=class of OQQCC0COQ0;
OCQOO0COQ0=class;
O0Q0O0COQ0=class
protected
OOQ0O0COQ0:TBytes;
OQQ0O0COQ0,OCQ0O0COQ0:NativeInt;
O0C0O0COQ0:NativeInt;
procedure OOC0O0COQ0(OQC0O0COQ0:NativeInt);
public
constructor Create;
destructor Destroy;override;
procedure OO0OO0COQ0;
procedure OQ0OO0COQ0;
procedure OC0OO0COQ0;virtual;
procedure O0OOO0COQ0(OOOOO0COQ0:NativeInt);overload;{$IFDEF USE_INLINE}inline;{$ENDIF}
function OCOOO0COQ0:TValueArr;
property O0QOO0COQ0:NativeInt read OQQ0O0COQ0;
property OOQOO0COQ0:NativeInt read OCQ0O0COQ0;
{$IFDEF LOG_PACKETS}
procedure OOQQC0OCQ0;
{$ENDIF}
end;
OQQCC0COQ0=class(O0Q0O0COQ0)
protected
OCQCC0COQ0:integer;
procedure O0OOO0COQ0(O0CCC0COQ0,OOOOO0COQ0:NativeInt);overload;{$IFDEF USE_INLINE}inline;{$ENDIF}
public
constructor Create;virtual;
procedure OOCCC0COQ0(OQCCC0COQ0:NativeInt);
procedure OCCCC0COQ0(O000C0COQ0:NativeInt);
procedure OO00C0COQ0(OQ00C0COQ0:ShortInt);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OC00C0COQ0(O0O0C0COQ0:Byte);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OOO0C0COQ0(OQO0C0COQ0:SmallInt);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OCO0C0COQ0(O0Q0C0COQ0:Word);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OOQ0C0COQ0(OQQ0C0COQ0:Integer);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OCQ0C0COQ0(O0C0C0COQ0:Cardinal);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OOC0C0COQ0(OQC0C0COQ0:Int64);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OCC0C0COQ0(O00OC0COQ0:UInt64);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OO0OC0COQ0(OQ0OC0COQ0:Single);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OC0OC0COQ0(O0OOC0COQ0:Double);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OOOOC0COQ0(const OQOOC0COQ0:TBytes;OCOOC0COQ0:Integer;O0QOC0COQ0:Integer);overload;{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OOOOC0COQ0(OQOOC0COQ0:Pointer;O0QOC0COQ0:Integer);overload;{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OOQOC0COQ0(const OQQOC0COQ0:WideString);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure O0COC0COQ0(const OOCOC0COQ0:AnsiString);{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OCCOC0COQ0(O00QQ0COQ0:Pointer;OO0QQ0COQ0:Integer);
procedure OQ0QQ0COQ0(OC0QQ0COQ0:TBlob);
procedure O0OQQ0COQ0(OOOQQ0COQ0:Pointer;OQOQQ0COQ0:Cardinal);
procedure OCOQQ0COQ0(O0QQQ0COQ0:TBlob);
procedure OOQQQ0COQ0(const OQQQQ0COQ0:AnsiString);
procedure O0CQQ0COQ0(const OOCQQ0COQ0:WideString);
procedure OCCQQ0COQ0(O00CQ0COQ0:Pointer;OO0CQ0COQ0:Integer;OQ0CQ0COQ0:Boolean=False);virtual;
procedure OC0CQ0COQ0(O0OCQ0COQ0:TBlob;OOOCQ0COQ0:Boolean=False);virtual;
procedure OQOCQ0COQ0(OCOCQ0COQ0:IntPtr;O0QCQ0COQ0:Integer;OOQCQ0COQ0:Boolean=False);overload;virtual;
procedure OQOCQ0COQ0(const OQQCQ0COQ0:TBytes;OOQCQ0COQ0:Boolean=False);overload;{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OQOCQ0COQ0(const OCQCQ0COQ0:AnsiString;OOQCQ0COQ0:Boolean=False);overload;{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure O0CCQ0COQ0(const OOCCQ0COQ0:WideString;OQCCQ0COQ0:Boolean=False);virtual;
procedure O000Q0COQ0(OO00Q0COQ0:IntPtr;OQ00Q0COQ0:Integer);overload;virtual;
procedure O000Q0COQ0(const OC00Q0COQ0:TBytes);overload;{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure O000Q0COQ0(const O0O0Q0COQ0:AnsiString);overload;{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OOO0Q0COQ0(const OQO0Q0COQ0:WideString);virtual;
procedure O0Q0Q0COQ0(OOQ0Q0COQ0:Pointer;OQQ0Q0COQ0,OCQ0Q0COQ0:NativeInt);
procedure O0C0Q0COQ0(OOC0Q0COQ0:TBlob);
end;
OCC0Q0COQ0=array[0..65535-SizeOf(Integer)]of Byte;
O00OQ0COQ0=^OCC0Q0COQ0;
OO0OQ0COQ0=record
OQ0OQ0COQ0:Integer;
OC0OQ0COQ0:OCC0Q0COQ0;
end;
O0OOQ0COQ0=^OO0OQ0COQ0;
OOOOQ0COQ0=class(TThread)
private
OQOOQ0COQ0:TCriticalSection;
OCOOQ0COQ0:TEvent;
O0QOQ0COQ0:TEvent;
OOQOQ0COQ0:Exception;
OQQOQ0COQ0:OCQOO0COQ0;
function OCQOQ0COQ0:Boolean;
protected
procedure Execute;override;
public
constructor Create(OCCOQ0COQ0:TCriticalSection;O00QOCQOQ0:TEvent);
destructor Destroy;override;
procedure OQ0QOCQOQ0;
procedure OC0QOCQOQ0(O0OQOCQOQ0:OCQOO0COQ0);
procedure OOOQOCQOQ0;
property OQOQOCQOQ0:Boolean read OCQOQ0COQ0;
end;
OCOQOCQOQ0=class
private
O0QQOCQOQ0:OOOOQ0COQ0;
OOQQOCQOQ0:TCriticalSection;
OQQQOCQOQ0:TEvent;
public
constructor Create;
destructor Destroy;override;
procedure OOCQOCQOQ0;
procedure OQCQOCQOQ0(O0OQOCQOQ0:OCQOO0COQ0);
procedure OCCQOCQOQ0;
procedure O00COCQOQ0(OO0COCQOQ0:OCQOO0COQ0);
procedure OQ0COCQOQ0(OC0COCQOQ0:OCQOO0COQ0);
procedure OOOCOCQOQ0(OQOCOCQOQ0:OCQOO0COQ0);
procedure O0QCOCQOQ0;
end;
OCQOO0COQ0=class
private
O0COO0COQ0:TObject;
OOCOO0COQ0:TList;
OQCOO0COQ0:TBytes;
OCCOO0COQ0:TCriticalSection;
O00Q00COQ0:O00OQ0COQ0;
OO0Q00COQ0:Integer;
OQ0Q00COQ0:Integer;
OC0Q00COQ0:Integer;
O0OQ00COQ0:NativeInt;
OOOQ00COQ0:Boolean;
function OQOQ00COQ0:NativeInt;
function OCOQ00COQ0:NativeInt;
protected
function OOQQ00COQ0:Boolean;
function O0CQ00COQ0:Boolean;
procedure OO0C00COQ0;
function OOOC00COQ0(OQOC00COQ0:integer;OCOC00COQ0:Boolean=False):string;
public
constructor Create(OCQC00COQ0:TObject);
destructor Destroy;override;
function OQCC00COQ0:boolean;
procedure OO0000COQ0;
procedure O0O000COQ0;
procedure OQO000COQ0;
procedure O0Q000COQ0;
procedure OQQ000COQ0;
procedure O0C000COQ0(OOC000COQ0:NativeInt);
procedure OCC000COQ0(O00O00COQ0:IntPtr;OO0O00COQ0:Integer);
function OC0O00COQ0:ShortInt;{$IFDEF USE_INLINE}inline;{$ENDIF}
function O0OO00COQ0:Byte;{$IFDEF USE_INLINE}inline;{$ENDIF}
function OOOO00COQ0:SmallInt;{$IFDEF USE_INLINE}inline;{$ENDIF}
function OQOO00COQ0:Word;{$IFDEF USE_INLINE}inline;{$ENDIF}
function OCOO00COQ0:Integer;{$IFDEF USE_INLINE}inline;{$ENDIF}
function O0QO00COQ0:Cardinal;{$IFDEF USE_INLINE}inline;{$ENDIF}
function OOQO00COQ0:Int64;{$IFDEF USE_INLINE}inline;{$ENDIF}
function OQQO00COQ0:UInt64;{$IFDEF USE_INLINE}inline;{$ENDIF}
function OCQO00COQ0:Single;{$IFDEF USE_INLINE}inline;{$ENDIF}
function O0CO00COQ0:Double;{$IFDEF USE_INLINE}inline;{$ENDIF}
function OOCO00COQ0:TBytes;{$IFDEF USE_INLINE}inline;{$ENDIF}
function OCCO00COQ0:TBytes;{$IFDEF USE_INLINE}inline;{$ENDIF}
function OO0QC0COQ0(OQ0QC0COQ0:Boolean=False):string;
function O0OQC0COQ0(OOOQC0COQ0:Boolean=False):string;
procedure OCOQC0COQ0(O0QQC0COQ0:IntPtr;OOQQC0COQ0:Integer;OQQQC0COQ0:Integer=0);
function OCCQC0COQ0:Byte;
procedure O0OCC0COQ0(OOOCC0COQ0:NativeInt);
procedure OQOCC0COQ0;
property O0QCC0COQ0:NativeInt read OQOQ00COQ0;
property OOQCC0COQ0:NativeInt read OCOQ00COQ0;
end;
function OCQCOCQOQ0(O0CCOCQOQ0:SmallInt):SmallInt;overload;
function OCQCOCQOQ0(O0CCOCQOQ0:Word):Word;overload;
function OCQCOCQOQ0(O0CCOCQOQ0:Integer):Integer;overload;
function OCQCOCQOQ0(O0CCOCQOQ0:Cardinal):Cardinal;overload;
function OCQCOCQOQ0(O0CCOCQOQ0:Int64):Int64;overload;
{$IFDEF VER7P}
function OCQCOCQOQ0(O0CCOCQOQ0:UInt64):UInt64;overload;
{$ENDIF}
implementation
uses
{$IFNDEF UNIDACPRO}
TdsProtocol;
{$ELSE}
TdsProtocolUni;
{$ENDIF}
const
OOCCOCQOQ0=4096;
{$IFNDEF VER10P}
type
OQCCOCQOQ0=class(TCriticalSection)
end;
{$ENDIF}
function OCQCOCQOQ0(O0CCOCQOQ0:SmallInt):SmallInt;
{$IFNDEF UseASM}
begin
Result:=(O0CCOCQOQ0 and$FF shl 8)or(O0CCOCQOQ0 and$FF00 shr 8);
{$ELSE}
asm
{$IFDEF CPU64}
MOV EAX,ECX
{$ENDIF}
XCHG AH,AL
{$ENDIF}
end;
function OCQCOCQOQ0(O0CCOCQOQ0:Word):Word;
{$IFNDEF UseASM}
begin
Result:=(O0CCOCQOQ0 and$FF shl 8)or(O0CCOCQOQ0 and$FF00 shr 8);
{$ELSE}
asm
{$IFDEF CPU64}
MOV EAX,ECX
{$ENDIF}
XCHG AH,AL
{$ENDIF}
end;
function OCQCOCQOQ0(O0CCOCQOQ0:Integer):Integer;
{$IFNDEF UseASM}
begin
Result:=(O0CCOCQOQ0 and$FF shl 24)or(O0CCOCQOQ0 and$FF00 shl 8)or(O0CCOCQOQ0 and$FF0000 shr 8)or(O0CCOCQOQ0 and Integer($FF000000)shr 24);
{$ELSE}
asm
{$IFDEF CPU64}
MOV EAX,ECX
{$ENDIF}
BSWAP EAX
{$ENDIF}
end;
function OCQCOCQOQ0(O0CCOCQOQ0:Cardinal):Cardinal;
{$IFNDEF UseASM}
begin
Result:=(O0CCOCQOQ0 and$FF shl 24)or(O0CCOCQOQ0 and$FF00 shl 8)or(O0CCOCQOQ0 and$FF0000 shr 8)or(O0CCOCQOQ0 and$FF000000 shr 24);
{$ELSE}
asm
{$IFDEF CPU64}
MOV EAX,ECX
{$ENDIF}
BSWAP EAX
{$ENDIF}
end;
function OCQCOCQOQ0(O0CCOCQOQ0:Int64):Int64;
begin
Int64Rec(Result).Lo:=OCQCOCQOQ0(Int64Rec(O0CCOCQOQ0).Lo);
Int64Rec(Result).Hi:=OCQCOCQOQ0(Int64Rec(O0CCOCQOQ0).Hi);
end;
{$IFDEF VER7P}
function OCQCOCQOQ0(O0CCOCQOQ0:UInt64):UInt64;
begin
Int64Rec(Result).Lo:=OCQCOCQOQ0(Int64Rec(O0CCOCQOQ0).Lo);
Int64Rec(Result).Hi:=OCQCOCQOQ0(Int64Rec(O0CCOCQOQ0).Hi);
end;
{$ENDIF}
procedure OCCCOCQOQ0(var O000OCQOQ0:WideString);{$IFDEF USE_INLINE}inline;{$ENDIF}
var
OO00OCQOQ0,OQ00OCQOQ0:Integer;
begin
OQ00OCQOQ0:=0;
for OO00OCQOQ0:=1 to Length(O000OCQOQ0)do begin
if O000OCQOQ0[OO00OCQOQ0]<>#0 then
Inc(OQ00OCQOQ0);
end;
SetLength(O000OCQOQ0,OQ00OCQOQ0);
end;
constructor O0Q0O0COQ0.Create;
begin
inherited Create;
O0C0O0COQ0:=OOCCOCQOQ0;
SetLength(OOQ0O0COQ0,O0C0O0COQ0);
OQQ0O0COQ0:=0;
OCQ0O0COQ0:=0;
end;
destructor O0Q0O0COQ0.Destroy;
begin
SetLength(OOQ0O0COQ0,0);
inherited;
end;
function O0Q0O0COQ0.OCOOO0COQ0:TValueArr;
begin
Result:=@OOQ0O0COQ0[0];
end;
procedure O0Q0O0COQ0.OO0OO0COQ0;
begin
if O0C0O0COQ0>32*1024 then begin
O0C0O0COQ0:=OOCCOCQOQ0;
SetLength(OOQ0O0COQ0,O0C0O0COQ0);
end;
OQQ0O0COQ0:=0;
OCQ0O0COQ0:=0;
end;
procedure O0Q0O0COQ0.OQ0OO0COQ0;
begin
OQQ0O0COQ0:=0;
OCQ0O0COQ0:=0;
end;
procedure O0Q0O0COQ0.OC0OO0COQ0;
begin
if OQQ0O0COQ0<32*1024 then
Exit;
Dec(OCQ0O0COQ0,OQQ0O0COQ0);
if OCQ0O0COQ0>0 then
Move(OOQ0O0COQ0[OQQ0O0COQ0],OOQ0O0COQ0[0],OCQ0O0COQ0);
OQQ0O0COQ0:=0;
end;
procedure O0Q0O0COQ0.OOC0O0COQ0(OQC0O0COQ0:NativeInt);
begin
{$IFDEF CPU64}
if OQC0O0COQ0>$7FFFFFFF then
raise Exception.CreateFmt('Size %d exceeds limits',[OQC0O0COQ0]);
{$ENDIF}
if OQC0O0COQ0>O0C0O0COQ0 then begin
O0C0O0COQ0:=O0C0O0COQ0*2;
if OQC0O0COQ0>O0C0O0COQ0 then
O0C0O0COQ0:=OQC0O0COQ0;
SetLength(OOQ0O0COQ0,O0C0O0COQ0);
end;
end;
procedure O0Q0O0COQ0.O0OOO0COQ0(OOOOO0COQ0:NativeInt);
var
OQOOO0COQ0:NativeInt;
begin
OQOOO0COQ0:=OCQ0O0COQ0+OOOOO0COQ0;
if OQOOO0COQ0>O0C0O0COQ0 then
OOC0O0COQ0(OQOOO0COQ0);
end;
{$IFDEF LOG_PACKETS}
procedure O0Q0O0COQ0.OOQQC0OCQ0;
begin
if OQQ0O0COQ0>0 then
AddDump(@OOQ0O0COQ0[0],OQQ0O0COQ0,'');
end;
{$ENDIF}
constructor OQQCC0COQ0.Create;
begin
inherited;
end;
procedure OQQCC0COQ0.O0OOO0COQ0(O0CCC0COQ0,OOOOO0COQ0:NativeInt);
var
OQOOO0COQ0:NativeInt;
begin
OQOOO0COQ0:=O0CCC0COQ0+OOOOO0COQ0;
if OQOOO0COQ0>O0C0O0COQ0 then
OOC0O0COQ0(OQOOO0COQ0);
end;
procedure OQQCC0COQ0.OOCCC0COQ0(OQCCC0COQ0:NativeInt);
begin
Assert(OCQ0O0COQ0+OQCCC0COQ0<=O0C0O0COQ0);
OCQ0O0COQ0:=OCQ0O0COQ0+OQCCC0COQ0;
end;
procedure OQQCC0COQ0.OCCCC0COQ0(O000C0COQ0:NativeInt);
begin
OQQ0O0COQ0:=OQQ0O0COQ0+O000C0COQ0;
end;
procedure OQQCC0COQ0.OO00C0COQ0(OQ00C0COQ0:ShortInt);
begin
O0OOO0COQ0(SizeOf(OQ00C0COQ0));
OOQ0O0COQ0[OCQ0O0COQ0]:=OQ00C0COQ0;
Inc(OCQ0O0COQ0,SizeOf(OQ00C0COQ0));
end;
procedure OQQCC0COQ0.OC00C0COQ0(O0O0C0COQ0:Byte);
begin
O0OOO0COQ0(SizeOf(O0O0C0COQ0));
OOQ0O0COQ0[OCQ0O0COQ0]:=O0O0C0COQ0;
Inc(OCQ0O0COQ0,SizeOf(O0O0C0COQ0));
end;
procedure OQQCC0COQ0.OOO0C0COQ0(OQO0C0COQ0:SmallInt);
begin
O0OOO0COQ0(SizeOf(OQO0C0COQ0));
PSmallInt(@OOQ0O0COQ0[OCQ0O0COQ0])^:=OQO0C0COQ0;
Inc(OCQ0O0COQ0,SizeOf(OQO0C0COQ0));
end;
procedure OQQCC0COQ0.OCO0C0COQ0(O0Q0C0COQ0:Word);
begin
O0OOO0COQ0(SizeOf(O0Q0C0COQ0));
PWord(@OOQ0O0COQ0[OCQ0O0COQ0])^:=O0Q0C0COQ0;
Inc(OCQ0O0COQ0,SizeOf(O0Q0C0COQ0));
end;
procedure OQQCC0COQ0.OOQ0C0COQ0(OQQ0C0COQ0:Integer);
begin
O0OOO0COQ0(SizeOf(OQQ0C0COQ0));
PInteger(@OOQ0O0COQ0[OCQ0O0COQ0])^:=OQQ0C0COQ0;
Inc(OCQ0O0COQ0,SizeOf(OQQ0C0COQ0));
end;
procedure OQQCC0COQ0.OCQ0C0COQ0(O0C0C0COQ0:Cardinal);
begin
O0OOO0COQ0(SizeOf(O0C0C0COQ0));
PCardinal(@OOQ0O0COQ0[OCQ0O0COQ0])^:=O0C0C0COQ0;
Inc(OCQ0O0COQ0,SizeOf(O0C0C0COQ0));
end;
procedure OQQCC0COQ0.OOC0C0COQ0(OQC0C0COQ0:Int64);
begin
O0OOO0COQ0(SizeOf(OQC0C0COQ0));
PInt64(@OOQ0O0COQ0[OCQ0O0COQ0])^:=OQC0C0COQ0;
Inc(OCQ0O0COQ0,SizeOf(OQC0C0COQ0));
end;
procedure OQQCC0COQ0.OCC0C0COQ0(O00OC0COQ0:UInt64);
begin
O0OOO0COQ0(SizeOf(O00OC0COQ0));
PUInt64(@OOQ0O0COQ0[OCQ0O0COQ0])^:=O00OC0COQ0;
Inc(OCQ0O0COQ0,SizeOf(O00OC0COQ0));
end;
procedure OQQCC0COQ0.OO0OC0COQ0(OQ0OC0COQ0:Single);
begin
O0OOO0COQ0(SizeOf(OQ0OC0COQ0));
PSingle(@OOQ0O0COQ0[OCQ0O0COQ0])^:=OQ0OC0COQ0;
Inc(OCQ0O0COQ0,SizeOf(OQ0OC0COQ0));
end;
procedure OQQCC0COQ0.OC0OC0COQ0(O0OOC0COQ0:Double);
begin
O0OOO0COQ0(SizeOf(O0OOC0COQ0));
PDouble(@OOQ0O0COQ0[OCQ0O0COQ0])^:=O0OOC0COQ0;
Inc(OCQ0O0COQ0,SizeOf(O0OOC0COQ0));
end;
procedure OQQCC0COQ0.OOOOC0COQ0(const OQOOC0COQ0:TBytes;OCOOC0COQ0:Integer;O0QOC0COQ0:Integer);
begin
OOOOC0COQ0(@OQOOC0COQ0[OCOOC0COQ0],O0QOC0COQ0);
end;
procedure OQQCC0COQ0.OOOOC0COQ0(OQOOC0COQ0:Pointer;O0QOC0COQ0:Integer);
begin
O0OOO0COQ0(O0QOC0COQ0);
Move(OQOOC0COQ0^,OOQ0O0COQ0[OCQ0O0COQ0],O0QOC0COQ0);
Inc(OCQ0O0COQ0,O0QOC0COQ0);
end;
procedure OQQCC0COQ0.OOQOC0COQ0(const OQQOC0COQ0:WideString);
var
OCQOC0COQ0:Integer;
begin
OCQOC0COQ0:=System.Length(OQQOC0COQ0)*2;
if OCQOC0COQ0>0 then begin
O0OOO0COQ0(OCQOC0COQ0);
Move(PWideChar(OQQOC0COQ0)^,OOQ0O0COQ0[OCQ0O0COQ0],OCQOC0COQ0);
Inc(OCQ0O0COQ0,OCQOC0COQ0);
end;
end;
procedure OQQCC0COQ0.O0COC0COQ0(const OOCOC0COQ0:AnsiString);
var
OQCOC0COQ0:Integer;
begin
OQCOC0COQ0:=LengthA(OOCOC0COQ0);
if OQCOC0COQ0>0 then begin
O0OOO0COQ0(OQCOC0COQ0);
Move(PAnsiChar(OOCOC0COQ0)^,OOQ0O0COQ0[OCQ0O0COQ0],OQCOC0COQ0);
Inc(OCQ0O0COQ0,OQCOC0COQ0);
end;
end;
procedure OQQCC0COQ0.OCCOC0COQ0(O00QQ0COQ0:Pointer;OO0QQ0COQ0:Integer);
begin
OC00C0COQ0(OO0QQ0COQ0);
if OO0QQ0COQ0>0 then begin
O0OOO0COQ0(OO0QQ0COQ0);
Move(O00QQ0COQ0^,OOQ0O0COQ0[OCQ0O0COQ0],OO0QQ0COQ0);
Inc(OCQ0O0COQ0,OO0QQ0COQ0);
end;
end;
procedure OQQCC0COQ0.OQ0QQ0COQ0(OC0QQ0COQ0:TBlob);
begin
if OC0QQ0COQ0.Size>$FF then
raise Exception.CreateFmt('B_VARBYTE size %d exceeds max length %d',[OC0QQ0COQ0.Size,$FF]);
if OC0QQ0COQ0.Size=0 then
OCO0C0COQ0(Word(OCQCC0COQ0))
else begin
OC00C0COQ0(OC0QQ0COQ0.Size);
O0C0Q0COQ0(OC0QQ0COQ0);
end;
end;
procedure OQQCC0COQ0.O0C0Q0COQ0(OOC0Q0COQ0:TBlob);
var
OQC0Q0COQ0:cardinal;
begin
O0OOO0COQ0(OOC0Q0COQ0.Size);
OQC0Q0COQ0:=OOC0Q0COQ0.GetData.Read(0,OOC0Q0COQ0.Size,@OOQ0O0COQ0[OCQ0O0COQ0]);
Inc(OCQ0O0COQ0,integer(OQC0Q0COQ0));
end;
procedure OQQCC0COQ0.O0OQQ0COQ0(OOOQQ0COQ0:Pointer;OQOQQ0COQ0:Cardinal);
begin
if OQOQQ0COQ0=0 then
OCQ0C0COQ0(Cardinal(OCQCC0COQ0))
else begin
OCQ0C0COQ0(OQOQQ0COQ0);
O0OOO0COQ0(OQOQQ0COQ0);
Move(OOOQQ0COQ0^,OOQ0O0COQ0[OCQ0O0COQ0],OQOQQ0COQ0);
Inc(OCQ0O0COQ0,integer(OQOQQ0COQ0));
end;
end;
procedure OQQCC0COQ0.OCOQQ0COQ0(O0QQQ0COQ0:TBlob);
begin
if O0QQQ0COQ0.Size=0 then
OCQ0C0COQ0(Cardinal(OCQCC0COQ0))
else begin
OCQ0C0COQ0(O0QQQ0COQ0.Size);
O0C0Q0COQ0(O0QQQ0COQ0);
end;
end;
procedure OQQCC0COQ0.OOQQQ0COQ0(const OQQQQ0COQ0:AnsiString);
var
OCQQQ0COQ0:Integer;
begin
OCQQQ0COQ0:=LengthA(OQQQQ0COQ0);
OC00C0COQ0(OCQQQ0COQ0);
if OCQQQ0COQ0>0 then begin
O0OOO0COQ0(OCQQQ0COQ0);
Move(PAnsiChar(OQQQQ0COQ0)^,OOQ0O0COQ0[OCQ0O0COQ0],OCQQQ0COQ0);
Inc(OCQ0O0COQ0,OCQQQ0COQ0);
end;
end;
procedure OQQCC0COQ0.O0CQQ0COQ0(const OOCQQ0COQ0:WideString);
var
OQCQQ0COQ0:Integer;
begin
OQCQQ0COQ0:=System.Length(OOCQQ0COQ0)*2;
OC00C0COQ0(OQCQQ0COQ0);
if OQCQQ0COQ0>0 then begin
O0OOO0COQ0(OQCQQ0COQ0);
Move(PWideChar(OOCQQ0COQ0)^,OOQ0O0COQ0[OCQ0O0COQ0],OQCQQ0COQ0);
Inc(OCQ0O0COQ0,OQCQQ0COQ0);
end;
end;
procedure OQQCC0COQ0.OCCQQ0COQ0(O00CQ0COQ0:Pointer;OO0CQ0COQ0:Integer;OQ0CQ0COQ0:Boolean=False);
begin
if OO0CQ0COQ0>$FFFF then
raise Exception.CreateFmt('US_VARBYTE size %d exceeds max length %d',[OO0CQ0COQ0,$FFFF]);
if OO0CQ0COQ0=0 then
OCO0C0COQ0(Word(OCQCC0COQ0))
else begin
OCO0C0COQ0(OO0CQ0COQ0);
O0OOO0COQ0(OO0CQ0COQ0);
Move(O00CQ0COQ0^,OOQ0O0COQ0[OCQ0O0COQ0],OO0CQ0COQ0);
Inc(OCQ0O0COQ0,OO0CQ0COQ0);
end;
end;
procedure OQQCC0COQ0.OC0CQ0COQ0(O0OCQ0COQ0:TBlob;OOOCQ0COQ0:Boolean=False);
begin
if O0OCQ0COQ0.Size>$FFFF then
raise Exception.CreateFmt('US_VARBYTE size %d exceeds max length %d',[O0OCQ0COQ0.Size,$FFFF]);
if O0OCQ0COQ0.Size=0 then
OCO0C0COQ0(Word(OCQCC0COQ0))
else begin
OCO0C0COQ0(O0OCQ0COQ0.Size);
O0C0Q0COQ0(O0OCQ0COQ0);
end;
end;
procedure OQQCC0COQ0.OQOCQ0COQ0(OCOCQ0COQ0:IntPtr;O0QCQ0COQ0:Integer;OOQCQ0COQ0:Boolean=False);
begin
if O0QCQ0COQ0>$FFFF then
raise Exception.CreateFmt('US_VARBYTE size %d exceeds max length %d',[O0QCQ0COQ0,$FFFF]);
OCO0C0COQ0(O0QCQ0COQ0);
if O0QCQ0COQ0>0 then begin
O0OOO0COQ0(O0QCQ0COQ0);
Move(OCOCQ0COQ0^,OOQ0O0COQ0[OCQ0O0COQ0],O0QCQ0COQ0);
Inc(OCQ0O0COQ0,O0QCQ0COQ0);
end;
end;
procedure OQQCC0COQ0.OQOCQ0COQ0(const OQQCQ0COQ0:TBytes;OOQCQ0COQ0:Boolean=False);
begin
OQOCQ0COQ0(OQQCQ0COQ0,Length(OQQCQ0COQ0),OOQCQ0COQ0);
end;
procedure OQQCC0COQ0.OQOCQ0COQ0(const OCQCQ0COQ0:AnsiString;OOQCQ0COQ0:Boolean=False);
begin
OQOCQ0COQ0(PAnsiChar(OCQCQ0COQ0),LengthA(OCQCQ0COQ0),OOQCQ0COQ0);
end;
procedure OQQCC0COQ0.O0CCQ0COQ0(const OOCCQ0COQ0:WideString;OQCCQ0COQ0:Boolean=False);
var
OCCCQ0COQ0:Integer;
begin
OCCCQ0COQ0:=System.Length(OOCCQ0COQ0)*2;
if OCCCQ0COQ0>$FFFF then
raise Exception.CreateFmt('US_VARBYTE size %d exceeds max length %d',[OCCCQ0COQ0,$FFFF]);
OCO0C0COQ0(OCCCQ0COQ0);
if OCCCQ0COQ0>0 then begin
O0OOO0COQ0(OCCCQ0COQ0);
Move(PWideChar(OOCCQ0COQ0)^,OOQ0O0COQ0[OCQ0O0COQ0],OCCCQ0COQ0);
Inc(OCQ0O0COQ0,OCCCQ0COQ0);
end;
end;
procedure OQQCC0COQ0.O000Q0COQ0(OO00Q0COQ0:IntPtr;OQ00Q0COQ0:Integer);
begin
OCQ0C0COQ0(OQ00Q0COQ0);
if OQ00Q0COQ0>0 then begin
O0OOO0COQ0(OQ00Q0COQ0);
Move(OO00Q0COQ0^,OOQ0O0COQ0[OCQ0O0COQ0],OQ00Q0COQ0);
Inc(OCQ0O0COQ0,OQ00Q0COQ0);
end;
end;
procedure OQQCC0COQ0.O000Q0COQ0(const OC00Q0COQ0:TBytes);
begin
O000Q0COQ0(OC00Q0COQ0,Length(OC00Q0COQ0));
end;
procedure OQQCC0COQ0.O000Q0COQ0(const O0O0Q0COQ0:AnsiString);
begin
O000Q0COQ0(PAnsiChar(O0O0Q0COQ0),LengthA(O0O0Q0COQ0));
end;
procedure OQQCC0COQ0.OOO0Q0COQ0(const OQO0Q0COQ0:WideString);
var
OCO0Q0COQ0:NativeInt;
begin
OCO0Q0COQ0:=System.Length(OQO0Q0COQ0)*2;
OCQ0C0COQ0(OCO0Q0COQ0);
if OCO0Q0COQ0>0 then begin
O0OOO0COQ0(OCO0Q0COQ0);
Move(PWideChar(OQO0Q0COQ0)^,OOQ0O0COQ0[OCQ0O0COQ0],OCO0Q0COQ0);
Inc(OCQ0O0COQ0,OCO0Q0COQ0);
end;
end;
procedure OQQCC0COQ0.O0Q0Q0COQ0(OOQ0Q0COQ0:Pointer;OQQ0Q0COQ0,OCQ0Q0COQ0:NativeInt);
begin
Assert(OCQ0Q0COQ0>=0);
O0OOO0COQ0(OCQ0Q0COQ0,OQQ0Q0COQ0);
Move(OOQ0Q0COQ0^,OOQ0O0COQ0[OCQ0Q0COQ0],OQQ0Q0COQ0);
end;
constructor OOOOQ0COQ0.Create(OCCOQ0COQ0:TCriticalSection;O00QOCQOQ0:TEvent);
begin
inherited Create(False);
OQOOQ0COQ0:=OCCOQ0COQ0;
O0QOQ0COQ0:=O00QOCQOQ0;
OCOOQ0COQ0:=TEvent.Create(nil,True,False,'');
FreeOnTerminate:=True;
end;
destructor OOOOQ0COQ0.Destroy;
begin
OCOOQ0COQ0.Free;
O0QOQ0COQ0.Free;
OQOOQ0COQ0.Free;
inherited;
end;
function OOOOQ0COQ0.OCQOQ0COQ0:Boolean;
begin
Result:=(OCOOQ0COQ0.WaitFor(0)<>wrSignaled);
end;
procedure OOOOQ0COQ0.Execute;
var
OOCOQ0COQ0:Boolean;
begin
while True do
if OCOOQ0COQ0.WaitFor(INFINITE)=wrSignaled then begin
OQOOQ0COQ0.Enter;
try
if Terminated then
Break;
OOCOQ0COQ0:=True;
if OQQOQ0COQ0<>nil then
try
OOCOQ0COQ0:=OQQOQ0COQ0.O0CQ00COQ0;
except
on E:Exception do begin
AcquireExceptionObject;
try
OOQOQ0COQ0.Free;
finally
OOQOQ0COQ0:=E;
end;
end;
end;
if OOCOQ0COQ0 then
OOOQOCQOQ0;
finally
O0QOQ0COQ0.SetEvent;
OQOOQ0COQ0.Leave;
end;
end;
end;
procedure OOOOQ0COQ0.OQ0QOCQOQ0;
begin
if OOQOQ0COQ0=nil then
Exit;
try
raise OOQOQ0COQ0;
finally
OOQOQ0COQ0:=nil;
end;
end;
procedure OOOOQ0COQ0.OC0QOCQOQ0(O0OQOCQOQ0:OCQOO0COQ0);
begin
OQQOQ0COQ0:=O0OQOCQOQ0;
OCOOQ0COQ0.SetEvent;
end;
procedure OOOOQ0COQ0.OOOQOCQOQ0;
begin
OCOOQ0COQ0.ResetEvent;
OQQOQ0COQ0:=nil;
end;
constructor OCOQOCQOQ0.Create;
begin
inherited;
OOQQOCQOQ0:=TCriticalSection.Create;
OQQQOCQOQ0:=TEvent.Create(nil,False,False,'');
end;
destructor OCOQOCQOQ0.Destroy;
begin
if O0QQOCQOQ0<>nil then begin
OOQQOCQOQ0.Enter;
try
O0QQOCQOQ0.Terminate;
O0QQOCQOQ0.OC0QOCQOQ0(nil);
O0QQOCQOQ0:=nil;
finally
OQQQOCQOQ0.SetEvent;
OOQQOCQOQ0.Leave;
end;
end
else begin
OQQQOCQOQ0.Free;
OOQQOCQOQ0.Free;
end;
inherited;
end;
procedure OCOQOCQOQ0.OOCQOCQOQ0;
begin
OOQQOCQOQ0.Enter;
try
if O0QQOCQOQ0<>nil then
O0QQOCQOQ0.OQ0QOCQOQ0;
finally
OOQQOCQOQ0.Leave;
end;
end;
procedure OCOQOCQOQ0.OQCQOCQOQ0(O0OQOCQOQ0:OCQOO0COQ0);
begin
OOQQOCQOQ0.Enter;
try
if O0QQOCQOQ0=nil then
O0QQOCQOQ0:=OOOOQ0COQ0.Create(OOQQOCQOQ0,OQQQOCQOQ0);
O0QQOCQOQ0.OC0QOCQOQ0(O0OQOCQOQ0);
finally
OQQQOCQOQ0.ResetEvent;
OOQQOCQOQ0.Leave;
end;
end;
procedure OCOQOCQOQ0.OCCQOCQOQ0;
begin
OOQQOCQOQ0.Enter;
try
if O0QQOCQOQ0<>nil then
O0QQOCQOQ0.OOOQOCQOQ0;
finally
OQQQOCQOQ0.SetEvent;
OOQQOCQOQ0.Leave;
end;
end;
procedure OCOQOCQOQ0.O00COCQOQ0(OO0COCQOQ0:OCQOO0COQ0);
begin
{$IFDEF FPC}
if OOQQOCQOQ0.TryEnter then
{$ELSE}{$IFDEF VER10P}
if OOQQOCQOQ0.TryEnter then
{$ELSE}
if TryEnterCriticalSection(OQCCOCQOQ0(OOQQOCQOQ0).FSection)then
{$ENDIF}{$ENDIF}
try
OOCQOCQOQ0;
if(O0QQOCQOQ0=nil)or O0QQOCQOQ0.OQOQOCQOQ0 then
OO0COCQOQ0.O0CQ00COQ0;
finally
OOQQOCQOQ0.Leave
end
else
OQQQOCQOQ0.WaitFor(INFINITE);
end;
procedure OCOQOCQOQ0.OQ0COCQOQ0(OC0COCQOQ0:OCQOO0COQ0);
var
O0OCOCQOQ0:Boolean;
begin
OOQQOCQOQ0.Enter;
try
if OOQQ0QQOQ0(OC0COCQOQ0.O0COO0COQ0).OQ0O0OQOQ0 then
Exit;
if(O0QQOCQOQ0<>nil)and not O0QQOCQOQ0.OQOQOCQOQ0 then
O0QQOCQOQ0.OOOQOCQOQ0;
repeat
if OC0COCQOQ0=nil then
O0OCOCQOQ0:=True
else
O0OCOCQOQ0:=OC0COCQOQ0.OOQQ00COQ0;
until O0OCOCQOQ0;
finally
OOQQOCQOQ0.Leave;
end;
end;
procedure OCOQOCQOQ0.OOOCOCQOQ0(OQOCOCQOQ0:OCQOO0COQ0);
var
OCOCOCQOQ0:Boolean;
begin
OOQQOCQOQ0.Enter;
try
if OOQQ0QQOQ0(OQOCOCQOQ0.O0COO0COQ0).OQ0O0OQOQ0 then
Exit;
if(O0QQOCQOQ0<>nil)and not O0QQOCQOQ0.OQOQOCQOQ0 then
O0QQOCQOQ0.OOOQOCQOQ0;
repeat
if OQOCOCQOQ0=nil then
OCOCOCQOQ0:=True
else
OCOCOCQOQ0:=OQOCOCQOQ0.O0CQ00COQ0;
until OCOCOCQOQ0;
finally
OOQQOCQOQ0.Leave;
end;
end;
procedure OCOQOCQOQ0.O0QCOCQOQ0;
var
OOQCOCQOQ0:OCQOO0COQ0;
OQQCOCQOQ0:Boolean;
begin
OOQQOCQOQ0.Enter;
try
if(O0QQOCQOQ0=nil)or O0QQOCQOQ0.OQOQOCQOQ0 then
Exit;
OOQCOCQOQ0:=O0QQOCQOQ0.OQQOQ0COQ0;
O0QQOCQOQ0.OOOQOCQOQ0;
repeat
if OOQCOCQOQ0=nil then
OQQCOCQOQ0:=True
else
OQQCOCQOQ0:=OOQCOCQOQ0.O0CQ00COQ0;
until OQQCOCQOQ0;
finally
OOQQOCQOQ0.Leave;
end;
end;
constructor OCQOO0COQ0.Create(OCQC00COQ0:TObject);
var
O0CC00COQ0:O0OOQ0COQ0;
begin
inherited Create;
OCCOO0COQ0:=TCriticalSection.Create;
O0COO0COQ0:=OCQC00COQ0;
OOCOO0COQ0:=TList.Create;
New(O0CC00COQ0);
O0CC00COQ0.OQ0OQ0COQ0:=0;
OOCOO0COQ0.Add(O0CC00COQ0);
O0OQ00COQ0:=-1;
OOOQ00COQ0:=True;
end;
destructor OCQOO0COQ0.Destroy;
begin
OO0000COQ0;
OCCOO0COQ0.Enter;
try
Dispose(O0OOQ0COQ0(OOCOO0COQ0[0]));
OOCOO0COQ0.Free;
finally
OCCOO0COQ0.Leave;
end;
OCCOO0COQ0.Free;
inherited;
end;
function OCQOO0COQ0.OQOQ00COQ0:NativeInt;
begin
Result:=NativeInt(OQ0Q00COQ0)*SizeOf(OCC0Q0COQ0)+NativeInt(OC0Q00COQ0);
end;
function OCQOO0COQ0.OCOQ00COQ0:NativeInt;
var
O0QQ00COQ0:Integer;
begin
OCCOO0COQ0.Enter;
try
O0QQ00COQ0:=OOCOO0COQ0.Count-1;
Result:=NativeInt(O0QQ00COQ0)*SizeOf(OCC0Q0COQ0)+NativeInt(O0OOQ0COQ0(OOCOO0COQ0[O0QQ00COQ0]).OQ0OQ0COQ0);
finally
OCCOO0COQ0.Leave;
end;
end;
function OCQOO0COQ0.OOQQ00COQ0:Boolean;
var
OQQQ00COQ0:Integer;
OCQQ00COQ0:Integer;
begin
if OOQQ0QQOQ0(O0COO0COQ0).OQ0O0OQOQ0 then begin
Result:=True;
Exit;
end;
OOQQ0QQOQ0(O0COO0COQ0).OCO0QQQOQ0(OQQQ00COQ0,Result);
if OQQQ00COQ0>Length(OQCOO0COQ0)then begin
OCQQ00COQ0:=OOQQ0QQOQ0(O0COO0COQ0).OCC00OQOQ0.OCOQ0QQOQ0;
if OQQQ00COQ0>OCQQ00COQ0 then
SetLength(OQCOO0COQ0,OQQQ00COQ0)
else
SetLength(OQCOO0COQ0,OCQQ00COQ0);
end;
OOQQ0QQOQ0(O0COO0COQ0).O0Q0QQQOQ0(@OQCOO0COQ0[0],OQQQ00COQ0,Result);
OOQQ0QQOQ0(O0COO0COQ0).OOQ0QQQOQ0(Result);
end;
function OCQOO0COQ0.O0CQ00COQ0:Boolean;
var
OOCQ00COQ0:O0OOQ0COQ0;
OQCQ00COQ0:Integer;
OCCQ00COQ0:Integer;
O00C00COQ0:Integer;
begin
if OOQQ0QQOQ0(O0COO0COQ0).OQ0O0OQOQ0 then begin
Result:=True;
Exit;
end;
OOQQ0QQOQ0(O0COO0COQ0).OCO0QQQOQ0(OCCQ00COQ0,Result);
if OCCQ00COQ0>0 then begin
OCCOO0COQ0.Enter;
try
OOCQ00COQ0:=O0OOQ0COQ0(OOCOO0COQ0[OOCOO0COQ0.Count-1]);
OQCQ00COQ0:=O0OOQ0COQ0(OOCQ00COQ0).OQ0OQ0COQ0;
finally
OCCOO0COQ0.Leave;
end;
while True do begin
O00C00COQ0:=SizeOf(OCC0Q0COQ0)-OQCQ00COQ0;
if O00C00COQ0<=0 then begin
New(OOCQ00COQ0);
if OCCQ00COQ0<=SizeOf(OCC0Q0COQ0)then
O00C00COQ0:=OCCQ00COQ0
else
O00C00COQ0:=SizeOf(OCC0Q0COQ0);
OOQQ0QQOQ0(O0COO0COQ0).O0Q0QQQOQ0(@OOCQ00COQ0.OC0OQ0COQ0[0],O00C00COQ0,Result);
OQCQ00COQ0:=O00C00COQ0;
OCCOO0COQ0.Enter;
try
OOCQ00COQ0.OQ0OQ0COQ0:=OQCQ00COQ0;
OOCOO0COQ0.Add(OOCQ00COQ0);
finally
OCCOO0COQ0.Leave;
end;
end
else begin
if OCCQ00COQ0<=O00C00COQ0 then
O00C00COQ0:=OCCQ00COQ0;
OOQQ0QQOQ0(O0COO0COQ0).O0Q0QQQOQ0(@OOCQ00COQ0.OC0OQ0COQ0[OQCQ00COQ0],O00C00COQ0,Result);
OQCQ00COQ0:=OQCQ00COQ0+O00C00COQ0;
OCCOO0COQ0.Enter;
try
OOCQ00COQ0.OQ0OQ0COQ0:=OQCQ00COQ0;
finally
OCCOO0COQ0.Leave;
end;
end;
if O00C00COQ0<OCCQ00COQ0 then
OCCQ00COQ0:=OCCQ00COQ0-O00C00COQ0
else
Break;
end;
end;
OOQQ0QQOQ0(O0COO0COQ0).OOQ0QQQOQ0(Result);
end;
procedure OCQOO0COQ0.OO0C00COQ0;
var
OQ0C00COQ0:O0OOQ0COQ0;
OC0C00COQ0:Integer;
O0OC00COQ0:Integer;
begin
OCCOO0COQ0.Enter;
try
OQ0C00COQ0:=O0OOQ0COQ0(OOCOO0COQ0[OQ0Q00COQ0]);
OC0C00COQ0:=OQ0C00COQ0.OQ0OQ0COQ0;
O0OC00COQ0:=OOCOO0COQ0.Count;
finally
OCCOO0COQ0.Leave;
end;
if OO0Q00COQ0<OC0C00COQ0 then
OO0Q00COQ0:=OC0C00COQ0
else if OC0C00COQ0<SizeOf(OCC0Q0COQ0)then begin
OQO000COQ0;
OCCOO0COQ0.Enter;
try
OO0Q00COQ0:=OQ0C00COQ0.OQ0OQ0COQ0;
finally
OCCOO0COQ0.Leave;
end;
end
else if OC0C00COQ0>=SizeOf(OCC0Q0COQ0)then begin
if OQ0Q00COQ0+1>=O0OC00COQ0 then
OQO000COQ0;
OCCOO0COQ0.Enter;
try
if OQ0Q00COQ0+1>=OOCOO0COQ0.Count then
Exit;
if OOOQ00COQ0 and(OQ0Q00COQ0>0)then begin
OQ0C00COQ0:=O0OOQ0COQ0(OOCOO0COQ0[OQ0Q00COQ0]);
Marshal.FreeHGlobal(OQ0C00COQ0);
OOCOO0COQ0[OQ0Q00COQ0]:=nil;
end;
Inc(OQ0Q00COQ0);
OQ0C00COQ0:=O0OOQ0COQ0(OOCOO0COQ0[OQ0Q00COQ0]);
O00Q00COQ0:=@OQ0C00COQ0.OC0OQ0COQ0;
OO0Q00COQ0:=OQ0C00COQ0.OQ0OQ0COQ0;
OC0Q00COQ0:=0;
finally
OCCOO0COQ0.Leave;
end;
end;
end;
function OCQOO0COQ0.OOOC00COQ0(OQOC00COQ0:integer;OCOC00COQ0:Boolean=False):string;
var
O0QC00COQ0:WideString;
OOQC00COQ0:AnsiString;
begin
if OQOC00COQ0<=0 then
Result:=''
else if OCOC00COQ0 then begin
SetLengthA(OOQC00COQ0,OQOC00COQ0);
OCC000COQ0(PAnsiChar(OOQC00COQ0),OQOC00COQ0);
Result:=string(OOQC00COQ0);
end
else begin
SetLength(O0QC00COQ0,OQOC00COQ0);
OQOC00COQ0:=OQOC00COQ0*2;
OCC000COQ0(@O0QC00COQ0[1],OQOC00COQ0);
OCCCOCQOQ0(O0QC00COQ0);
Result:=string(O0QC00COQ0);
end;
end;
function OCQOO0COQ0.OQCC00COQ0:boolean;
var
OCCC00COQ0:O0OOQ0COQ0;
O00000COQ0:Integer;
begin
if OC0Q00COQ0<OO0Q00COQ0 then
Result:=True
else begin
OCCOO0COQ0.Enter;
try
if OQ0Q00COQ0+1<OOCOO0COQ0.Count then
Result:=True
else begin
OCCC00COQ0:=O0OOQ0COQ0(OOCOO0COQ0[OQ0Q00COQ0]);
O00000COQ0:=OCCC00COQ0.OQ0OQ0COQ0;
if OC0Q00COQ0<O00000COQ0 then
Result:=True
else
Result:=False;
end;
finally
OCCOO0COQ0.Leave
end;
end;
end;
procedure OCQOO0COQ0.OO0000COQ0;
var
OQ0000COQ0:Integer;
OC0000COQ0:O0OOQ0COQ0;
begin
OCCOO0COQ0.Enter;
try
O0OQ00COQ0:=-1;
for OQ0000COQ0:=1 to OOCOO0COQ0.Count-1 do begin
OC0000COQ0:=OOCOO0COQ0[OQ0000COQ0];
if OC0000COQ0<>nil then
Marshal.FreeHGlobal(OC0000COQ0);
end;
OOCOO0COQ0.Count:=1;
OC0000COQ0:=O0OOQ0COQ0(OOCOO0COQ0[0]);
OC0000COQ0.OQ0OQ0COQ0:=0;
O00Q00COQ0:=@OC0000COQ0.OC0OQ0COQ0;
OO0Q00COQ0:=0;
OQ0Q00COQ0:=0;
OC0Q00COQ0:=0;
finally
OCCOO0COQ0.Leave
end;
end;
procedure OCQOO0COQ0.O0O000COQ0;
var
OOO000COQ0:OQOCQCQOQ0;
begin
OOO000COQ0:=OOQQ0QQOQ0(O0COO0COQ0).OCC00OQOQ0;
if OOO000COQ0<>nil then
OOO000COQ0.O0OQ0QQOQ0.OCCQOCQOQ0
else
Exit;
OO0000COQ0;
end;
procedure OCQOO0COQ0.OQO000COQ0;
var
OCO000COQ0:OQOCQCQOQ0;
begin
OCO000COQ0:=OOQQ0QQOQ0(O0COO0COQ0).OCC00OQOQ0;
try
OCO000COQ0.O0OQ0QQOQ0.O00COCQOQ0(Self);
except
on E:SocketException do
OCO000COQ0.OOCOOQQOQ0(E.ErrorCode,E.Message,OOQQ0QQOQ0(O0COO0COQ0).OOC00OQOQ0);
on E:Exception do
raise;
end;
end;
procedure OCQOO0COQ0.O0Q000COQ0;
var
OOQ000COQ0:OQOCQCQOQ0;
begin
OOQ000COQ0:=OOQQ0QQOQ0(O0COO0COQ0).OCC00OQOQ0;
try
OOQ000COQ0.O0OQ0QQOQ0.OOOCOCQOQ0(Self);
except
on E:SocketException do
OOQ000COQ0.OOCOOQQOQ0(E.ErrorCode,E.Message,OOQQ0QQOQ0(O0COO0COQ0).OOC00OQOQ0);
on E:Exception do
raise;
end;
end;
procedure OCQOO0COQ0.OQQ000COQ0;
var
OCQ000COQ0:OQOCQCQOQ0;
begin
OCQ000COQ0:=OOQQ0QQOQ0(O0COO0COQ0).OCC00OQOQ0;
try
OCQ000COQ0.O0OQ0QQOQ0.OQ0COCQOQ0(Self);
except
on E:SocketException do
OCQ000COQ0.OOCOOQQOQ0(E.ErrorCode,E.Message,OOQQ0QQOQ0(O0COO0COQ0).OOC00OQOQ0);
on E:Exception do
raise;
end;
end;
procedure OCQOO0COQ0.O0C000COQ0(OOC000COQ0:NativeInt);
var
OQC000COQ0:Integer;
begin
while True do begin
OQC000COQ0:=OO0Q00COQ0-OC0Q00COQ0;
if OOC000COQ0<=OQC000COQ0 then begin
OC0Q00COQ0:=OC0Q00COQ0+OOC000COQ0;
Break;
end
else begin
if OQC000COQ0>0 then begin
OC0Q00COQ0:=OC0Q00COQ0+OQC000COQ0;
OOC000COQ0:=OOC000COQ0-OQC000COQ0;
end;
OO0C00COQ0;
end;
end;
end;
procedure OCQOO0COQ0.OCC000COQ0(O00O00COQ0:IntPtr;OO0O00COQ0:Integer);
var
OQ0O00COQ0:Integer;
begin
while True do begin
OQ0O00COQ0:=OO0Q00COQ0-OC0Q00COQ0;
if OO0O00COQ0<=OQ0O00COQ0 then begin
case OO0O00COQ0 of
0:
Break;
1:
Byte(O00O00COQ0^):=O00Q00COQ0[OC0Q00COQ0];
2:
Word(O00O00COQ0^):=PWord(@O00Q00COQ0[OC0Q00COQ0])^;
4:
Cardinal(O00O00COQ0^):=PCardinal(@O00Q00COQ0[OC0Q00COQ0])^;
{$IFDEF CPU64}
8:
UInt64(O00O00COQ0^):=PUInt64(@O00Q00COQ0[OC0Q00COQ0])^;
{$ENDIF}
else
Move(O00Q00COQ0[OC0Q00COQ0],O00O00COQ0^,OO0O00COQ0);
end;
OC0Q00COQ0:=OC0Q00COQ0+OO0O00COQ0;
Break;
end
else begin
if OQ0O00COQ0>0 then begin
Move(O00Q00COQ0[OC0Q00COQ0],O00O00COQ0^,OQ0O00COQ0);
O00O00COQ0:=PtrOffset(O00O00COQ0,OQ0O00COQ0);
OC0Q00COQ0:=OC0Q00COQ0+OQ0O00COQ0;
OO0O00COQ0:=OO0O00COQ0-OQ0O00COQ0;
end;
OO0C00COQ0;
end;
end;
end;
function OCQOO0COQ0.OC0O00COQ0:ShortInt;
begin
while OO0Q00COQ0-OC0Q00COQ0<SizeOf(ShortInt)do
OO0C00COQ0;
Result:=ShortInt(O00Q00COQ0[OC0Q00COQ0]);
Inc(OC0Q00COQ0);
end;
function OCQOO0COQ0.O0OO00COQ0:Byte;
begin
while OO0Q00COQ0-OC0Q00COQ0<SizeOf(Byte)do
OO0C00COQ0;
Result:=O00Q00COQ0[OC0Q00COQ0];
Inc(OC0Q00COQ0);
end;
function OCQOO0COQ0.OOOO00COQ0:SmallInt;
begin
OCC000COQ0(@Result,SizeOf(SmallInt));
end;
function OCQOO0COQ0.OQOO00COQ0:Word;
begin
OCC000COQ0(@Result,SizeOf(Word));
end;
function OCQOO0COQ0.OCOO00COQ0:Integer;
begin
OCC000COQ0(@Result,SizeOf(Integer));
end;
function OCQOO0COQ0.O0QO00COQ0:Cardinal;
begin
OCC000COQ0(@Result,SizeOf(Cardinal));
end;
function OCQOO0COQ0.OOQO00COQ0:Int64;
begin
OCC000COQ0(@Result,SizeOf(Int64));
end;
function OCQOO0COQ0.OQQO00COQ0:UInt64;
begin
OCC000COQ0(@Result,SizeOf(UInt64));
end;
function OCQOO0COQ0.OCQO00COQ0:Single;
begin
OCC000COQ0(@Result,SizeOf(Single));
end;
function OCQOO0COQ0.O0CO00COQ0:Double;
begin
OCC000COQ0(@Result,SizeOf(Double));
end;
function OCQOO0COQ0.OOCO00COQ0:TBytes;
var
OQCO00COQ0:Byte;
begin
OCC000COQ0(@OQCO00COQ0,SizeOf(Byte));
if OQCO00COQ0=0 then begin
Result:=nil;
Exit;
end;
SetLength(Result,OQCO00COQ0);
OCC000COQ0(@Result[0],OQCO00COQ0);
end;
function OCQOO0COQ0.OCCO00COQ0:TBytes;
var
O00QC0COQ0:Word;
begin
OCC000COQ0(@O00QC0COQ0,SizeOf(Word));
if O00QC0COQ0=0 then begin
Result:=nil;
Exit;
end;
SetLength(Result,O00QC0COQ0);
OCC000COQ0(@Result[0],O00QC0COQ0);
end;
function OCQOO0COQ0.OO0QC0COQ0(OQ0QC0COQ0:Boolean=False):string;
var
OC0QC0COQ0:Byte;
begin
OCC000COQ0(@OC0QC0COQ0,SizeOf(Byte));
Result:=OOOC00COQ0(OC0QC0COQ0,OQ0QC0COQ0);
end;
function OCQOO0COQ0.O0OQC0COQ0(OOOQC0COQ0:Boolean=False):string;
var
OQOQC0COQ0:Word;
begin
OCC000COQ0(@OQOQC0COQ0,SizeOf(Word));
Result:=OOOC00COQ0(OQOQC0COQ0,OOOQC0COQ0);
end;
procedure OCQOO0COQ0.OCOQC0COQ0(O0QQC0COQ0:IntPtr;OOQQC0COQ0:Integer;OQQQC0COQ0:Integer=0);
var
OCQQC0COQ0:O00OQ0COQ0;
O0CQC0COQ0:Integer;
OOCQC0COQ0:Integer;
OQCQC0COQ0:Integer;
begin
OCQQC0COQ0:=O00Q00COQ0;
O0CQC0COQ0:=OO0Q00COQ0;
OOCQC0COQ0:=OQ0Q00COQ0;
OQCQC0COQ0:=OC0Q00COQ0;
OOOQ00COQ0:=False;
try
if OQQQC0COQ0>0 then
O0C000COQ0(OQQQC0COQ0);
OCC000COQ0(O0QQC0COQ0,OOQQC0COQ0);
finally
O00Q00COQ0:=OCQQC0COQ0;
OO0Q00COQ0:=O0CQC0COQ0;
OQ0Q00COQ0:=OOCQC0COQ0;
OC0Q00COQ0:=OQCQC0COQ0;
OOOQ00COQ0:=True;
end;
end;
function OCQOO0COQ0.OCCQC0COQ0:Byte;
var
O00CC0COQ0:O00OQ0COQ0;
OO0CC0COQ0:Integer;
OQ0CC0COQ0:Integer;
OC0CC0COQ0:Integer;
begin
if OO0Q00COQ0-OC0Q00COQ0>=SizeOf(Byte)then
Result:=O00Q00COQ0[OC0Q00COQ0]
else begin
O00CC0COQ0:=O00Q00COQ0;
OO0CC0COQ0:=OO0Q00COQ0;
OQ0CC0COQ0:=OQ0Q00COQ0;
OC0CC0COQ0:=OC0Q00COQ0;
OOOQ00COQ0:=False;
try
repeat
OO0C00COQ0
until OO0Q00COQ0-OC0Q00COQ0>=SizeOf(Byte);
Result:=O00Q00COQ0[OC0Q00COQ0];
finally
O00Q00COQ0:=O00CC0COQ0;
OO0Q00COQ0:=OO0CC0COQ0;
OQ0Q00COQ0:=OQ0CC0COQ0;
OC0Q00COQ0:=OC0CC0COQ0;
OOOQ00COQ0:=True;
end;
end;
end;
procedure OCQOO0COQ0.O0OCC0COQ0(OOOCC0COQ0:NativeInt);
begin
O0OQ00COQ0:=OOOCC0COQ0;
end;
procedure OCQOO0COQ0.OQOCC0COQ0;
var
OCOCC0COQ0:Integer;
begin
if O0OQ00COQ0<0 then
Exit;
OCOCC0COQ0:=O0OQ00COQ0-O0QCC0COQ0;
O0OQ00COQ0:=-1;
if OCOCC0COQ0>0 then
O0C000COQ0(OCOCC0COQ0);
end;
end.
