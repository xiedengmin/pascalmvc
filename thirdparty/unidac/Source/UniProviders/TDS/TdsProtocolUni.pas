//////////////////////////////////////////////////
//  SQL Server Data Access Components
//  Copyright © 1998-2021 Devart. All right reserved.
//  Access in Direct mode
//////////////////////////////////////////////////
{$I Tds.inc}
unit TdsProtocolUni;
interface
uses
{$IFDEF MSWINDOWS}
Windows,
{$ENDIF}
Classes,SysUtils,TypInfo,DateUtils,Variants,FmtBcd,SyncObjs,
{$IFNDEF FPC}
StrUtils,SqlTimSt,
{$ENDIF}
{$IFDEF LOG_PACKETS}
LogHandler,
{$ENDIF}
CRTypes,CRFunctions,CRNumeric,CRTimeStamp,CRAccess,CRVio,CLRClasses,CRParser,MemData,
{$IFNDEF UNIDACPRO}
TdsTypes,TdsConsts,TdsPackets,TdsNet,TdsSMPProtocol,SqlClasses;
{$ELSE}
TdsTypesUni,TdsConstsUni,TdsPacketsUni,TdsNetUni,TdsSMPProtocolUni,SqlClassesUni;
{$ENDIF}
type
OOCCCCQOQ0=(OQQCCCQOQ0,OCQCCCQOQ0,O0CCCCQOQ0);
OQCCCCQOQ0=record
OCCCCCQOQ0,O000CCQOQ0:Integer;
OO00CCQOQ0,OQ00CCQOQ0:Byte;
OC00CCQOQ0,O0O0CCQOQ0,OOO0CCQOQ0:string;
end;
OQO0CCQOQ0=array of OQCCCCQOQ0;
OCO0CCQOQ0=procedure(const O0Q0CCQOQ0:array of const)of object;
OOQ0CCQOQ0=procedure(OQQ0CCQOQ0:Integer;const OCQ0CCQOQ0:string;O0C0CCQOQ0:TObject)of object;
OOC0CCQOQ0=procedure(const OQC0CCQOQ0:OQO0CCQOQ0;OCC0CCQOQ0:TObject)of object;
O00OCCQOQ0=procedure(const OO0OCCQOQ0:OQCCCCQOQ0;OQ0OCCQOQ0:TObject)of object;
OC0OCCQOQ0=procedure(O0OOCCQOQ0:Integer;OOOOCCQOQ0:Integer;const OQOOCCQOQ0:boolean)of object;
OCOOCCQOQ0=procedure(O0QOCCQOQ0:Integer;OOQOCCQOQ0:Integer;const OQQOCCQOQ0:Variant)of object;
OCQOCCQOQ0=function(O0COCCQOQ0:Integer;OOCOCCQOQ0:Integer):PVariant of object;
OQCOCCQOQ0=function(const OCCOCCQOQ0:string):Integer of object;
O00QQCQOQ0=function(OO0QQCQOQ0:Integer;OQ0QQCQOQ0:Integer):TSharedObject of object;
OC0QQCQOQ0=procedure(O0OQQCQOQ0:Integer;OOOQQCQOQ0:OQQCC0COQ0)of object;
OQOQQCQOQ0=^OCOQQCQOQ0;
OCOQQCQOQ0=record
O0QQQCQOQ0:string;
OOQQQCQOQ0:Integer;
OQQQQCQOQ0:Integer;
OCQQQCQOQ0:TParamDirection;
O0CQQCQOQ0,OOCQQCQOQ0:integer;
OQCQQCQOQ0,OCCQQCQOQ0:Boolean;
O00CQCQOQ0:Byte;
OO0CQCQOQ0:Cardinal;
OQ0CQCQOQ0:Byte;
OC0CQCQOQ0:O0QCQQCOQ0;
O0OCQCQOQ0:OC0QQCQOQ0;
end;
OOOCQCQOQ0=array of OCOQQCQOQ0;
OQOCQCQOQ0=class;
OOQQ0QQOQ0=class
protected
OQQQ0QQOQ0:OCQOO0COQ0;
OCQQ0QQOQ0:OQQCC0COQ0;
{$IFDEF AUTOREFCOUNT}[weak]{$ENDIF}
O0CQ0QQOQ0:OQOCQCQOQ0;
{$IFDEF AUTOREFCOUNT}[weak]{$ENDIF}
OOCQ0QQOQ0:TObject;
OQCQ0QQOQ0:OQO0CCQOQ0;
OCCQ0QQOQ0:TCriticalSection;
O00C0QQOQ0:string;
OO0C0QQOQ0:OQO0QQCOQ0;
OQ0C0QQOQ0:OOC0CQCOQ0;
OC0C0QQOQ0:Boolean;
O0OC0QQOQ0:TSQLParserClass;
OOOC0QQOQ0:Byte;
OQOC0QQOQ0:Byte;
OCOC0QQOQ0:Word;
O0QC0QQOQ0:boolean;
OOQC0QQOQ0:Byte;
OQQC0QQOQ0:NativeInt;
OCQC0QQOQ0:Boolean;
O0CC0QQOQ0:Boolean;
OOCC0QQOQ0:Boolean;
OQCC0QQOQ0:Boolean;
OCCC0QQOQ0:Boolean;
O0000QQOQ0:Boolean;
OO000QQOQ0:Boolean;
OQ000QQOQ0:Cardinal;
OC000QQOQ0:Boolean;
O0O00QQOQ0:Boolean;
OOO00QQOQ0:Boolean;
OQO00QQOQ0:boolean;
OCO00QQOQ0:OC0OCCQOQ0;
O0Q00QQOQ0:OCOOCCQOQ0;
OOQ00QQOQ0:OCQOCCQOQ0;
OQQ00QQOQ0:O00QQCQOQ0;
procedure OCQ00QQOQ0(O0C00QQOQ0:OQOCQCQOQ0);virtual;
procedure OOC00QQOQ0;
function OQC00QQOQ0:OQQOO0COQ0;virtual;
function OCC00QQOQ0:byte;virtual;
procedure O00O0QQOQ0;
function OO0O0QQOQ0(const OQ0O0QQOQ0:string):Integer;
function O0OO0QQOQ0(const OOOO0QQOQ0:O00CQQCOQ0):Encoding;virtual;abstract;
function OQOO0QQOQ0(const OCOO0QQOQ0:O00CQQCOQ0):Encoding;virtual;abstract;
function O0QO0QQOQ0:Encoding;virtual;abstract;
class function OOQO0QQOQ0(const OQQO0QQOQ0:AnsiString):TBytes;
class function OCQO0QQOQ0(O0CO0QQOQ0:Pointer;OOCO0QQOQ0:Integer):TBytes;
class function OQCO0QQOQ0(OCCO0QQOQ0:Int64;O00QCQQOQ0:PSQLTimeStamp;OO0QCQQOQ0:Word;OQ0QCQQOQ0:boolean):Integer;
class function OC0QCQQOQ0(O0OQCQQOQ0:Int64;OOOQCQQOQ0:PSQLTimeStampOffset;OQOQCQQOQ0:Word;OCOQCQQOQ0:boolean):Integer;
function O0QQCQQOQ0(const OOQQCQQOQ0:O0Q0QQCOQ0;OQQQCQQOQ0:Pointer;OCQQCQQOQ0:Integer):Variant;virtual;
function O0CQCQQOQ0():Boolean;virtual;
function OOCQCQQOQ0(var OQCQCQQOQ0:Integer;OCCQCQQOQ0:Integer;O00CCQQOQ0,OO0CCQQOQ0:Boolean):Integer;
procedure OQ0CCQQOQ0(OC0CCQQOQ0:OCO0QQCOQ0);virtual;
procedure O0OCCQQOQ0(OOOCCQQOQ0:OCO0QQCOQ0);virtual;
procedure OQOCCQQOQ0(OCOCCQQOQ0:OCO0QQCOQ0);virtual;
procedure O0QCCQQOQ0(const OOQCCQQOQ0:O0Q0QQCOQ0;var OQQCCQQOQ0:OQ00QQCOQ0;
OCQCCQQOQ0:Boolean);virtual;abstract;
function O0CCCQQOQ0(const OOCCCQQOQ0:Variant;OQCCCQQOQ0:Boolean):Cardinal;
procedure O000CQQOQ0(OO00CQQOQ0:OC0OCCQOQ0;OQ00CQQOQ0:OCOOCCQOQ0;OC00CQQOQ0:O00QQCQOQ0;
const O0O0CQQOQ0:OCOQQCQOQ0;const OOO0CQQOQ0:O0Q0QQCOQ0;const OQO0CQQOQ0:OQ00QQCOQ0);virtual;
procedure O0C0CQQOQ0;
procedure OQC0CQQOQ0(out OCC0CQQOQ0:boolean);virtual;abstract;
procedure O00OCQQOQ0(const OO0OCQQOQ0:OQO0QQCOQ0;OQ0OCQQOQ0:boolean);
procedure OCOOCQQOQ0;
procedure OQQOCQQOQ0(OCQOCQQOQ0,O0COCQQOQ0:Word;OOCOCQQOQ0:Int64);
function OQCOCQQOQ0(OCCOCQQOQ0,O00QQQQOQ0:Word):Boolean;virtual;
function OO0QQQQOQ0(const OQ0QQQQOQ0:string):string;
function OCOQQQQOQ0(const O0QQQQQOQ0:string;const OOQQQQQOQ0:array of integer):Boolean;
function OQCQQQQOQ0(const OCCQQQQOQ0:string;const O00CQQQOQ0:array of string):Boolean;
function OOOCQQQOQ0(const OQOCQQQOQ0:string):string;
procedure OOCCQQQOQ0(OQ0COQQOQ0:Byte;OC0COQQOQ0:Byte=0);virtual;
procedure OQCCQQQOQ0;
procedure OCCCQQQOQ0;
procedure O000QQQOQ0;
public
OO00QQQOQ0:OO0QOOCOQ0;
OQ00QQQOQ0:TStringArray;
OC00QQQOQ0:OOOCQCQOQ0;
constructor Create(OOO0QQQOQ0:OQOCQCQOQ0);virtual;
destructor Destroy;override;
procedure OCO0QQQOQ0(out OO0QOQQOQ0:Integer;out OQ0QOQQOQ0:Boolean);virtual;
procedure O0Q0QQQOQ0(OCQQOQQOQ0:IntPtr;O0CQOQQOQ0:Integer;OOCQOQQOQ0:Boolean);virtual;
procedure OOQ0QQQOQ0(OQQ0QQQOQ0:Boolean);
procedure OCQ0QQQOQ0;
procedure O0C0QQQOQ0;
procedure OOC0QQQOQ0;
class function OQC0QQQOQ0(OCC0QQQOQ0:Pointer;O00OQQQOQ0:Integer):Int64;
class function OO0OQQQOQ0(OQ0OQQQOQ0:Pointer;OC0OQQQOQ0:Integer):Double;
class function O0OOQQQOQ0(OOOOQQQOQ0:Pointer;OQOOQQQOQ0:Integer):TDBNumeric;
class function O0QOQQQOQ0(OOQOQQQOQ0:Byte;OQQOQQQOQ0:Word;OCQOQQQOQ0:Pointer;O0COQQQOQ0:Integer):TDateTime;virtual;
class function OQCOQQQOQ0(OCCOQQQOQ0,O00QOOQOQ0:Word;OO0QOOQOQ0:Pointer;OQ0QOOQOQ0:Integer):Int64;
class function OOOQOOQOQ0(OQOQOOQOQ0,OCOQOOQOQ0:Word;O0QQOOQOQ0:Pointer;OOQQOOQOQ0:Integer):Double;
class function OCQQOOQOQ0(O0CQOOQOQ0,OOCQOOQOQ0:Word;OQCQOOQOQ0:Pointer;OCCQOOQOQ0:Integer):TBcd;
class function OQ0COOQOQ0(OC0COOQOQ0,O0OCOOQOQ0:Word;OOOCOOQOQ0:Pointer;OQOCOOQOQ0:Integer):TDBNumeric;virtual;
class procedure OCOCOOQOQ0(O0QCOOQOQ0:Byte;OOQCOOQOQ0:Word;OQQCOOQOQ0:Integer;OCQCOOQOQ0,O0CCOOQOQ0:Pointer);virtual;
class procedure OCCCOOQOQ0(O000OOQOQ0:Word;OO00OOQOQ0:Integer;OQ00OOQOQ0,OC00OOQOQ0:Pointer);
function OCO0OOQOQ0(var O0Q0OOQOQ0:OQ00QQCOQ0):Variant;virtual;
procedure OOQ0OOQOQ0(const OQQ0OOQOQ0:OQ00QQCOQ0;OCQ0OOQOQ0:TBlob;
const O0C0OOQOQ0:O00CQQCOQ0;OOC0OOQOQ0:OOCCCCQOQ0);
function OC0OOOQOQ0(const O0OOOOQOQ0:O0Q0QQCOQ0;OOOOOOQOQ0:Pointer;
var OQOOOOQOQ0:Integer;OCOOOOQOQ0:Integer;O0QOOOQOQ0,OOQOOOQOQ0:boolean;OQQOOOQOQ0:TStringHeap):Pointer;
function OQ0Q0OQOQ0(const OC0Q0OQOQ0:O0Q0QQCOQ0;O0OQ0OQOQ0:Pointer;
var OOOQ0OQOQ0:Integer;OQOQ0OQOQ0:Integer;OCOQ0OQOQ0,O0QQ0OQOQ0:boolean;OOQQ0OQOQ0:TStringHeap):Pointer;
function OQOC0OQOQ0(const OCOC0OQOQ0:OQO0QQCOQ0;O0QC0OQOQ0:boolean=False):boolean;
procedure OOQC0OQOQ0(OQQC0OQOQ0:Boolean);virtual;abstract;
procedure OCQC0OQOQ0(const O0CC0OQOQ0:string);virtual;abstract;
procedure OOCC0OQOQ0(OQCC0OQOQ0:Integer;var OCCC0OQOQ0:Integer);virtual;abstract;
function O0000OQOQ0(const OO000OQOQ0:string):string;virtual;
procedure OOQ00OQOQ0;
procedure OQQ00OQOQ0;
property OCQ00OQOQ0:OCQOO0COQ0 read OQQQ0QQOQ0;
property O0C00OQOQ0:Boolean read OC0C0QQOQ0 write OC0C0QQOQ0;
property OOC00OQOQ0:TObject read OOCQ0QQOQ0 write OOCQ0QQOQ0;
property OQC00OQOQ0:TSQLParserClass read O0OC0QQOQ0 write O0OC0QQOQ0;
property OCC00OQOQ0:OQOCQCQOQ0 read O0CQ0QQOQ0 write OCQ00QQOQ0;
property O00O0OQOQ0:string read O00C0QQOQ0 write O00C0QQOQ0;
property OO0O0OQOQ0:Word read OCOC0QQOQ0;
property OQ0O0OQOQ0:Boolean read O0QC0QQOQ0;
property OC0O0OQOQ0:NativeInt read OQQC0QQOQ0 write OQQC0QQOQ0;
property O0OO0OQOQ0:Boolean read OCQC0QQOQ0;
property OOOO0OQOQ0:Boolean read OOCC0QQOQ0;
property OQOO0OQOQ0:Boolean read O0CC0QQOQ0;
property OCOO0OQOQ0:Boolean read O0000QQOQ0;
property O0QO0OQOQ0:Boolean read OC000QQOQ0 write OC000QQOQ0;
property OOQO0OQOQ0:Boolean read O0O00QQOQ0 write O0O00QQOQ0;
property OQQO0OQOQ0:Boolean read OOO00QQOQ0 write OOO00QQOQ0;
property OCQO0OQOQ0:boolean read OQO00QQOQ0 write OQO00QQOQ0;
property O0CO0OQOQ0:OC0OCCQOQ0 read OCO00QQOQ0 write OCO00QQOQ0;
property OOCO0OQOQ0:OCOOCCQOQ0 read O0Q00QQOQ0 write O0Q00QQOQ0;
property OQCO0OQOQ0:OCQOCCQOQ0 read OOQ00QQOQ0 write OOQ00QQOQ0;
property OCCO0OQOQ0:O00QQCQOQ0 read OQQ00QQOQ0 write OQQ00QQOQ0;
end;
O00QCOQOQ0=record
OO0QCOQOQ0:string;
OQ0QCOQOQ0:string;
OC0QCOQOQ0:string;
O0OQCOQOQ0:string;
OOOQCOQOQ0:string;
OQOQCOQOQ0:string;
OCOQCOQOQ0:string;
O0QQCOQOQ0:Boolean;
OOQQCOQOQ0:string;
OQQQCOQOQ0:Integer;
OCQQCOQOQ0:boolean;
O0CQCOQOQ0:boolean;
OOCQCOQOQ0:boolean;
end;
OQOCQCQOQ0=class
private
OCOCQCQOQ0:TCriticalSection;
O0QCQCQOQ0:OCOQOCQOQ0;
function OOQCQCQOQ0:Integer;
procedure OQQCQCQOQ0(OCQCQCQOQ0:Integer);
function O0CCQCQOQ0:Integer;
procedure OOCCQCQOQ0(OQCCQCQOQ0:Integer);
protected
OCCCQCQOQ0:TCRVio;
O000QCQOQ0:OO0OOCQOQ0;
OO00QCQOQ0:O00QCOQOQ0;
OQ00QCQOQ0:Boolean;
OC00QCQOQ0:Word;
O0O0QCQOQ0:Integer;
OOO0QCQOQ0:Cardinal;
OQO0QCQOQ0:Encoding;
OCO0QCQOQ0:OOQ0CCQOQ0;
O0Q0QCQOQ0:OOC0CCQOQ0;
OOQ0QCQOQ0:O00OCCQOQ0;
OQQ0QCQOQ0:OCO0CCQOQ0;
OCQ0QCQOQ0:OCO0CCQOQ0;
O0C0QCQOQ0:OCO0CCQOQ0;
OOC0QCQOQ0:OCO0CCQOQ0;
OQC0QCQOQ0:OCO0CCQOQ0;
OCC0QCQOQ0:OCO0CCQOQ0;
function O00OQCQOQ0(OO0OQCQOQ0:pointer;OQ0OQCQOQ0,OC0OQCQOQ0:Integer):Integer;virtual;
function O0OOQCQOQ0(OOOOQCQOQ0:pointer;OQOOQCQOQ0,OCOOQCQOQ0:Integer):Integer;virtual;
function O0QOQCQOQ0:Boolean;
function OOQOQCQOQ0:boolean;
function OQQOQCQOQ0(OCQOQCQOQ0:IntPtr;O0COQCQOQ0,OOCOQCQOQ0:Integer;OQCOQCQOQ0:integer):Integer;
procedure OCCOQCQOQ0(out O00QOQQOQ0:Byte;out OO0QOQQOQ0:Integer;out OQ0QOQQOQ0:Boolean;OC0QOQQOQ0:integer);
procedure OQQQOQQOQ0(OCQQOQQOQ0:IntPtr;O0CQOQQOQ0:Integer;OOCQOQQOQ0:Boolean;OQCQOQQOQ0:integer);
procedure OO0COQQOQ0(OQ0COQQOQ0,OC0COQQOQ0:Byte;O0OCOQQOQ0:OQQCC0COQ0;OOOCOQQOQ0:integer);
public
constructor Create;virtual;
destructor Destroy;override;
procedure OCCCOQQOQ0(O000OQQOQ0:TProxyOptions;const OO00OQQOQ0:string;OQ00OQQOQ0:integer;OC00OQQOQ0:TIPVersion);
procedure O0O0OQQOQ0;virtual;
procedure OOO0OQQOQ0;{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OQO0OQQOQ0;{$IFDEF USE_INLINE}inline;{$ENDIF}
procedure OCO0OQQOQ0(const O0Q0OQQOQ0:O00QCOQOQ0;OOQ0OQQOQ0:boolean;
OQQ0OQQOQ0:OOQ0CCQOQ0;OCQ0OQQOQ0:OOC0CCQOQ0;O0C0OQQOQ0:O00OCCQOQ0);virtual;
procedure OOC0OQQOQ0(OQC0OQQOQ0:Integer);overload;
function OCC0OQQOQ0:Integer;
function O00OOQQOQ0:Encoding;
procedure OO0OOQQOQ0(OQ0OOQQOQ0:Word);overload;
procedure OO0OOQQOQ0(OC0OOQQOQ0,O0OOOQQOQ0:Byte);overload;
function OOOOOQQOQ0:Word;
function OQOOOQQOQ0:boolean;virtual;abstract;
procedure OCOOOQQOQ0;
property O0QOOQQOQ0:OCO0CCQOQ0 read OQQ0QCQOQ0 write OQQ0QCQOQ0;
property OOQOOQQOQ0:OCO0CCQOQ0 read OCQ0QCQOQ0 write OCQ0QCQOQ0;
property OQQOOQQOQ0:OCO0CCQOQ0 read O0C0QCQOQ0 write O0C0QCQOQ0;
property OCQOOQQOQ0:OCO0CCQOQ0 read OOC0QCQOQ0 write OOC0QCQOQ0;
property O0COOQQOQ0:OCO0CCQOQ0 read OQC0QCQOQ0 write OQC0QCQOQ0;
property OOCOOQQOQ0:OOQ0CCQOQ0 read OCO0QCQOQ0 write OCO0QCQOQ0;
property OQCOOQQOQ0:OOC0CCQOQ0 read O0Q0QCQOQ0;
property OCCOOQQOQ0:O00OCCQOQ0 read OOQ0QCQOQ0;
property O00Q0QQOQ0:OCO0CCQOQ0 read OCC0QCQOQ0 write OCC0QCQOQ0;
property OO0Q0QQOQ0:TCRVio read OCCCQCQOQ0 write OCCCQCQOQ0;
property OQ0Q0QQOQ0:Integer read OOQCQCQOQ0 write OQQCQCQOQ0;
property OC0Q0QQOQ0:Integer read O0CCQCQOQ0 write OOCCQCQOQ0;
property O0OQ0QQOQ0:OCOQOCQOQ0 read O0QCQCQOQ0;
property OOOQ0QQOQ0:Boolean read O0QOQCQOQ0;
property OQOQ0QQOQ0:Boolean read OOQOQCQOQ0;
property OCOQ0QQOQ0:Word read OC00QCQOQ0 write OC00QCQOQ0;
property O0QQ0QQOQ0:Cardinal read OOO0QCQOQ0;
end;
OQCQCOQOQ0=class of OOQQ0QQOQ0;
OCCQCOQOQ0=class of OQOCQCQOQ0;
implementation
uses
CRVioTcp;
const
O00CCOQOQ0='[';
OO0CCOQOQ0=']';
OQ0CCOQOQ0=MinsPerHour*SecsPerMin;
OC0CCOQOQ0=OQ0CCOQOQ0*MSecsPerSec;
O0OCCOQOQ0=SecsPerMin*MSecsPerSec;
constructor OOQQ0QQOQ0.Create(OOO0QQQOQ0:OQOCQCQOQ0);
begin
inherited Create;
OCCQ0QQOQ0:=TCriticalSection.Create;
OQQQ0QQOQ0:=OCQOO0COQ0.Create(Self);
OCQQ0QQOQ0:=OQC00QQOQ0.Create;
O0CQ0QQOQ0:=OOO0QQQOQ0;
O0QC0QQOQ0:=True;
end;
destructor OOQQ0QQOQ0.Destroy;
begin
{$IFDEF LOG_PACKETS}
AddToLog(Format('TDSContext.Destroy %p',[Pointer(Self)]));
{$ENDIF}
OQQQ0QQOQ0.Free;
OCQQ0QQOQ0.Free;
O0CQ0QQOQ0:=nil;
OCCQ0QQOQ0.Free;
inherited;
end;
procedure OOQQ0QQOQ0.OCQ00QQOQ0(O0C00QQOQ0:OQOCQCQOQ0);
begin
O0CQ0QQOQ0:=O0C00QQOQ0;
end;
function OOQQ0QQOQ0.OQC00QQOQ0:OQQOO0COQ0;
begin
Result:=OQQCC0COQ0;
end;
function OOQQ0QQOQ0.OO0O0QQOQ0(const OQ0O0QQOQ0:string):Integer;
var
OC0O0QQOQ0:Integer;
begin
Result:=-1;
for OC0O0QQOQ0:=0 to High(OC00QQQOQ0)do
if UpperCase(OC00QQQOQ0[OC0O0QQOQ0].O0QQQCQOQ0)=UpperCase(OQ0O0QQOQ0)then begin
Result:=OC0O0QQOQ0;
Exit;
end;
end;
procedure OOQQ0QQOQ0.OCQ0QQQOQ0;
begin
OCCC0QQOQ0:=False;
OQCC0QQOQ0:=False;
O0CC0QQOQ0:=False;
OCQC0QQOQ0:=False;
OO00QQQOQ0:=nil;
OQ00QQQOQ0:=nil;
OO0C0QQOQ0:=nil;
OQQC0QQOQ0:=0;
if not OQQQ0QQOQ0.OQCC00COQ0 then
OQQQ0QQOQ0.OO0000COQ0;
end;
procedure OOQQ0QQOQ0.O0C0QQQOQ0;
begin
OCQ0QQQOQ0;
OO000QQOQ0:=False;
O0000QQOQ0:=False;
OOCC0QQOQ0:=False;
end;
procedure OOQQ0QQOQ0.OOC00QQOQ0;
begin
SetLength(OQCQ0QQOQ0,0);
end;
procedure OOQQ0QQOQ0.O00O0QQOQ0;
begin
if(OC00QQQOQ0<>nil)and(OC00QQQOQ0[0].OCQQQCQOQ0=pdResult)then begin
Assert(Assigned(O0Q00QQOQ0));
O0Q00QQOQ0(OC00QQQOQ0[0].OOQQQCQOQ0,OC00QQQOQ0[0].OQQQQCQOQ0,OQ000QQOQ0);
end;
end;
class function OOQQ0QQOQ0.OOQO0QQOQ0(const OQQO0QQOQ0:AnsiString):TBytes;
begin
SetLength(Result,LengthA(OQQO0QQOQ0));
if LengthA(OQQO0QQOQ0)>0 then
Move(PAnsiChar(OQQO0QQOQ0)^,Result[0],LengthA(OQQO0QQOQ0));
end;
class function OOQQ0QQOQ0.OCQO0QQOQ0(O0CO0QQOQ0:Pointer;OOCO0QQOQ0:Integer):TBytes;
begin
SetLength(Result,OOCO0QQOQ0);
if OOCO0QQOQ0>0 then
Move(O0CO0QQOQ0^,Result[0],OOCO0QQOQ0);
end;
class function OOQQ0QQOQ0.OQC0QQQOQ0(OCC0QQQOQ0:Pointer;O00OQQQOQ0:Integer):Int64;
begin
Result:=0;
case O00OQQQOQ0 of
8:begin
Int64Rec(Result).Hi:=OQ0OCQCOQ0(OCC0QQQOQ0).O0OOCQCOQ0;
Int64Rec(Result).Lo:=OQ0OCQCOQ0(OCC0QQQOQ0).OOOOCQCOQ0;
end;
4:
Result:=PInteger(OCC0QQQOQ0)^;
else
raise Exception.CreateFmt('Packet reading error: Wrong Currency size %d',[O00OQQQOQ0]);
end;
end;
class function OOQQ0QQOQ0.OO0OQQQOQ0(OQ0OQQQOQ0:Pointer;OC0OQQQOQ0:Integer):Double;
begin
Result:=OQC0QQQOQ0(OQ0OQQQOQ0,OC0OQQQOQ0)/10000;
end;
class function OOQQ0QQOQ0.O0OOQQQOQ0(OOOOQQQOQ0:Pointer;OQOOQQQOQ0:Integer):TDBNumeric;
var
OCOOQQQOQ0:integer;
begin
FillChar(Result,SizeOf(Result),0);
case OQOOQQQOQ0 of
8:begin
Move(OQ0OCQCOQ0(OOOOQQQOQ0).OOOOCQCOQ0,Result.Val[0],4);
Move(OQ0OCQCOQ0(OOOOQQQOQ0).O0OOCQCOQ0,Result.Val[4],4);
Result.Precision:=19;
Result.Scale:=4;
if Result.ValLow<0 then begin
Result.ValLow:=-Result.ValLow;
Result.Sign:=0;
end
else
Result.Sign:=1;
end;
4:begin
OCOOQQQOQ0:=PInteger(OOOOQQQOQ0)^;
if OCOOQQQOQ0<0 then begin
OCOOQQQOQ0:=-OCOOQQQOQ0;
Result.Sign:=0;
end
else
Result.Sign:=1;
Result.ValLow:=OCOOQQQOQ0;
Result.Precision:=10;
Result.Scale:=4;
end;
else
raise Exception.CreateFmt('Packet reading error: Wrong Currency size %d',[OQOOQQQOQ0]);
end;
end;
class function OOQQ0QQOQ0.O0QOQQQOQ0(OOQOQQQOQ0:Byte;OQQOQQQOQ0:Word;OCQOQQQOQ0:Pointer;O0COQQQOQ0:Integer):TDateTime;
var
OOCOQQQOQ0:Int64;
begin
case OOQOQQQOQ0 of
OQCOQCCOQ0,OO0QOQCOQ0,O0QQOQCOQ0:begin
case O0COQQQOQ0 of
4:begin
Result:=OO0QQQCOQ0(OCQOQQQOQ0).O0OQQQCOQ0/O00C0QCOQ0;
OOCOQQQOQ0:=(OO0QQQCOQ0(OCQOQQQOQ0).OC0QQQCOQ0+2);
if OOCOQQQOQ0>=0 then
Result:=OOCOQQQOQ0+Result
else
Result:=OOCOQQQOQ0-Result;
end;
8:begin
Result:=((OOQOCQCOQ0(OCQOQQQOQ0).O0COCQCOQ0*20+3)div 6)/MSecsPerDay;
OOCOQQQOQ0:=OOQOCQCOQ0(OCQOQQQOQ0).OCQOCQCOQ0+2;
if OOCOQQQOQ0>=0 then
Result:=OOCOQQQOQ0+Result
else
Result:=OOCOQQQOQ0-Result;
end;
else
raise Exception.CreateFmt('Packet reading error: Wrong TDS_DATETIMNTYPE size %d',[O0COQQQOQ0]);
end;
end;
else
raise Exception.CreateFmt('Packet reading error: DateTime type %d',[OOQOQQQOQ0]);
end;
end;
class function OOQQ0QQOQ0.OQCOQQQOQ0(OCCOQQQOQ0,O00QOOQOQ0:Word;OO0QOOQOQ0:Pointer;OQ0QOOQOQ0:Integer):Int64;
var
OC0QOOQOQ0:Double;
O0OQOOQOQ0:currency;
begin
OC0QOOQOQ0:=OOOQOOQOQ0(OCCOQQQOQ0,O00QOOQOQ0,OO0QOOQOQ0,OQ0QOOQOQ0);
O0OQOOQOQ0:=OC0QOOQOQ0;
Result:=Int64((@O0OQOOQOQ0)^);
end;
class function OOQQ0QQOQ0.OOOQOOQOQ0(OQOQOOQOQ0,OCOQOOQOQ0:Word;O0QQOOQOQ0:Pointer;OOQQOOQOQ0:Integer):Double;
var
OQQQOOQOQ0:TDBNumeric;
begin
OQQQOOQOQ0:=OQ0COOQOQ0(OQOQOOQOQ0,OCOQOOQOQ0,O0QQOOQOQ0,OOQQOOQOQ0);
Result:=DBNumericToDouble(OQQQOOQOQ0);
end;
class function OOQQ0QQOQ0.OCQQOOQOQ0(O0CQOOQOQ0,OOCQOOQOQ0:Word;OQCQOOQOQ0:Pointer;OCCQOOQOQ0:Integer):TBcd;
var
O00COOQOQ0:TDBNumeric;
OO0COOQOQ0:TBcd;
begin
O00COOQOQ0:=OQ0COOQOQ0(O0CQOOQOQ0,OOCQOOQOQ0,OQCQOOQOQ0,OCCQOOQOQ0);
OO0COOQOQ0:=DBNumericToBcd(O00COOQOQ0);
CRFunctions.NormalizeBcd(OO0COOQOQ0,Result,O0CQOOQOQ0,OOCQOOQOQ0);
end;
class function OOQQ0QQOQ0.OQ0COOQOQ0(OC0COOQOQ0,O0OCOOQOQ0:Word;OOOCOOQOQ0:Pointer;OQOCOOQOQ0:Integer):TDBNumeric;
begin
FillChar(Result,SizeOf(Result),0);
Move(OOOCOOQOQ0^,Result.sign,OQOCOOQOQ0);
Result.Precision:=OC0COOQOQ0;
Result.Scale:=O0OCOOQOQ0;
end;
class function OOQQ0QQOQ0.OQCO0QQOQ0(OCCO0QQOQ0:Int64;O00QCQQOQ0:PSQLTimeStamp;OO0QCQQOQ0:Word;OQ0QCQQOQ0:boolean):Integer;
begin
if OO0QCQQOQ0>0 then begin
OCCO0QQOQ0:=OCCO0QQOQ0*O0CQ0QCOQ0[OO0QCQQOQ0];
OCCO0QQOQ0:=(OCCO0QQOQ0+5000)div OCCQ0QCOQ0;
O00QCQQOQ0.Fractions:=OCCO0QQOQ0 mod MSecsPerSec;
OCCO0QQOQ0:=OCCO0QQOQ0 div MSecsPerSec;
end
else
O00QCQQOQ0.Fractions:=0;
O00QCQQOQ0.Second:=OCCO0QQOQ0 mod 60;
OCCO0QQOQ0:=OCCO0QQOQ0 div 60;
O00QCQQOQ0.Minute:=OCCO0QQOQ0 mod 60;
O00QCQQOQ0.Hour:=OCCO0QQOQ0 div 60;
if O00QCQQOQ0.Hour>=24 then
if OQ0QCQQOQ0 then begin
O00QCQQOQ0.Hour:=23;
O00QCQQOQ0.Minute:=59;
O00QCQQOQ0.Second:=59;
O00QCQQOQ0.Fractions:=999;
Result:=0;
end
else begin
O00QCQQOQ0.Hour:=0;
O00QCQQOQ0.Minute:=0;
O00QCQQOQ0.Second:=0;
O00QCQQOQ0.Fractions:=0;
Result:=1;
end
else
Result:=0;
end;
class function OOQQ0QQOQ0.OC0QCQQOQ0(O0OQCQQOQ0:Int64;OOOQCQQOQ0:PSQLTimeStampOffset;OQOQCQQOQ0:Word;OCOQCQQOQ0:boolean):Integer;
begin
O0OQCQQOQ0:=O0OQCQQOQ0*O0CQ0QCOQ0[OQOQCQQOQ0];
O0OQCQQOQ0:=(O0OQCQQOQ0+5000)div OCCQ0QCOQ0;
OOOQCQQOQ0.Fractions:=O0OQCQQOQ0 mod MSecsPerSec;
O0OQCQQOQ0:=O0OQCQQOQ0 div MSecsPerSec;
OOOQCQQOQ0.Second:=O0OQCQQOQ0 mod 60;
O0OQCQQOQ0:=O0OQCQQOQ0 div 60;
OOOQCQQOQ0.Minute:=O0OQCQQOQ0 mod 60;
OOOQCQQOQ0.Hour:=O0OQCQQOQ0 div 60;
if OOOQCQQOQ0.Hour>=24 then
if OCOQCQQOQ0 then begin
OOOQCQQOQ0.Hour:=23;
OOOQCQQOQ0.Minute:=59;
OOOQCQQOQ0.Second:=59;
OOOQCQQOQ0.Fractions:=999;
Result:=0;
end
else begin
OOOQCQQOQ0.Hour:=0;
OOOQCQQOQ0.Minute:=0;
OOOQCQQOQ0.Second:=0;
OOOQCQQOQ0.Fractions:=0;
Result:=1;
end
else
Result:=0;
end;
class procedure OOQQ0QQOQ0.OCOCOOQOQ0(O0QCOOQOQ0:Byte;OOQCOOQOQ0:Word;OQQCOOQOQ0:Integer;OCQCOOQOQ0,O0CCOOQOQ0:Pointer);
var
OOCCOOQOQ0:Int64;
OQCCOOQOQ0:Integer;
begin
case O0QCOOQOQ0 of
OQCOQCCOQ0,OO0QOQCOQ0,O0QQOQCOQ0:begin
case OQQCOOQOQ0 of
4:begin
PSQLTimeStamp(O0CCOOQOQ0).Hour:=OO0QQQCOQ0(OCQCOOQOQ0).O0OQQQCOQ0 div MinsPerHour;
PSQLTimeStamp(O0CCOOQOQ0).Minute:=OO0QQQCOQ0(OCQCOOQOQ0).O0OQQQCOQ0 mod MinsPerHour;
PSQLTimeStamp(O0CCOOQOQ0).Second:=0;
PSQLTimeStamp(O0CCOOQOQ0).Fractions:=0;
OOCCOOQOQ0:=(OO0QQQCOQ0(OCQCOOQOQ0).OC0QQQCOQ0+2);
DecodeDate(OOCCOOQOQ0,Word(PSQLTimeStamp(O0CCOOQOQ0).Year),PSQLTimeStamp(O0CCOOQOQ0).Month,PSQLTimeStamp(O0CCOOQOQ0).Day);
end;
8:begin
OQCCOOQOQ0:=OOQOCQCOQ0(OCQCOOQOQ0).O0COCQCOQ0;
OQCCOOQOQ0:=(OQCCOOQOQ0*20+3)div 6;
PSQLTimeStamp(O0CCOOQOQ0).Hour:=OQCCOOQOQ0 div OC0CCOQOQ0;
OQCCOOQOQ0:=OQCCOOQOQ0 mod OC0CCOQOQ0;
PSQLTimeStamp(O0CCOOQOQ0).Minute:=OQCCOOQOQ0 div O0OCCOQOQ0;
OQCCOOQOQ0:=OQCCOOQOQ0 mod O0OCCOQOQ0;
PSQLTimeStamp(O0CCOOQOQ0).Second:=OQCCOOQOQ0 div MSecsPerSec;
PSQLTimeStamp(O0CCOOQOQ0).Fractions:=OQCCOOQOQ0 mod MSecsPerSec;
OOCCOOQOQ0:=OOQOCQCOQ0(OCQCOOQOQ0).OCQOCQCOQ0+2;
DecodeDate(OOCCOOQOQ0,Word(PSQLTimeStamp(O0CCOOQOQ0).Year),PSQLTimeStamp(O0CCOOQOQ0).Month,PSQLTimeStamp(O0CCOOQOQ0).Day);
end;
else
raise Exception.CreateFmt('Packet reading error: Wrong TDS_DATETIMNTYPE size %d',[OQQCOOQOQ0]);
end;
end;
else
raise Exception.CreateFmt('Packet reading error: DateTime type %d',[O0QCOOQOQ0]);
end;
end;
class procedure OOQQ0QQOQ0.OCCCOOQOQ0(O000OOQOQ0:Word;OO00OOQOQ0:Integer;OQ00OOQOQ0,OC00OOQOQ0:Pointer);
var
O0O0OOQOQ0,OOO0OOQOQ0:Int64;
OQO0OOQOQ0:SmallInt;
begin
Assert((OO00OOQOQ0>=8)and(OO00OOQOQ0<=10));
Assert(O000OOQOQ0<=7);
O0O0OOQOQ0:=0;
Move(PtrOffset(OQ00OOQOQ0,OO00OOQOQ0-5)^,O0O0OOQOQ0,3);
Dec(O0O0OOQOQ0,DateDelta-1);
OOO0OOQOQ0:=0;
Move(OQ00OOQOQ0^,OOO0OOQOQ0,OO00OOQOQ0-5);
O0O0OOQOQ0:=O0O0OOQOQ0+OC0QCQQOQ0(OOO0OOQOQ0,OC00OOQOQ0,O000OOQOQ0,O0O0OOQOQ0=2958465);
DecodeDate(O0O0OOQOQ0,PSQLTimeStampOffset(OC00OOQOQ0).Year,PSQLTimeStampOffset(OC00OOQOQ0).Month,PSQLTimeStampOffset(OC00OOQOQ0).Day);
Move(PtrOffset(OQ00OOQOQ0,OO00OOQOQ0-2)^,OQO0OOQOQ0,2);
if(OQO0OOQOQ0>840)or(OQO0OOQOQ0<-840)then
raise Exception.CreateFmt('Wrong TDS_DATETIMEOFFSETNTYPE offset value %d',[OQO0OOQOQ0]);
PSQLTimeStampOffset(OC00OOQOQ0).TimeZoneHour:=OQO0OOQOQ0 div 60;
PSQLTimeStampOffset(OC00OOQOQ0).TimeZoneMinute:=OQO0OOQOQ0 mod 60;
end;
function OOQQ0QQOQ0.O0QQCQQOQ0(const OOQQCQQOQ0:O0Q0QQCOQ0;OQQQCQQOQ0:Pointer;OCQQCQQOQ0:Integer):Variant;
begin
Assert(False);
{$IFDEF FPC}
Result:=Unassigned;
{$ENDIF}
end;
function OOQQ0QQOQ0.O0CQCQQOQ0():Boolean;
begin
Result:=False;
end;
function OOQQ0QQOQ0.OOCQCQQOQ0(var OQCQCQQOQ0:Integer;OCCQCQQOQ0:Integer;O00CCQQOQ0,OO0CCQQOQ0:Boolean):Integer;
begin
if OQCQCQQOQ0>OCCQCQQOQ0 then
OQCQCQQOQ0:=OCCQCQQOQ0;
Result:=OQCQCQQOQ0;
if O0CQCQQOQ0 and not O00CCQQOQ0 and OO0CCQQOQ0 then
OQCQCQQOQ0:=OCCQCQQOQ0;
end;
function OOQQ0QQOQ0.OCO0OOQOQ0(var O0Q0OOQOQ0:OQ00QQCOQ0):Variant;
begin
Result:=Unassigned;
end;
procedure OOQQ0QQOQ0.OOQ0OOQOQ0(const OQQ0OOQOQ0:OQ00QQCOQ0;OCQ0OOQOQ0:TBlob;
const O0C0OOQOQ0:O00CQQCOQ0;OOC0OOQOQ0:OOCCCCQOQ0);
var
OQC0OOQOQ0:integer;
OCC0OOQOQ0:Pointer;
O00OOOQOQ0:TBytes;
OO0OOOQOQ0:Encoding;
OQ0OOOQOQ0:Encoding;
begin
{$IFNDEF VER9P}
O00OOOQOQ0:=nil;
{$ENDIF}
OQC0OOQOQ0:=Length(OQQ0OOQOQ0.OOO0QQCOQ0);
if OQC0OOQOQ0>0 then
OCC0OOQOQ0:=@OQQ0OOQOQ0.OOO0QQCOQ0[0]
else
OCC0OOQOQ0:=nil;
if not OC0C0QQOQ0 then begin
OCQ0OOQOQ0.Write(0,OQC0OOQOQ0,OCC0OOQOQ0);
Exit;
end;
if OCQ0OOQOQ0.IsUnicode then
OQ0OOOQOQ0:=Encoding.Unicode
else
OQ0OOOQOQ0:=Encoding.Default;
if OOC0OOQOQ0=OCQCCCQOQ0 then
OO0OOOQOQ0:=Encoding.Unicode
else if OOC0OOQOQ0=OQQCCCQOQ0 then
OO0OOOQOQ0:=OQOO0QQOQ0(O0C0OOQOQ0)
else
OO0OOOQOQ0:=OQ0OOOQOQ0;
if OO0OOOQOQ0<>OQ0OOOQOQ0 then begin
O00OOOQOQ0:=Encoding.Convert(OO0OOOQOQ0,OQ0OOOQOQ0,OCQO0QQOQ0(OCC0OOQOQ0,OQC0OOQOQ0),0,OQC0OOQOQ0);
if Length(O00OOOQOQ0)>0 then
OCQ0OOQOQ0.Write(0,Length(O00OOOQOQ0),@O00OOOQOQ0[0])
else
OCQ0OOQOQ0.Write(0,0,nil);
end
else
OCQ0OOQOQ0.Write(0,OQC0OOQOQ0,OCC0OOQOQ0);
end;
function OOQQ0QQOQ0.OC0OOOQOQ0(const O0OOOOQOQ0:O0Q0QQCOQ0;OOOOOOQOQ0:Pointer;
var OQOOOOQOQ0:Integer;OCOOOOQOQ0:Integer;O0QOOOQOQ0,OOQOOOQOQ0:boolean;OQQOOOQOQ0:TStringHeap):Pointer;
var
OCQOOOQOQ0:WideString;
O0COOOQOQ0,OOCOOOQOQ0:TBytes;
OQCOOOQOQ0,OCCOOOQOQ0:Encoding;
O00Q0OQOQ0:Integer;
OO0Q0OQOQ0:Integer;
begin
{$IFNDEF VER9P}
OOCOOOQOQ0:=nil;
{$ENDIF}
if(OOOOOOQOQ0=nil)or(OQOOOOQOQ0<=0)then begin
OQOOOOQOQ0:=0;
O00Q0OQOQ0:=OOCQCQQOQ0(OQOOOOQOQ0,OCOOOOQOQ0,O0QOOOQOQ0,OOQOOOQOQ0);
Result:=OQQOOOQOQ0.NewBuf(OQOOOOQOQ0+1);
Marshal.WriteInt16(Result,OQOOOOQOQ0,0);
end
else
begin
if O0OOOOQOQ0.OOOOQQCOQ0.OQQCCQCOQ0 then begin
if OC0C0QQOQ0 then begin
OQCOOOQOQ0:=O0OO0QQOQ0(O0OOOOQOQ0.OQCOQQCOQ0);
OCCOOOQOQ0:=O0QO0QQOQ0;
end
else begin
OQCOOOQOQ0:=nil;
OCCOOOQOQ0:=nil;
end;
if OQCOOOQOQ0<>OCCOOOQOQ0 then begin
SetLength(O0COOOQOQ0,OQOOOOQOQ0);
Move(OOOOOOQOQ0^,O0COOOQOQ0[0],OQOOOOQOQ0);
OOCOOOQOQ0:=Encoding.Convert(OQCOOOQOQ0,OCCOOOQOQ0,O0COOOQOQ0);
OQOOOOQOQ0:=Length(OOCOOOQOQ0);
OOOOOOQOQ0:=@OOCOOOQOQ0[0];
end;
end
else begin
SetLength(OCQOOOQOQ0,OQOOOOQOQ0 shr 1);
if OQOOOOQOQ0>0 then
Move(OOOOOOQOQ0^,PWideChar(OCQOOOQOQ0)^,OQOOOOQOQ0);
OCCOOOQOQ0:=O0QO0QQOQ0;
O0COOOQOQ0:=OCCOOOQOQ0.GetBytes(OCQOOOQOQ0);
OQOOOOQOQ0:=Length(O0COOOQOQ0);
OOOOOOQOQ0:=@O0COOOQOQ0[0];
end;
O00Q0OQOQ0:=OOCQCQQOQ0(OQOOOOQOQ0,OCOOOOQOQ0,O0QOOOQOQ0,OOQOOOQOQ0);
if O0QOOOQOQ0 then
Result:=OQQOOOQOQ0.AllocTrimmedStr(OOOOOOQOQ0,OQOOOOQOQ0)
else
Result:=OQQOOOQOQ0.AllocStr(OOOOOOQOQ0,OQOOOOQOQ0);
end;
if O0CQCQQOQ0 and not O0QOOOQOQ0 and OOQOOOQOQ0 then begin
OO0Q0OQOQ0:=OQOOOOQOQ0-O00Q0OQOQ0;
if OO0Q0OQOQ0>0 then begin
FillChar(PtrOffset(Result,O00Q0OQOQ0)^,OO0Q0OQOQ0,$20);
Marshal.WriteByte(Result,OQOOOOQOQ0,0);
end;
end;
end;
function OOQQ0QQOQ0.OQ0Q0OQOQ0(const OC0Q0OQOQ0:O0Q0QQCOQ0;O0OQ0OQOQ0:Pointer;
var OOOQ0OQOQ0:Integer;OQOQ0OQOQ0:Integer;OCOQ0OQOQ0,O0QQ0OQOQ0:boolean;OOQQ0OQOQ0:TStringHeap):Pointer;
function OQQQ0OQOQ0(var OCQQ0OQOQ0;O0CQ0OQOQ0:Integer;const OOCQ0OQOQ0:WideChar):Cardinal;
var
OQCQ0OQOQ0:PWideChar;
begin
Result:=O0CQ0OQOQ0;
OQCQ0OQOQ0:=@OCQQ0OQOQ0;
for O0CQ0OQOQ0:=O0CQ0OQOQ0 downto 1 do begin
OQCQ0OQOQ0^:=OOCQ0OQOQ0;
Inc(OQCQ0OQOQ0);
end;
end;
var
OCCQ0OQOQ0:AnsiString;
O00C0OQOQ0:WideString;
OO0C0OQOQ0:TBytes;
OQ0C0OQOQ0,OC0C0OQOQ0:Encoding;
O0OC0OQOQ0:Integer;
OOOC0OQOQ0:Integer;
begin
if(O0OQ0OQOQ0=nil)or(OOOQ0OQOQ0<=0)then begin
OOOQ0OQOQ0:=0;
O0OC0OQOQ0:=OOCQCQQOQ0(OOOQ0OQOQ0,OQOQ0OQOQ0,OCOQ0OQOQ0,O0QQ0OQOQ0);
Result:=OOQQ0OQOQ0.NewBuf((OOOQ0OQOQ0+1)*SizeOf(WideChar));
Marshal.WriteInt16(Result,OOOQ0OQOQ0,0);
end
else
if OC0Q0OQOQ0.OOOOQQCOQ0.OQQCCQCOQ0 then begin
if OC0C0QQOQ0 then begin
OQ0C0OQOQ0:=O0OO0QQOQ0(OC0Q0OQOQ0.OQCOQQCOQ0);
OC0C0OQOQ0:=O0QO0QQOQ0;
end
else begin
OQ0C0OQOQ0:=nil;
OC0C0OQOQ0:=nil;
end;
if OQ0C0OQOQ0<>OC0C0OQOQ0 then begin
SetLength(OO0C0OQOQ0,OOOQ0OQOQ0);
Move(O0OQ0OQOQ0^,OO0C0OQOQ0[0],OOOQ0OQOQ0);
O00C0OQOQ0:={$IFNDEF NEXTGEN}OQ0C0OQOQ0.GetWideString(OO0C0OQOQ0){$ELSE}WideString(OQ0C0OQOQ0.GetString(OO0C0OQOQ0)){$ENDIF};
end
else begin
SetLengthA(OCCQ0OQOQ0,OOOQ0OQOQ0);
if OOOQ0OQOQ0>0 then
Move(O0OQ0OQOQ0^,PAnsiChar(OCCQ0OQOQ0)^,OOOQ0OQOQ0);
O00C0OQOQ0:=WideString(OCCQ0OQOQ0);
end;
OOOQ0OQOQ0:=Length(O00C0OQOQ0)*2;
O0OC0OQOQ0:=OOCQCQQOQ0(OOOQ0OQOQ0,OQOQ0OQOQ0,OCOQ0OQOQ0,O0QQ0OQOQ0);
OOOQ0OQOQ0:=OOOQ0OQOQ0 shr 1;
if OCOQ0OQOQ0 then
Result:=OOQQ0OQOQ0.AllocTrimmedWideStr(PWideChar(O00C0OQOQ0),OOOQ0OQOQ0)
else
Result:=OOQQ0OQOQ0.AllocWideStr(PWideChar(O00C0OQOQ0),OOOQ0OQOQ0);
end
else begin
O0OC0OQOQ0:=OOCQCQQOQ0(OOOQ0OQOQ0,OQOQ0OQOQ0,OCOQ0OQOQ0,O0QQ0OQOQ0);
if O0OQ0OQOQ0=nil then
O0OQ0OQOQ0:=PWideChar(EmptyWString);
OOOQ0OQOQ0:=OOOQ0OQOQ0 shr 1;
if OCOQ0OQOQ0 then
Result:=OOQQ0OQOQ0.AllocTrimmedWideStr(O0OQ0OQOQ0,OOOQ0OQOQ0)
else
Result:=OOQQ0OQOQ0.AllocWideStr(O0OQ0OQOQ0,OOOQ0OQOQ0);
end;
if O0CQCQQOQ0 and not OCOQ0OQOQ0 and O0QQ0OQOQ0 then begin
OOOC0OQOQ0:=(OOOQ0OQOQ0*2)-O0OC0OQOQ0;
if OOOC0OQOQ0>0 then begin
OQQQ0OQOQ0(PtrOffset(Result,O0OC0OQOQ0)^,OOOC0OQOQ0,' ');
Marshal.WriteInt16(Result,OOOQ0OQOQ0*2,0);
end;
end;
end;
procedure OOQQ0QQOQ0.OQ0CCQQOQ0(OC0CCQQOQ0:OCO0QQCOQ0);
begin
end;
procedure OOQQ0QQOQ0.O0OCCQQOQ0(OOOCCQQOQ0:OCO0QQCOQ0);
begin
end;
procedure OOQQ0QQOQ0.OQOCCQQOQ0(OCOCCQQOQ0:OCO0QQCOQ0);
begin
case OCOCCQQOQ0.OOOOQQCOQ0.OOOCCQCOQ0 of
O0OQ0QCOQ0:begin
if OCOCCQQOQ0.OC0OQQCOQ0<>OQ0OQCCOQ0 then
OCOCCQQOQ0.OCQ0QQCOQ0:=OQQQ0QQOQ0.O0OO00COQ0
else
OCOCCQQOQ0.OCQ0QQCOQ0:=OCOCCQQOQ0.OOOOQQCOQ0.OQOCCQCOQ0;
if OCOCCQQOQ0.OOOOQQCOQ0.O0O0CQCOQ0 then begin
case OCOCCQQOQ0.OC0OQQCOQ0 of
O00OQCCOQ0:
case OCOCCQQOQ0.OCQ0QQCOQ0 of
1:
OCOCCQQOQ0.OC0OQQCOQ0:=O0QOQCCOQ0;
2:
OCOCCQQOQ0.OC0OQQCOQ0:=O0COQCCOQ0;
4:
OCOCCQQOQ0.OC0OQQCOQ0:=OOCOQCCOQ0;
8:
OCOCCQQOQ0.OC0OQQCOQ0:=OCQQOQCOQ0;
else
raise Exception.CreateFmt('Unacceptable length %d',[OCOCCQQOQ0.OCQ0QQCOQ0]);
end;
OC0QOQCOQ0:
case OCOCCQQOQ0.OCQ0QQCOQ0 of
0:
OCOCCQQOQ0.OC0OQQCOQ0:=OCQ0QCCOQ0;
1:
OCOCCQQOQ0.OC0OQQCOQ0:=OCQOQCCOQ0;
else
raise Exception.CreateFmt('Unacceptable length %d',[OCOCCQQOQ0.OCQ0QQCOQ0]);
end;
OQOQOQCOQ0:
case OCOCCQQOQ0.OCQ0QQCOQ0 of
4:begin
OCOCCQQOQ0.OC0OQQCOQ0:=OCCOQCCOQ0;
OCOCCQQOQ0.O0C0QQCOQ0:=OO0C0QCOQ0[OQ0C0QQOQ0[OCCOQCCOQ0].OCOCCQCOQ0];
OCOCCQQOQ0.OOC0QQCOQ0:=OQ0C0QQOQ0[OCCOQCCOQ0].O0QCCQCOQ0;
end;
8:begin
OCOCCQQOQ0.OC0OQQCOQ0:=OQ0QOQCOQ0;
OCOCCQQOQ0.O0C0QQCOQ0:=OO0C0QCOQ0[OQ0C0QQOQ0[OQ0QOQCOQ0].OCOCCQCOQ0];
OCOCCQQOQ0.OOC0QQCOQ0:=OQ0C0QQOQ0[OQ0QOQCOQ0].O0QCCQCOQ0;
end;
else
raise Exception.CreateFmt('Unacceptable length %d',[OCOCCQQOQ0.OCQ0QQCOQ0]);
end;
OCOQOQCOQ0:
case OCOCCQQOQ0.OCQ0QQCOQ0 of
4:begin
OCOCCQQOQ0.OC0OQQCOQ0:=OOQQOQCOQ0;
OCOCCQQOQ0.O0C0QQCOQ0:=10;
OCOCCQQOQ0.OOC0QQCOQ0:=OQ0C0QQOQ0[OOQQOQCOQ0].O0QCCQCOQ0;
end;
8:begin
OCOCCQQOQ0.OC0OQQCOQ0:=O00QOQCOQ0;
OCOCCQQOQ0.O0C0QQCOQ0:=19;
OCOCCQQOQ0.OOC0QQCOQ0:=OQ0C0QQOQ0[O00QOQCOQ0].O0QCCQCOQ0;
end;
else
raise Exception.CreateFmt('Unacceptable length %d',[OCOCCQQOQ0.OCQ0QQCOQ0]);
end;
O0QQOQCOQ0:begin
case OCOCCQQOQ0.OCQ0QQCOQ0 of
4:
OCOCCQQOQ0.OC0OQQCOQ0:=OQCOQCCOQ0;
8:
OCOCCQQOQ0.OC0OQQCOQ0:=OO0QOQCOQ0;
else
raise Exception.CreateFmt('Unacceptable length %d',[OCOCCQQOQ0.OCQ0QQCOQ0]);
end;
end;
end;
end
else begin
case OCOCCQQOQ0.OC0OQQCOQ0 of
OCC0QCCOQ0,
OO0OQCCOQ0,
OQOOQCCOQ0,
OCOOQCCOQ0:;
O0OQOQCOQ0,
OOOQOQCOQ0:;
OOQOQCCOQ0,
OQQOQCCOQ0:;
OQCOQCCOQ0:
OCOCCQQOQ0.OOC0QQCOQ0:=0;
OO0QOQCOQ0:
OCOCCQQOQ0.OOC0QQCOQ0:=3;
O0CQOQCOQ0:begin
OCOCCQQOQ0.OOC0QQCOQ0:=3;
OCOCCQQOQ0.OCQ0QQCOQ0:=OCOCCQQOQ0.OOOOQQCOQ0.OCOCCQCOQ0;
end;
OQ0OQCCOQ0,OQQQOQCOQ0:
OCOCCQQOQ0.OCQ0QQCOQ0:=OCOCCQQOQ0.OOOOQQCOQ0.OCOCCQCOQ0;
OOCQOQCOQ0,OQCQOQCOQ0:begin
OCOCCQQOQ0.OOC0QQCOQ0:=OQQQ0QQOQ0.O0OO00COQ0;
OCOCCQQOQ0.OCQ0QQCOQ0:=OCOCCQQOQ0.OOOOQQCOQ0.OCOCCQCOQ0;
end;
OQC0QCCOQ0:
OCOCCQQOQ0.OCQ0QQCOQ0:=SizeOf(TGuid);
OC0OQCCOQ0,
O0OOQCCOQ0,
OOOOQCCOQ0:begin
OCOCCQQOQ0.OOC0QQCOQ0:=OCOCCQQOQ0.OCQ0QQCOQ0;
OCOCCQQOQ0.OCQ0QQCOQ0:=OCOCCQQOQ0.OOOOQQCOQ0.OCOCCQCOQ0;
end;
else
raise Exception.CreateFmt('Type %d not defined yet',[OCOCCQQOQ0.OC0OQQCOQ0]);
end;
end;
end;
OOOQ0QCOQ0:
OCOCCQQOQ0.OCQ0QQCOQ0:=OQQQ0QQOQ0.OQOO00COQ0;
OQOQ0QCOQ0:
OCOCCQQOQ0.OCQ0QQCOQ0:=OQQQ0QQOQ0.O0QO00COQ0;
else
OCOCCQQOQ0.OCQ0QQCOQ0:=Cardinal(OCOCCQQOQ0.OOOOQQCOQ0.OQOCCQCOQ0);
OQ0CCQQOQ0(OCOCCQQOQ0);
end;
if OCOCCQQOQ0.OOOOQQCOQ0.OOQCCQCOQ0 then
O0OCCQQOQ0(OCOCCQQOQ0)
else
if OCOCCQQOQ0.OOOOQQCOQ0.OC00CQCOQ0 then begin
OCOCCQQOQ0.O0C0QQCOQ0:=OQQQ0QQOQ0.O0OO00COQ0;
OCOCCQQOQ0.OOC0QQCOQ0:=OQQQ0QQOQ0.O0OO00COQ0;
end;
end;
function OOQQ0QQOQ0.OQOC0OQOQ0(const OCOC0OQOQ0:OQO0QQCOQ0;O0QC0OQOQ0:boolean=False):boolean;
begin
OCCQ0QQOQ0.Enter;
try
Result:=O0CC0QQOQ0 and not O0000QQOQ0;
if not Result then
Exit;
O00OCQQOQ0(OCOC0OQOQ0,O0QC0OQOQ0);
O0C0CQQOQ0;
finally
OCCQ0QQOQ0.Leave;
end;
end;
procedure OOQQ0QQOQ0.O00OCQQOQ0(const OO0OCQQOQ0:OQO0QQCOQ0;OQ0OCQQOQ0:boolean);
var
OC0OCQQOQ0:TBytes;
O0OOCQQOQ0,OOOOCQQOQ0:integer;
OQOOCQQOQ0:boolean;
begin
Assert(Length(OO00QQQOQ0)=Length(OO0OCQQOQ0));
OQOOCQQOQ0:=OOQC0QQOQ0=OOOQQCCOQ0;
if OQOOCQQOQ0 then begin
OOOOCQQOQ0:=Length(OO00QQQOQ0)shr 3;
if(Length(OO00QQQOQ0)and 7)<>0 then
Inc(OOOOCQQOQ0);
SetLength(OC0OCQQOQ0,OOOOCQQOQ0);
OQQQ0QQOQ0.OCC000COQ0(@OC0OCQQOQ0[0],OOOOCQQOQ0);
end;
for O0OOCQQOQ0:=0 to Length(OO00QQQOQ0)-1 do begin
if OQOOCQQOQ0 and((OC0OCQQOQ0[O0OOCQQOQ0 shr 3]and(1 shl(O0OOCQQOQ0 and 7)))<>0)then
OO0OCQQOQ0[O0OOCQQOQ0].OC00QQCOQ0:=True
else begin
OO0OCQQOQ0[O0OOCQQOQ0].OC00QQCOQ0:=False;
O0QCCQQOQ0(OO00QQQOQ0[O0OOCQQOQ0],OO0OCQQOQ0[O0OOCQQOQ0],OQ0OCQQOQ0);
end;
end;
end;
procedure OOQQ0QQOQ0.OCOOCQQOQ0;
var
O0QOCQQOQ0:OQCCCCQOQ0;
OOQOCQQOQ0:integer;
begin
O0QOCQQOQ0.OCCCCCQOQ0:=OQQQ0QQOQ0.O0QO00COQ0;
O0QOCQQOQ0.OO00CCQOQ0:=OQQQ0QQOQ0.O0OO00COQ0;
O0QOCQQOQ0.OQ00CCQOQ0:=OQQQ0QQOQ0.O0OO00COQ0;
O0QOCQQOQ0.OC00CCQOQ0:=OQQQ0QQOQ0.O0OQC0COQ0;
O0QOCQQOQ0.O0O0CCQOQ0:=OQQQ0QQOQ0.OO0QC0COQ0;
O0QOCQQOQ0.OOO0CCQOQ0:=OQQQ0QQOQ0.OO0QC0COQ0;
if(O0CQ0QQOQ0.O0QQ0QQOQ0>=O0Q0CCCOQ0)and not(OOOC0QQOQ0 in[OCCCCCCOQ0,OQCCCCCOQ0])then
O0QOCQQOQ0.O000CCQOQ0:=OQQQ0QQOQ0.O0QO00COQ0
else
O0QOCQQOQ0.O000CCQOQ0:=OQQQ0QQOQ0.OQOO00COQ0;
{$IFDEF LOG_PACKETS}
AddToLog(Format('Number %d, State %X, Class %X, MsgText "%s", ServerName "%s", ProcName "%s", LineNumber %d',
[O0QOCQQOQ0.OCCCCCQOQ0,O0QOCQQOQ0.OO00CCQOQ0,O0QOCQQOQ0.OQ00CCQOQ0,O0QOCQQOQ0.OC00CCQOQ0,
O0QOCQQOQ0.O0O0CCQOQ0,O0QOCQQOQ0.OOO0CCQOQ0,O0QOCQQOQ0.O000CCQOQ0]));
{$ENDIF}
if O0QOCQQOQ0.OQ00CCQOQ0<=10 then
O0CQ0QQOQ0.OCCOOQQOQ0(O0QOCQQOQ0,OOCQ0QQOQ0)
else begin
OOQOCQQOQ0:=Length(OQCQ0QQOQ0);
SetLength(OQCQ0QQOQ0,OOQOCQQOQ0+1);
OQCQ0QQOQ0[OOQOCQQOQ0]:=O0QOCQQOQ0;
end;
end;
procedure OOQQ0QQOQ0.OQQOCQQOQ0(OCQOCQQOQ0,O0COCQQOQ0:Word;OOCOCQQOQ0:Int64);
begin
OCOC0QQOQ0:=OCQOCQQOQ0;
if(OCQOCQQOQ0 and OO00OOCOQ0)<>0 then begin
if not OQCOCQQOQ0(OCQOCQQOQ0,O0COCQQOQ0)or(OOCC0QQOQ0 and OQCC0QQOQ0)then
OQQC0QQOQ0:=OOCOCQQOQ0;
{$IFDEF LOG_PACKETS}
AddToLog(Format('RowsAffected: %d',[OOCOCQQOQ0]));
{$ENDIF}
end;
OQCC0QQOQ0:=False;
OO000QQOQ0:=(OCQOCQQOQ0 and OOCCOOCOQ0)<>0;
if((OOQC0QQOQ0=O00CQCCOQ0)or(OOQC0QQOQ0=OO0CQCCOQ0))and OO000QQOQ0 then
O0000QQOQ0:=OOCC0QQOQ0;
if(OCQOCQQOQ0 and OQ00OOCOQ0)<>0 then
OCCC0QQOQ0:=False;
end;
function OOQQ0QQOQ0.OQCOCQQOQ0(OCCOCQQOQ0,O00QQQQOQ0:Word):Boolean;
begin
Result:=OCQC0QQOQ0;
end;
procedure OOQQ0QQOQ0.O0C0CQQOQ0;
var
OOC0CQQOQ0:boolean;
begin
OOC00QQOQ0;
OOC0CQQOQ0:=False;
while not OOC0CQQOQ0 and(not O0QC0QQOQ0 or OQQQ0QQOQ0.OQCC00COQ0)do begin
OOQC0QQOQ0:=OQQQ0QQOQ0.O0OO00COQ0;
OQC0CQQOQ0(OOC0CQQOQ0);
end;
if OCCC0QQOQ0 then begin
O0QC0QQOQ0:=False;
OOQC0QQOQ0:=OQQQ0QQOQ0.O0OO00COQ0;
OQC0CQQOQ0(OOC0CQQOQ0);
end;
if Length(OQCQ0QQOQ0)>0 then
O0CQ0QQOQ0.OQCOOQQOQ0(OQCQ0QQOQ0,OOCQ0QQOQ0);
end;
function OOQQ0QQOQ0.O0CCCQQOQ0(const OOCCCQQOQ0:Variant;OQCCCQQOQ0:Boolean):Cardinal;
var
OCCCCQQOQ0:Word;
begin
Result:=0;
OCCCCQQOQ0:=TVarData(OOCCCQQOQ0).VType;
if(OCCCCQQOQ0 and varByRef)<>0 then begin
Result:=TBlob(TVarData(OOCCCQQOQ0).VPointer).Size;
end
else if((OCCCCQQOQ0 and varArray)<>0)and(VarArrayDimCount(OOCCCQQOQ0)>0)then
Result:=VarArrayHighBound(OOCCCQQOQ0,1)+1
else
case OCCCCQQOQ0 of
varOleStr,varString{$IFDEF VER12P},varUString{$ENDIF}:begin
Result:=Length(string(OOCCCQQOQ0));
if not OQCCCQQOQ0 and((OCCCCQQOQ0=varOleStr){$IFDEF VER12P}or(OCCCCQQOQ0=varUString){$ENDIF})then
Result:=Result shl 1;
end;
end;
end;
procedure OOQQ0QQOQ0.O000CQQOQ0(OO00CQQOQ0:OC0OCCQOQ0;OQ00CQQOQ0:OCOOCCQOQ0;OC00CQQOQ0:O00QQCQOQ0;
const O0O0CQQOQ0:OCOQQCQOQ0;const OOO0CQQOQ0:O0Q0QQCOQ0;const OQO0CQQOQ0:OQ00QQCOQ0);
var
OCO0CQQOQ0:integer;
O0Q0CQQOQ0:Pointer;
OOQ0CQQOQ0:TBlob;
OQQ0CQQOQ0:Variant;
OCQ0CQQOQ0:OOCCCCQOQ0;
begin
if Assigned(OO00CQQOQ0)then
OO00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,OQO0CQQOQ0.OC00QQCOQ0);
if OQO0CQQOQ0.OC00QQCOQ0 or not Assigned(OQ00CQQOQ0)then
Exit;
OCO0CQQOQ0:=Length(OQO0CQQOQ0.OOO0QQCOQ0);
if OCO0CQQOQ0>0 then
O0Q0CQQOQ0:=@OQO0CQQOQ0.OOO0QQCOQ0[0]
else
O0Q0CQQOQ0:=nil;
case OOO0CQQOQ0.OC0OQQCOQ0 of
O0QOQCCOQ0:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PShortInt(O0Q0CQQOQ0)^);
O0COQCCOQ0:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PSmallInt(O0Q0CQQOQ0)^);
OOCOQCCOQ0:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PInteger(O0Q0CQQOQ0)^);
O00OQCCOQ0:
case OCO0CQQOQ0 of
1:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PShortInt(O0Q0CQQOQ0)^);
2:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PSmallInt(O0Q0CQQOQ0)^);
4:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PInteger(O0Q0CQQOQ0)^);
8:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PInt64(O0Q0CQQOQ0)^);
else
raise Exception.CreateFmt('Unknown TDS_INTNTYPE Data.Size %d',[OCO0CQQOQ0]);
end;
OCQOQCCOQ0:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PShortInt(O0Q0CQQOQ0)^<>0);
OCCOQCCOQ0:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PSingle(O0Q0CQQOQ0)^);
OQ0QOQCOQ0:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PDouble(O0Q0CQQOQ0)^);
OQOQOQCOQ0:
case OCO0CQQOQ0 of
4:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PSingle(O0Q0CQQOQ0)^);
8:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,PDouble(O0Q0CQQOQ0)^);
else
raise Exception.CreateFmt('Unknown TDS_FLTNTYPE Data.Size %d',[OCO0CQQOQ0]);
end;
O00QOQCOQ0,OCOQOQCOQ0,OOQQOQCOQ0:
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,OO0OQQQOQ0(O0Q0CQQOQ0,OCO0CQQOQ0));
OQCOQCCOQ0,OO0QOQCOQ0,O0QQOQCOQ0:begin
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,O0QOQQQOQ0(OOO0CQQOQ0.OC0OQQCOQ0,OOO0CQQOQ0.OOC0QQCOQ0,O0Q0CQQOQ0,OCO0CQQOQ0));
end;
OO0OQCCOQ0,OCOOQCCOQ0:begin
OQQ0CQQOQ0:=O0QQCQQOQ0(OOO0CQQOQ0,O0Q0CQQOQ0,OCO0CQQOQ0);
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,OQQ0CQQOQ0);
end;
OQOOQCCOQ0,OCC0QCCOQ0:
if OCO0CQQOQ0>0 then begin
OQQ0CQQOQ0:=VarArrayCreate([0,OCO0CQQOQ0-1],varByte);
Move(O0Q0CQQOQ0^,TVarData(OQQ0CQQOQ0).VArray.Data^,OCO0CQQOQ0);
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,OQQ0CQQOQ0);
end;
OOC0QCCOQ0:
if Assigned(OC00CQQOQ0)then begin
OOQ0CQQOQ0:=TBlob(OC00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0));
if OOQ0CQQOQ0=nil then begin
OOQ0CQQOQ0:=TBlob.Create;
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,OOQ0CQQOQ0.ToVariant);
end;
if OOO0CQQOQ0.OOOOQQCOQ0.OCQCCQCOQ0 then
OCQ0CQQOQ0:=OCQCCCQOQ0
else if OOO0CQQOQ0.OOOOQQCOQ0.OQQCCQCOQ0 then
OCQ0CQQOQ0:=OQQCCCQOQ0
else
OCQ0CQQOQ0:=O0CCCCQOQ0;
OOQ0CQQOQ0.RollbackEnabled:=False;
OOQ0OOQOQ0(OQO0CQQOQ0,OOQ0CQQOQ0,OOO0CQQOQ0.OQCOQQCOQ0,OCQ0CQQOQ0);
OOQ0CQQOQ0.RollbackEnabled:=True;
end;
O0OQOQCOQ0,OOOQOQCOQ0:
if O0O0CQQOQ0.OO0CQCQOQ0=OQOCOQCOQ0 then
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,OOOQOOQOQ0(OOO0CQQOQ0.O0C0QQCOQ0,OOO0CQQOQ0.OOC0QQCOQ0,O0Q0CQQOQ0,OCO0CQQOQ0))
else
OQ00CQQOQ0(O0O0CQQOQ0.OOQQQCQOQ0,O0O0CQQOQ0.OQQQQCQOQ0,VarFMTBcdCreate(OCQQOOQOQ0(OOO0CQQOQ0.O0C0QQCOQ0,OOO0CQQOQ0.OOC0QQCOQ0,O0Q0CQQOQ0,OCO0CQQOQ0)));
else
raise Exception.CreateFmt('Unknown FieldInfo.TdsFieldType %d',[OOO0CQQOQ0.OC0OQQCOQ0]);
end;
end;
function OOQQ0QQOQ0.OO0QQQQOQ0(const OQ0QQQQOQ0:string):string;
var
OC0QQQQOQ0:StringBuilder;
O0OQQQQOQ0:TSQLParser;
OOOQQQQOQ0:Integer;
OQOQQQQOQ0:string;
begin
Assert(OQ0QQQQOQ0<>'');
OC0QQQQOQ0:=StringBuilder.Create(Length(OQ0QQQQOQ0)+Length(OQ0QQQQOQ0)div 2);
try
O0OQQQQOQ0:=O0OC0QQOQ0.Create(OQ0QQQQOQ0);
try
O0OQQQQOQ0.OmitBlank:=False;
O0OQQQQOQ0.OmitComment:=True;
O0OQQQQOQ0.QuotedString:=True;
O0OQQQQOQ0.DecSeparator:='.';
O0OQQQQOQ0.ToBegin;
repeat
OOOQQQQOQ0:=O0OQQQQOQ0.GetNext(OQOQQQQOQ0);
if OOOQQQQOQ0=lxSelect then
OC0QQQQOQ0.Append(OQOQQQQOQ0+' TOP 0 ')
else
OC0QQQQOQ0.Append(OQOQQQQOQ0);
until(OOOQQQQOQ0=lcEnd);
finally
O0OQQQQOQ0.Free;
end;
Result:=OC0QQQQOQ0.ToString;
finally
OC0QQQQOQ0.Free;
end;
end;
function OOQQ0QQOQ0.OCOQQQQOQ0(const O0QQQQQOQ0:string;const OOQQQQQOQ0:array of integer):Boolean;
var
OQQQQQQOQ0:TSQLParser;
OCQQQQQOQ0,O0CQQQQOQ0:Integer;
OOCQQQQOQ0:string;
begin
Assert(O0QQQQQOQ0<>'');
Result:=False;
OQQQQQQOQ0:=O0OC0QQOQ0.Create(O0QQQQQOQ0);
try
OQQQQQQOQ0.OmitBlank:=True;
OQQQQQQOQ0.OmitComment:=True;
OQQQQQQOQ0.QuotedString:=True;
OQQQQQQOQ0.DecSeparator:='.';
OQQQQQQOQ0.ToBegin;
repeat
O0CQQQQOQ0:=OQQQQQQOQ0.GetNext(OOCQQQQOQ0);
for OCQQQQQOQ0:=Low(OOQQQQQOQ0)to High(OOQQQQQOQ0)do
if O0CQQQQOQ0=OOQQQQQOQ0[OCQQQQQOQ0]then begin
Result:=True;
Exit;
end;
until(O0CQQQQOQ0=lcEnd);
finally
OQQQQQQOQ0.Free;
end;
end;
function OOQQ0QQOQ0.OQCQQQQOQ0(const OCCQQQQOQ0:string;const O00CQQQOQ0:array of string):Boolean;
var
OO0CQQQOQ0:TSQLParser;
OQ0CQQQOQ0,OC0CQQQOQ0:Integer;
O0OCQQQOQ0:string;
begin
Assert(OCCQQQQOQ0<>'');
Result:=False;
OO0CQQQOQ0:=O0OC0QQOQ0.Create(OCCQQQQOQ0);
try
OO0CQQQOQ0.OmitBlank:=True;
OO0CQQQOQ0.OmitComment:=True;
OO0CQQQOQ0.QuotedString:=True;
OO0CQQQOQ0.DecSeparator:='.';
OO0CQQQOQ0.ToBegin;
repeat
OC0CQQQOQ0:=OO0CQQQOQ0.GetNext(O0OCQQQOQ0);
for OQ0CQQQOQ0:=Low(O00CQQQOQ0)to High(O00CQQQOQ0)do
if UpperCase(O0OCQQQOQ0)=UpperCase(O00CQQQOQ0[OQ0CQQQOQ0])then begin
Result:=True;
Exit;
end;
until(OC0CQQQOQ0=lcEnd);
finally
OO0CQQQOQ0.Free;
end;
end;
function OOQQ0QQOQ0.OOOCQQQOQ0(const OQOCQQQOQ0:string):string;
var
OCOCQQQOQ0:StringBuilder;
O0QCQQQOQ0:TSQLParser;
OOQCQQQOQ0:Integer;
OQQCQQQOQ0,OCQCQQQOQ0:string;
O0CCQQQOQ0:boolean;
begin
Result:=Trim(OQOCQQQOQ0);
if(Length(Result)>1)and(Result[1]='{')and(Result[Length(Result)]='}')then begin
Result:=Copy(Result,2,Length(Result)-2);
if not OQCQQQQOQ0(Result,['CALL'])then
Exit;
OCQCQQQOQ0:='';
O0CCQQQOQ0:=False;
OCOCQQQOQ0:=StringBuilder.Create(Length(Result)+Length(Result)div 2);
O0QCQQQOQ0:=O0OC0QQOQ0.Create(Result);
try
O0QCQQQOQ0.OmitBlank:=False;
O0QCQQQOQ0.OmitComment:=True;
O0QCQQQOQ0.QuotedString:=True;
O0QCQQQOQ0.ToBegin;
repeat
OOQCQQQOQ0:=O0QCQQQOQ0.GetNext(OQQCQQQOQ0);
if UpperCase(OQQCQQQOQ0)='CALL' then begin
OCOCQQQOQ0.Append('EXEC ');
if OCQCQQQOQ0<>'' then
OCOCQQQOQ0.Append(OCQCQQQOQ0+' = ');
O0CCQQQOQ0:=True;
end
else
if not O0CCQQQOQ0 and(OOQCQQQOQ0<>lxEqual)and(OOQCQQQOQ0<>lcBlank)then
OCQCQQQOQ0:=OCQCQQQOQ0+OQQCQQQOQ0
else
if O0CCQQQOQ0 and not(OOQCQQQOQ0 in[lxLeftBracket,lxRightBracket])then
OCOCQQQOQ0.Append(OQQCQQQOQ0);
until OOQCQQQOQ0=lcEnd;
Result:=OCOCQQQOQ0.ToString;
finally
O0QCQQQOQ0.Free;
OCOCQQQOQ0.Free;
end;
end;
end;
function OOQQ0QQOQ0.O0000OQOQ0(const OO000OQOQ0:string):string;
var
OQ000OQOQ0:StringBuilder;
OC000OQOQ0:TSQLParser;
O0O00OQOQ0:Integer;
OOO00OQOQ0:Integer;
OQO00OQOQ0:Integer;
OCO00OQOQ0:string;
O0Q00OQOQ0:TStringList;
begin
if OC00QQQOQ0=nil then begin
Result:=OO000OQOQ0;
Exit;
end;
if Pos('?',OO000OQOQ0)>0 then begin
OQO00OQOQ0:=0;
OQ000OQOQ0:=StringBuilder.Create(Length(OO000OQOQ0)*2);
O0Q00OQOQ0:=TStringList.Create;
try
OC000OQOQ0:=O0OC0QQOQ0.Create(OO000OQOQ0);
try
OC000OQOQ0.OmitBlank:=False;
OC000OQOQ0.OmitComment:=True;
OC000OQOQ0.QuotedString:=True;
OC000OQOQ0.DecSeparator:='.';
OC000OQOQ0.ToBegin;
OOO00OQOQ0:=OC000OQOQ0.CurrPos;
repeat
O0O00OQOQ0:=OC000OQOQ0.GetNextToken;
if O0O00OQOQ0=lxQuestion then begin
OQ000OQOQ0.Append(Copy(OO000OQOQ0,OOO00OQOQ0+1,OC000OQOQ0.CurrPos-OOO00OQOQ0-1));
if OQO00OQOQ0>=Length(OC00QQQOQ0)then
raise Exception.CreateFmt('ParamIndex %d out of range',[OQO00OQOQ0]);
OCO00OQOQ0:=OC00QQQOQ0[OQO00OQOQ0].O0QQQCQOQ0;
if(Length(OCO00OQOQ0)>1)and(OCO00OQOQ0[1]=O00CCOQOQ0)and(OCO00OQOQ0[Length(OCO00OQOQ0)]=OO0CCOQOQ0)then
OCO00OQOQ0:='P'+IntToStr(OQO00OQOQ0);
if O0Q00OQOQ0.IndexOf(OCO00OQOQ0)>=0 then
OCO00OQOQ0:=OCO00OQOQ0+'_'+IntToStr(OQO00OQOQ0);
OC00QQQOQ0[OQO00OQOQ0].O0QQQCQOQ0:=OCO00OQOQ0;
OQ000OQOQ0.Append('@'+OCO00OQOQ0);
O0Q00OQOQ0.Add(OCO00OQOQ0);
Inc(OQO00OQOQ0);
OOO00OQOQ0:=OC000OQOQ0.CurrPos;
end;
until O0O00OQOQ0=lcEnd;
OQ000OQOQ0.Append(Copy(OO000OQOQ0,OOO00OQOQ0+1,OC000OQOQ0.CurrPos-OOO00OQOQ0));
finally
OC000OQOQ0.Free;
end;
Result:=OQ000OQOQ0.ToString;
finally
O0Q00OQOQ0.Free;
OQ000OQOQ0.Free;
end;
end
else
Result:=OO000OQOQ0;
end;
function OOQQ0QQOQ0.OCC00QQOQ0:byte;
begin
Result:=0;
end;
procedure OOQQ0QQOQ0.OOC0QQQOQ0;
begin
if OCCC0QQOQ0 then
Exit;
OCQQ0QQOQ0.OQ0OO0COQ0;
OCQQ0QQOQ0.OOCCC0COQ0(SizeOf(OC0QOOCOQ0));
OOCCQQQOQ0(OQQCCCCOQ0,OCC00QQOQ0);
OCCC0QQOQ0:=True;
end;
procedure OOQQ0QQOQ0.OOQ00OQOQ0;
begin
OOCC0QQOQ0:=False;
O0000QQOQ0:=False;
OO000QQOQ0:=False;
O0C0CQQOQ0;
end;
procedure OOQQ0QQOQ0.O000QQQOQ0;
begin
while not O0QC0QQOQ0 or OQQQ0QQOQ0.OQCC00COQ0 do
O0C0CQQOQ0;
end;
procedure OOQQ0QQOQ0.OQQ00OQOQ0;
begin
if not O0QC0QQOQ0 then
OQQQ0QQOQ0.OQQ000COQ0;
end;
procedure OOQQ0QQOQ0.OQCCQQQOQ0;
begin
if OC000QQOQ0 and not O0O00QQOQ0 then
Exit;
OQQQ0QQOQ0.O0O000COQ0;
OQQQ0QQOQ0.O0Q000COQ0;
OOQ00OQOQ0;
{$IFDEF LOG_PACKETS}
AddToLog(Format('GetFullResponse: FProtocol %p, CmdContext %p, FIsLastPacket %d, FCurrentIsRowDataToken %d',[Pointer(O0CQ0QQOQ0),Pointer(Self),Integer(O0QC0QQOQ0),Integer(O0CC0QQOQ0)]));
{$ENDIF}
end;
procedure OOQQ0QQOQ0.OCCCQQQOQ0;
begin
if OC000QQOQ0 and not O0O00QQOQ0 then
Exit;
OQQQ0QQOQ0.O0O000COQ0;
O0CC0QQOQ0:=False;
OQQC0QQOQ0:=0;
OQQQ0QQOQ0.OQO000COQ0;
if not O0QC0QQOQ0 and
not OCQO0OQOQ0 and
not O0CQ0QQOQ0.OOOQ0QQOQ0
then
O0CQ0QQOQ0.O0OQ0QQOQ0.OQCQOCQOQ0(OQQQ0QQOQ0);
while not O0CC0QQOQ0 and(not O0QC0QQOQ0 or OQQQ0QQOQ0.OQCC00COQ0)do
OOQ00OQOQ0;
{$IFDEF LOG_PACKETS}
AddToLog(Format('GetResponse: FProtocol %p, CmdContext %p, FIsLastPacket %d, FCurrentIsRowDataToken %d',[Pointer(O0CQ0QQOQ0),Pointer(Self),Integer(O0QC0QQOQ0),Integer(O0CC0QQOQ0)]));
{$ENDIF}
end;
procedure OOQQ0QQOQ0.OCO0QQQOQ0(out OO0QOQQOQ0:Integer;out OQ0QOQQOQ0:Boolean);
begin
try
O0CQ0QQOQ0.OCCOQCQOQ0(OQOC0QQOQ0,OO0QOQQOQ0,OQ0QOQQOQ0,-1);
except
O0QC0QQOQ0:=True;
raise;
end;
end;
procedure OOQQ0QQOQ0.O0Q0QQQOQ0(OCQQOQQOQ0:IntPtr;O0CQOQQOQ0:Integer;OOCQOQQOQ0:Boolean);
begin
try
O0CQ0QQOQ0.OQQQOQQOQ0(OCQQOQQOQ0,O0CQOQQOQ0,OOCQOQQOQ0,-1);
except
O0QC0QQOQ0:=True;
raise;
end;
end;
procedure OOQQ0QQOQ0.OOCCQQQOQ0(OQ0COQQOQ0:Byte;OC0COQQOQ0:Byte=0);
begin
OOOC0QQOQ0:=OQ0COQQOQ0;
try
O0CQ0QQOQ0.OO0COQQOQ0(OOOC0QQOQ0,OC0COQQOQ0,OCQQ0QQOQ0,-1);
except
on E:SocketException do
OCC00OQOQ0.OOCOOQQOQ0(E.ErrorCode,E.Message,OOCQ0QQOQ0);
on E:Exception do
raise;
end;
O0QC0QQOQ0:=O0CQ0QQOQ0.OQ00QCQOQ0;
end;
procedure OOQQ0QQOQ0.OOQ0QQQOQ0(OQQ0QQQOQ0:Boolean);
begin
O0QC0QQOQ0:=OQQ0QQQOQ0;
end;
constructor OQOCQCQOQ0.Create;
begin
inherited;
OCOCQCQOQ0:=TCriticalSection.Create;
O0QCQCQOQ0:=OCOQOCQOQ0.Create;
OQ00QCQOQ0:=True;
end;
destructor OQOCQCQOQ0.Destroy;
begin
O0QCQCQOQ0.Free;
O0O0OQQOQ0;
OCOCQCQOQ0.Free;
inherited;
end;
procedure OQOCQCQOQ0.OCCCOQQOQ0(O000OQQOQ0:TProxyOptions;const OO00OQQOQ0:string;OQ00OQQOQ0:integer;OC00OQQOQ0:TIPVersion);
begin
OCCCQCQOQ0:=TCRVioTcp.Create(O000OQQOQ0,'',OO00OQQOQ0,OQ00OQQOQ0,OC00OQQOQ0);
end;
procedure OQOCQCQOQ0.O0O0OQQOQ0;
begin
FreeAndNil(OCCCQCQOQ0);
end;
function OQOCQCQOQ0.OOQCQCQOQ0:Integer;
begin
Result:=OCCCQCQOQ0.Timeout;
end;
procedure OQOCQCQOQ0.OQQCQCQOQ0(OCQCQCQOQ0:Integer);
begin
OCCCQCQOQ0.Timeout:=OCQCQCQOQ0;
end;
function OQOCQCQOQ0.O0CCQCQOQ0:Integer;
begin
Result:=OCCCQCQOQ0.ReceiveTimeout;
end;
procedure OQOCQCQOQ0.OOCCQCQOQ0(OQCCQCQOQ0:Integer);
begin
OCCCQCQOQ0.ReceiveTimeout:=OQCCQCQOQ0;
end;
procedure OQOCQCQOQ0.OOO0OQQOQ0;
begin
OCOCQCQOQ0.Enter;
end;
procedure OQOCQCQOQ0.OQO0OQQOQ0;
begin
OCOCQCQOQ0.Release;
end;
procedure OQOCQCQOQ0.OCO0OQQOQ0(const O0Q0OQQOQ0:O00QCOQOQ0;OOQ0OQQOQ0:boolean;
OQQ0OQQOQ0:OOQ0CCQOQ0;OCQ0OQQOQ0:OOC0CCQOQ0;O0C0OQQOQ0:O00OCCQOQ0);
begin
OO00QCQOQ0:=O0Q0OQQOQ0;
{$IFDEF LOG_PACKETS}
AddToLog(sLineBreak+'Connecting');
{$ENDIF}
Assert(Assigned(OQQ0OQQOQ0));
OCO0QCQOQ0:=OQQ0OQQOQ0;
Assert(Assigned(OCQ0OQQOQ0));
O0Q0QCQOQ0:=OCQ0OQQOQ0;
OOQ0QCQOQ0:=O0C0OQQOQ0;
OCCCQCQOQ0.Connect;
end;
function OQOCQCQOQ0.O0QOQCQOQ0:Boolean;
begin
Result:=OO00QCQOQ0.O0CQCOQOQ0;
end;
function OQOCQCQOQ0.OOQOQCQOQ0:boolean;
begin
if OO00QCQOQ0.O0CQCOQOQ0 then
Result:=True
else
Result:=OQ00QCQOQ0;
end;
procedure OQOCQCQOQ0.OO0OOQQOQ0(OQ0OOQQOQ0:Word);
begin
case OQ0OOQQOQ0 of
$500:OOO0QCQOQ0:=OQ00CCCOQ0;
$700:OOO0QCQOQ0:=OOO0CCCOQ0;
$701:OOO0QCQOQ0:=OCO0CCCOQ0;
$702:OOO0QCQOQ0:=O0Q0CCCOQ0;
$703:OOO0QCQOQ0:=OOQ0CCCOQ0;
$704:OOO0QCQOQ0:=OCQ0CCCOQ0;
else
raise Exception.CreateFmt('Unknown protocol version %X',[OQ0OOQQOQ0]);
end;
end;
procedure OQOCQCQOQ0.OO0OOQQOQ0(OC0OOQQOQ0,O0OOOQQOQ0:Byte);
begin
OO0OOQQOQ0((OC0OOQQOQ0 shl 8)or O0OOOQQOQ0);
end;
function OQOCQCQOQ0.OOOOOQQOQ0:Word;
begin
case OOO0QCQOQ0 of
OQ00CCCOQ0:Result:=$500;
OOO0CCCOQ0:Result:=$700;
OCO0CCCOQ0:Result:=$701;
O0Q0CCCOQ0:Result:=$702;
OOQ0CCCOQ0:Result:=$703;
OQQ0CCCOQ0:Result:=$703;
OCQ0CCCOQ0:Result:=$704;
else
raise Exception.CreateFmt('Unknown protocol version %X',[OOO0QCQOQ0]);
end;
end;
procedure OQOCQCQOQ0.OOC0OQQOQ0(OQC0OQQOQ0:Integer);
begin
O0O0QCQOQ0:=OQC0OQQOQ0;
if OQC0OQQOQ0>0 then
OQO0QCQOQ0:={$IFDEF NEXTGEN}Encoding{$ENDIF}(Encoding.GetEncoding(OQC0OQQOQ0))
else
OQO0QCQOQ0:={$IFDEF NEXTGEN}Encoding{$ENDIF}(Encoding.GetEncoding(1252));
end;
function OQOCQCQOQ0.OCC0OQQOQ0:Integer;
begin
Result:=O0O0QCQOQ0;
end;
function OQOCQCQOQ0.O00OOQQOQ0:Encoding;
begin
Result:=OQO0QCQOQ0;
end;
function OQOCQCQOQ0.O00OQCQOQ0(OO0OQCQOQ0:pointer;OQ0OQCQOQ0,OC0OQCQOQ0:Integer):Integer;
begin
Result:=OCCCQCQOQ0.Read(OO0OQCQOQ0,OQ0OQCQOQ0,OC0OQCQOQ0);
end;
function OQOCQCQOQ0.O0OOQCQOQ0(OOOOQCQOQ0:pointer;OQOOQCQOQ0,OCOOQCQOQ0:Integer):Integer;
begin
Result:=OCCCQCQOQ0.Write(OOOOQCQOQ0,OQOOQCQOQ0,OCOOQCQOQ0);
end;
procedure OQOCQCQOQ0.OO0COQQOQ0(OQ0COQQOQ0,OC0COQQOQ0:Byte;O0OCOQQOQ0:OQQCC0COQ0;OOOCOQQOQ0:integer);
var
OQOCOQQOQ0:OQ0QOOCOQ0;
OCOCOQQOQ0,O0QCOQQOQ0,OOQCOQQOQ0,OQQCOQQOQ0:Integer;
OCQCOQQOQ0:Word;
O0CCOQQOQ0:Byte;
begin
O0QCOQQOQ0:=O0OCOQQOQ0.OOQOO0COQ0-SizeOf(OC0QOOCOQ0);
OOQCOQQOQ0:=0;
O0CCOQQOQ0:=1;
OQQCOQQOQ0:=OC00QCQOQ0-SizeOf(OC0QOOCOQ0);
repeat
OQOCOQQOQ0:=PtrOffset(O0OCOQQOQ0.OCOOO0COQ0,OOQCOQQOQ0);
OQOCOQQOQ0.O0OQOOCOQ0:=OQ0COQQOQ0;
OQOCOQQOQ0.OCOQOOCOQ0:=0;
OQOCOQQOQ0.OOQQOOCOQ0:=0;
OQOCOQQOQ0.O0QQOOCOQ0:=O0CCOQQOQ0;
if O0QCOQQOQ0>OQQCOQQOQ0 then begin
OCQCOQQOQ0:=OQQCOQQOQ0;
OQOCOQQOQ0.OQOQOOCOQ0:=OCQCOCQOQ0(OC00QCQOQ0);
OQOCOQQOQ0.OOOQOOCOQ0:=OQQQOOCOQ0 or OC0COQQOQ0;
end
else begin
OCQCOQQOQ0:=O0QCOQQOQ0;
OQOCOQQOQ0.OQOQOOCOQ0:=OCQCOCQOQ0(Word(O0QCOQQOQ0+SizeOf(OC0QOOCOQ0)));
OQOCOQQOQ0.OOOQOOCOQ0:=OCQQOOCOQ0 or OC0COQQOQ0;
end;
if(O000QCQOQ0<>nil)and(OOOCOQQOQ0<>-1)then begin
try
O000QCQOQ0.OC0C0CQOQ0(OOOCOQQOQ0,O0OCOQQOQ0.OCOOO0COQ0,OOQCOQQOQ0,OCQCOQQOQ0+SizeOf(OC0QOOCOQ0));
except
if OCCCQCQOQ0.LastErrorCode=0 then
raise SocketException.Create('Connection has been gracefully closed by server',-1)
else
raise SocketException.Create(OCCCQCQOQ0.LastError,OCCCQCQOQ0.LastErrorCode);
end;
end
else begin
OCOCOQQOQ0:=O0OOQCQOQ0(O0OCOQQOQ0.OCOOO0COQ0,OOQCOQQOQ0,OCQCOQQOQ0+SizeOf(OC0QOOCOQ0));
{$IFDEF LOG_PACKETS}
AddDump(PtrOffset(WStream.GetBuffer,OOQCOQQOQ0),OCQCOQQOQ0+SizeOf(OC0QOOCOQ0),Format('Out packet: FProtocol %p',[Pointer(Self)]));
{$ENDIF}
if OCOCOQQOQ0<>OCQCOQQOQ0+SizeOf(OC0QOOCOQ0)then begin
{$IFDEF LOG_PACKETS}
AddToLog('Connection error: '+OCCCQCQOQ0.LastError);
{$ENDIF}
raise SocketException.Create(OCCCQCQOQ0.LastError,OCCCQCQOQ0.LastErrorCode);
end;
end;
O0CCOQQOQ0:=(O0CCOQQOQ0+1)and$FF;
Inc(OOQCOQQOQ0,OCQCOQQOQ0);
Dec(O0QCOQQOQ0,OCQCOQQOQ0);
until O0QCOQQOQ0<=0;
OQ00QCQOQ0:=False;
end;
function OQOCQCQOQ0.OQQOQCQOQ0(OCQOQCQOQ0:IntPtr;O0COQCQOQ0,OOCOQCQOQ0:Integer;OQCOQCQOQ0:integer):Integer;
begin
if(O000QCQOQ0<>nil)and(OQCOQCQOQ0<>-1)then begin
try
Result:=O000QCQOQ0.OOQC0CQOQ0(OQCOQCQOQ0,OCQOQCQOQ0,O0COQCQOQ0,OOCOQCQOQ0);
except
if OCCCQCQOQ0.LastErrorCode=0 then
raise SocketException.Create('Connection has been gracefully closed by server',-1)
else
raise SocketException.Create(OCCCQCQOQ0.LastError,OCCCQCQOQ0.LastErrorCode);
Result:=0;
Exit;
end;
end
else
Result:=O00OQCQOQ0(OCQOQCQOQ0,O0COQCQOQ0,OOCOQCQOQ0);
if Result<=0 then
if OCCCQCQOQ0.LastErrorCode=0 then
raise SocketException.Create('Connection has been gracefully closed by server',-1)
else
raise SocketException.Create(OCCCQCQOQ0.LastError,OCCCQCQOQ0.LastErrorCode);
end;
procedure OQOCQCQOQ0.OCCOQCQOQ0(out O00QOQQOQ0:Byte;out OO0QOQQOQ0:Integer;out OQ0QOQQOQ0:Boolean;OC0QOQQOQ0:integer);
const
O0OQOQQOQ0='Packet size exceeds max packet length';
var
OOOQOQQOQ0:OC0QOOCOQ0;
OQOQOQQOQ0:Integer;
OCOQOQQOQ0:Integer;
O0QQOQQOQ0:Integer;
OOQQOQQOQ0:Integer;
begin
try
O0QQOQQOQ0:=0;
OCOQOQQOQ0:=SizeOf(OC0QOOCOQ0);
while OCOQOQQOQ0>0 do begin
OOQQOQQOQ0:=OQQOQCQOQ0(@OOOQOQQOQ0,O0QQOQQOQ0,OCOQOQQOQ0,OC0QOQQOQ0);
Dec(OCOQOQQOQ0,OOQQOQQOQ0);
Inc(O0QQOQQOQ0,OOQQOQQOQ0);
end;
O00QOQQOQ0:=OOOQOQQOQ0.O0OQOOCOQ0;
OQ0QOQQOQ0:=(OOOQOQQOQ0.OOOQOOCOQ0 and OCQQOOCOQ0)<>0;
OQOQOQQOQ0:=OCQCOCQOQ0(OOOQOQQOQ0.OQOQOOCOQ0);
if(OQOQOQQOQ0>OC00QCQOQ0)or(OQOQOQQOQ0<SizeOf(OC0QOOCOQ0))then
raise Exception.Create(O0OQOQQOQ0);
OO0QOQQOQ0:=OQOQOQQOQ0-SizeOf(OC0QOOCOQ0);
if OO0QOQQOQ0=0 then
OQ00QCQOQ0:=OQ0QOQQOQ0;
except
OQ00QCQOQ0:=True;
raise;
end;
end;
procedure OQOCQCQOQ0.OQQQOQQOQ0(OCQQOQQOQ0:IntPtr;O0CQOQQOQ0:Integer;OOCQOQQOQ0:Boolean;OQCQOQQOQ0:integer);
var
OCCQOQQOQ0:Integer;
O00COQQOQ0:Integer;
begin
try
OCCQOQQOQ0:=0;
while O0CQOQQOQ0>0 do begin
O00COQQOQ0:=OQQOQCQOQ0(OCQQOQQOQ0,OCCQOQQOQ0,O0CQOQQOQ0,OQCQOQQOQ0);
Dec(O0CQOQQOQ0,O00COQQOQ0);
Inc(OCCQOQQOQ0,O00COQQOQ0);
end;
OQ00QCQOQ0:=OOCQOQQOQ0;
except
OQ00QCQOQ0:=True;
raise;
end;
end;
procedure OQOCQCQOQ0.OCOOOQQOQ0;
begin
try
O0OQ0QQOQ0.O0QCOCQOQ0;
except
on E:SocketException do
OOCOOQQOQ0(E.ErrorCode,E.Message,nil);
on E:Exception do
raise;
end;
end;
end.
