//////////////////////////////////////////////////
//  SecureBridge Components
//  Copyright © 2007-2021 Devart. All right reserved.
//////////////////////////////////////////////////
{$I Tds.inc}
unit TdsCryptoAPIStorageUni;
interface
{$IFNDEF LINUX}
{$IFNDEF LINUX_BSD}
{$IFNDEF ANDROID}
uses
Classes,SysUtils,
{$IFDEF MSWINDOWS}
Windows,
{$ENDIF}
{$IFDEF POSIX}
{$IFNDEF ANDROID}Macapi.CoreFoundation,{$ENDIF}
Posix.Stdlib,Posix.String_,Posix.Dlfcn,
{$ENDIF}
{$IFDEF DARWIN}
MacTypes,CFBase,CFData,CFString,CFDictionary,CFNumber,CFArray,
{$ENDIF}
CLRClasses,CRTypes,
{$IFNDEF UNIDACPRO}
TdsUtils,TdsBridge,TdsCryptoAPIIntf,TdsASN1,TdsOids,TdsCertificateExts;
{$ELSE}
TdsUtilsUni,TdsBridgeUni,TdsCryptoAPIIntfUni,TdsASN1Uni,TdsOidsUni,TdsCertificateExtsUni;
{$ENDIF}
{$IFDEF VER16P}
const
pidCryptoAPIPlatforms=pidWin32 or pidWin64 or pidOSX32{$IFDEF VER26P} or pidOSX64{$ENDIF}
{$IFDEF VER18P} or pidiOSSimulator{$IFNDEF VER22P} or pidiOSDevice{$ELSE} or pidiOSDevice32 or pidiOSDevice64{$ENDIF}{$ENDIF};
{$ENDIF}
type
{$IFDEF MSWINDOWS}
OCCQCOOCQ0=(
OOQQCOOCQ0,
OQQQCOOCQ0,
OCQQCOOCQ0,
O0CQCOOCQ0,
OOCQCOOCQ0,
OQCQCOOCQ0
);
O0QCCOOCQ0=(
O00CCOOCQ0,
OO0CCOOCQ0,
OQ0CCOOCQ0,
OC0CCOOCQ0,
O0OCCOOCQ0,
OOOCCOOCQ0,
OQOCCOOCQ0,
OCOCCOOCQ0
);
{$ENDIF}
{$IFDEF VER16P}
[ComponentPlatformsAttribute({$IFDEF STD}pidDevartWinPlatforms{$ELSE}pidCryptoAPIPlatforms{$ENDIF})]
{$ENDIF}
TScCryptoAPIStorage=class(OCCCQ00OQ0)
private
{$IFDEF MSWINDOWS}
OOQCCOOCQ0:OCCQCOOCQ0;
OQQCCOOCQ0:O0QCCOOCQ0;
OCQCCOOCQ0:string;
O0CCCOOCQ0:string;
OOCCCOOCQ0:Cardinal;
OQCCCOOCQ0:Integer;
procedure OCCCCOOCQ0(const O000COOCQ0:string);
procedure OOO0COOCQ0(const OQO0COOCQ0:OCCQCOOCQ0);
procedure OCO0COOCQ0(const O0Q0COOCQ0:O0QCCOOCQ0);
procedure OOQ0COOCQ0(const OQQ0COOCQ0:string);
function OCQ0COOCQ0(O0C0COOCQ0:TScCertificate):TScCertificate;
function OQ0OCOOCQ0(const OC0OCOOCQ0:TBytes;O0OOCOOCQ0:OOOOCOQOQ0):PCCERT_CONTEXT;
{$ELSE}
OCQQQ0OCQ0:string;
procedure O0CQQ0OCQ0(const OOCQQ0OCQ0:string);
procedure OQCQQ0OCQ0(OCCQQ0OCQ0:TStrings;O00CQ0OCQ0:SecItemClass;OO0CQ0OCQ0:CFTypeID);
function OCQCQ0OCQ0(O0CCQ0OCQ0:SecItemClass;const OOCCQ0OCQ0:string):SecKeychainItemRef;
class function OC00Q0OCQ0(var O0O0Q0OCQ0:IntPtr;out OOO0Q0OCQ0:OCQCQ00OQ0;
out OQO0Q0OCQ0:OOQQQOQOQ0;out OCO0Q0OCQ0:boolean):TBytes;
{$ENDIF}
procedure O0QOCOOCQ0(OOQOCOOCQ0:cardinal=0);
function OC0QQOOCQ0:{$IFDEF MSWINDOWS}HCERTSTORE{$ELSE}SecKeychainRef{$ENDIF};
procedure O0OQQOOCQ0(OOOQQOOCQ0:TStrings);
procedure OCQQQOOCQ0(O0CQQOOCQ0:TStrings);
procedure OQCQQOOCQ0(OCCQQOOCQ0:IntPtr);
{$IFDEF MSWINDOWS}
class function O00CQOOCQ0(OO0CQOOCQ0:IntPtr;OQ0CQOOCQ0:OOOOCOQOQ0):TBytes;
class function OQOCQOOCQ0(OCOCQOOCQ0:HCRYPTPROV;O0QCQOOCQ0:IntPtr=nil):HCRYPTKEY;
{$ELSE}
class function O0OOQ0OCQ0(const OOOOQ0OCQ0:TBytes;OQOOQ0OCQ0:boolean;
OCOOQ0OCQ0:SecKeychainRef;O0QOQ0OCQ0:IntPtr):IntPtr;
{$ENDIF}
protected
OQQCQOOCQ0:IntPtr;
procedure AssignTo(O0CCQOOCQ0:TPersistent);override;
procedure DefineProperties(OQCCQOOCQ0:TFiler);override;
{$IFDEF MSWINDOWS}
procedure OCCCQOOCQ0(O000QOOCQ0:TReader);
procedure OO00QOOCQ0(OQ00QOOCQ0:TWriter);
{$ELSE}
procedure OC0QOC0CQ0(O0OQOC0CQ0:TReader);
procedure OOOQOC0CQ0(OQOQOC0CQ0:TWriter);
{$ENDIF}
function OC00QOOCQ0(O0O0QOOCQ0:IntPtr;
out OOO0QOOCQ0:OCQCQ00OQ0;out OQO0QOOCQ0:OOQQQOQOQ0;
out OCO0QOOCQ0:boolean):TBytes;
procedure O0OOQ00OQ0;override;
procedure OO0COCC0Q0;override;
procedure O0QOQ00OQ0(OO0OQOOCQ0:O0OQ0CC0Q0);override;
procedure O0COQ00OQ0(OQQOQOOCQ0:O0OQ0CC0Q0);override;
procedure O00QOCC0Q0(OC0QO0OCQ0:O0OQ0CC0Q0);override;
procedure OQOQOCC0Q0(OOQQO0OCQ0:O0OQ0CC0Q0;const OQQQO0OCQ0:string;OCQQO0OCQ0:boolean);override;
procedure OOCQOCC0Q0(const O0OCO0OCQ0:OCCC0CC0Q0;OOOCO0OCQ0:TStrings);override;
function OO0OQ00OQ0:OOC0CCC0Q0;override;
function OC0OQ00OQ0:OQCQQCC0Q0;override;
function OQOCO0OCQ0(const OCOCO0OCQ0:TBytes;const O0QCO0OCQ0:string):IntPtr;
function OQCCO0OCQ0(OCCCO0OCQ0:IntPtr):TBytes;
function OO00O0OCQ0(OQ00O0OCQ0:IntPtr):string;
procedure O00COCC0Q0;override;
public
constructor Create(OQO0O0OCQ0:TComponent);override;
function FindCertificateBySubject(OCO0O0OCQ0:OQOCO0OOQ0):TScCertificate;
function CheckCertificateByIssuer(OQ0OO0OCQ0:TScCertificate):TScCertificateStatus;
{$IFDEF IOS}
class function CheckTrustCertificateByIssuer(OCQ0OC0CQ0:TScCertificate):TScCertificateStatus;
{$ENDIF}
{$IFDEF MSWINDOWS}
procedure GetProviderNames(OQOOO0OCQ0:TStrings);
{$ENDIF}
property Handle:IntPtr read OQQCQOOCQ0;
published
{$IFDEF MSWINDOWS}
property OCQOO0OCQ0:string read O0CCCOOCQ0 write OCCCCOOCQ0;
property O0COO0OCQ0:OCCQCOOCQ0 read OOQCCOOCQ0 write OOO0COOCQ0 default O0CQCOOCQ0;
property OOCOO0OCQ0:O0QCCOOCQ0 read OQQCCOOCQ0 write OCO0COOCQ0 default O00CCOOCQ0;
property OQCOO0OCQ0:string read OCQCCOOCQ0 write OOQ0COOCQ0 stored False;
{$ELSE}
property OQCCOC0CQ0:string read OCQQQ0OCQ0 write O0CQQ0OCQ0;
{$ENDIF}
end;
{$IFDEF MSWINDOWS}
const
OCCOO0OCQ0:array[0..3]of string=('MY','Root','Trust','CA');
{$ENDIF}
{$IFNDEF MSWINDOWS}
function OCCCOC0CQ0(O000OC0CQ0:CFStringRef):WideString;
procedure OQ00OC0CQ0(OC00OC0CQ0:OSStatus;const O0O0OC0CQ0:string='');
{$ENDIF}
{$ENDIF ANDROID}
{$ENDIF LINUX_BSD}
{$ENDIF LINUX}
implementation
{$IFNDEF LINUX}
{$IFNDEF LINUX_BSD}
{$IFNDEF ANDROID}
uses
{$IFDEF VER7P}
StrUtils,
{$ENDIF}
{$IFNDEF MSWINDOWS}
DateUtils,
{$ENDIF}
{$IFDEF VER17P}
{$IFNDEF NEXTGEN}
Contnrs,
{$ENDIF}
{$ENDIF}
SyncObjs,
CRDECUtil,CRFunctions,CRBigInteger,
{$IFNDEF UNIDACPRO}
TdsSSLConsts
{$ELSE}
TdsSSLConstsUni
{$ENDIF}
{$IFDEF MSWINDOWS},Registry{$ENDIF};
{$IFDEF MSWINDOWS}
const
O00Q00OCQ0=X509_ASN_ENCODING or PKCS_7_ASN_ENCODING;
OO0Q00OCQ0={$IFDEF UNICODE}WideString{$ENDIF}('SB_');
OQ0Q00OCQ0={$IFDEF UNICODE}WideString{$ENDIF}('{5DBA170A-13B6-4D3C-AE88-A29A1CDD350E}');
OC0Q00OCQ0='2.5.4.3';
function O0OQ00OCQ0(OOOQ00OCQ0:IntPtr):NativeUInt;
begin
Result:=NativeUInt(OOOQ00OCQ0 {$IFDEF FPC}-nil{$ENDIF});
end;
function OQOQ00OCQ0(OCOQ00OCQ0:NativeUInt):IntPtr;
begin
Result:=IntPtr({$IFDEF FPC}IntPtr(0)+{$ENDIF}OCOQ00OCQ0);
end;
function O0QQ00OCQ0(const OOQQ00OCQ0:{$IFDEF UNICODE}WideString{$ELSE}string{$ENDIF}):IntPtr;
begin
{$IFDEF UNICODE}
Result:=Marshal.StringToHGlobalUni(OOQQ00OCQ0);
{$ELSE}
Result:=Marshal.StringToHGlobalAnsi(OOQQ00OCQ0);
{$ENDIF}
end;
function OQQQ00OCQ0(OCQQ00OCQ0:IntPtr):{$IFDEF UNICODE}WideString{$ELSE}string{$ENDIF};
begin
{$IFDEF UNICODE}
Result:=Marshal.PtrToStringUni(OCQQ00OCQ0);
{$ELSE}
Result:=Marshal.PtrToStringAnsi(OCQQ00OCQ0);
{$ENDIF}
end;
function O0CQ00OCQ0:string;
begin
Result:=SysErrorMessage({$IFNDEF VER12P}Integer{$ENDIF}(GetLastError));
end;
type
OOCQ00OCQ0=class
protected
OQCQ00OCQ0:HCRYPTPROV;
OCCQ00OCQ0:string;
O00C00OCQ0:string;
OO0C00OCQ0:cardinal;
OQ0C00OCQ0:boolean;
public
constructor Create(const O0OC00OCQ0,OOOC00OCQ0:string;
OQOC00OCQ0:cardinal;OCOC00OCQ0:boolean);
destructor Destroy;override;
property O0CC00OCQ0:HCRYPTPROV read OQCQ00OCQ0;
end;
var
OOCC00OCQ0:OOCQ00OCQ0;
OQCC00OCQ0:string='';
OCCC00OCQ0:TCriticalSection;
function O00000OCQ0(const OO0000OCQ0,OQ0000OCQ0:string;
OC0000OCQ0:cardinal;O0O000OCQ0:boolean):HCRYPTPROV;
var
OOO000OCQ0:IntPtr;
OQO000OCQ0:IntPtr;
begin
if OO0000OCQ0='' then
OOO000OCQ0:=nil
else
OOO000OCQ0:=O0QQ00OCQ0(OO0000OCQ0);
if OQ0000OCQ0='' then
OQO000OCQ0:=nil
else
OQO000OCQ0:=O0QQ00OCQ0(OQ0000OCQ0);
try
Result:=0;
if not CryptAcquireContext(Result,OOO000OCQ0,OQO000OCQ0,OC0000OCQ0,CRYPT_SILENT)then
if(HRESULT(GetLastError)=NTE_BAD_KEYSET)and O0O000OCQ0 then
CryptAcquireContext(Result,OOO000OCQ0,OQO000OCQ0,OC0000OCQ0,CRYPT_NEWKEYSET or CRYPT_SILENT);
finally
if OQO000OCQ0<>nil then
Marshal.FreeCoTaskMem(OQO000OCQ0);
if OOO000OCQ0<>nil then
Marshal.FreeCoTaskMem(OOO000OCQ0);
end;
end;
constructor OOCQ00OCQ0.Create(const O0OC00OCQ0,OOOC00OCQ0:string;
OQOC00OCQ0:cardinal;OCOC00OCQ0:boolean);
begin
inherited Create;
OCCQ00OCQ0:=O0OC00OCQ0;
O00C00OCQ0:=OOOC00OCQ0;
OO0C00OCQ0:=OQOC00OCQ0;
OQCQ00OCQ0:=O00000OCQ0(OCCQ00OCQ0,O00C00OCQ0,OO0C00OCQ0,OCOC00OCQ0);
if(OQCQ00OCQ0=0)and(HRESULT(GetLastError)=NTE_EXISTS)and(OCCQ00OCQ0='')then begin
OCCQ00OCQ0:=OQ0Q00OCQ0;
OQCQ00OCQ0:=O00000OCQ0(OCCQ00OCQ0,O00C00OCQ0,OO0C00OCQ0,OCOC00OCQ0);
end;
Win32Check(OQCQ00OCQ0<>0);
end;
destructor OOCQ00OCQ0.Destroy;
var
OOQC00OCQ0:HCRYPTPROV;
OQQC00OCQ0:IntPtr;
OCQC00OCQ0:IntPtr;
begin
if OQCQ00OCQ0<>0 then
CryptReleaseContext(OQCQ00OCQ0,0);
if OQ0C00OCQ0 then begin
if O00C00OCQ0='' then
OCQC00OCQ0:=nil
else
OCQC00OCQ0:=O0QQ00OCQ0(O00C00OCQ0);
OQQC00OCQ0:=O0QQ00OCQ0(OCCQ00OCQ0);
try
Win32Check(CryptAcquireContext(OOQC00OCQ0,OQQC00OCQ0,OCQC00OCQ0,OO0C00OCQ0,
CRYPT_DELETEKEYSET or CRYPT_SILENT));
finally
if OCQC00OCQ0<>nil then
Marshal.FreeCoTaskMem(OCQC00OCQ0);
Marshal.FreeCoTaskMem(OQQC00OCQ0);
end;
end;
inherited;
end;
function OCO000OCQ0:HCRYPTPROV;
begin
O0QOOCOOQ0(OCCC00OCQ0);
try
if OOCC00OCQ0=nil then begin
if OQCC00OCQ0='' then begin
try
OOCC00OCQ0:=OOCQ00OCQ0.Create(OQ0Q00OCQ0,'',PROV_RSA_FULL,True);
except
on E:Exception do
OQCC00OCQ0:=E.Message;
end;
end;
if OQCC00OCQ0<>'' then
raise EScError.CreateFmt(OQCC00OCQ0,[],seCSPError);
end;
finally
OQQOOCOOQ0(OCCC00OCQ0);
end;
Result:=OOCC00OCQ0.O0CC00OCQ0;
end;
{$ENDIF}
constructor TScCryptoAPIStorage.Create(OQO0O0OCQ0:TComponent);
begin
inherited;
{$IFDEF MSWINDOWS}
OQCCCOOCQ0:=-1;
OOQCCOOCQ0:=O0CQCOOCQ0;
OQQCCOOCQ0:=O00CCOOCQ0;
OCQCCOOCQ0:='MY';
O0CCCOOCQ0:='';
OOCCCOOCQ0:=PROV_RSA_FULL;
{$ENDIF}
OQQCQOOCQ0:=nil;
end;
procedure TScCryptoAPIStorage.O0OOQ00OQ0;
begin
inherited;
{$IFDEF MSWINDOWS}
if OQQCQOOCQ0<>nil then begin
CertCloseStore(OQQCQOOCQ0,0);
OQQCQOOCQ0:=nil;
end;
if OQCCCOOCQ0>-1 then begin
CloseHandle(THandle(OQCCCOOCQ0));
OQCCCOOCQ0:=-1;
end;
{$ELSE}
if OQQCQOOCQ0<>nil then begin
CFRelease(OQQCQOOCQ0);
OQQCQOOCQ0:=nil;
end;
{$ENDIF}
end;
function TScCryptoAPIStorage.OC0QQOOCQ0:{$IFDEF MSWINDOWS}HCERTSTORE{$ELSE}SecKeychainRef{$ENDIF};
begin
if OQQCQOOCQ0=nil then
O0QOCOOCQ0;
Result:=OQQCQOOCQ0;
end;
procedure TScCryptoAPIStorage.O0QOCOOCQ0(OOQOCOOCQ0:cardinal=0);
{$IFDEF MSWINDOWS}
function OQQOCOOCQ0:Cardinal;
begin
case OOCOO0OCQ0 of
OOOCCOOCQ0:
Result:=CERT_SYSTEM_STORE_CURRENT_SERVICE;
O00CCOOCQ0:
Result:=CERT_SYSTEM_STORE_CURRENT_USER;
OO0CCOOCQ0:
Result:=CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY;
OQ0CCOOCQ0:
Result:=CERT_SYSTEM_STORE_LOCAL_MACHINE;
OC0CCOOCQ0:
Result:=CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE;
O0OCCOOCQ0:
Result:=CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY;
OQOCCOOCQ0:
Result:=CERT_SYSTEM_STORE_SERVICES;
OCOCCOOCQ0:
Result:=CERT_SYSTEM_STORE_USERS;
else
Result:=0;
Assert(False);
end;
end;
function OCQOCOOCQ0:HKEY;
begin
case OOCOO0OCQ0 of
OOOCCOOCQ0,OO0CCOOCQ0,
OC0CCOOCQ0,O0OCCOOCQ0,OQOCCOOCQ0:
Result:=0;
O00CCOOCQ0:
Result:=HKEY_CURRENT_USER;
OQ0CCOOCQ0:
Result:=HKEY_LOCAL_MACHINE;
OCOCCOOCQ0:
Result:=HKEY_USERS;
else
Result:=0;
Assert(False);
end;
end;
{$ENDIF}
var
{$IFDEF MSWINDOWS}
O0COCOOCQ0:LPCSTR;
OOCOCOOCQ0:Cardinal;
OQCOCOOCQ0:IntPtr;
OCCOCOOCQ0:HKEY;
O00QQOOCQ0:OOCQ00OCQ0;
OO0QQOOCQ0:string;
OQ0QQOOCQ0:Cardinal;
{$ELSE}
O00OQ0OCQ0:SecKeychainRef;
OO0OQ0OCQ0:OSStatus;
OQ0OQ0OCQ0:UInt32;
OC0OQ0OCQ0:AnsiString;
{$ENDIF}
begin
{$IFDEF MSWINDOWS}
if(OQCOO0OCQ0='')and(O0COO0OCQ0<>OOQQCOOCQ0)then
raise EScError.Create(seEmptyStorageName);
OOCOCOOCQ0:=0;
OCCOCOOCQ0:=0;
OQCOCOOCQ0:=nil;
if OO0Q0CC0Q0 then
OOQOCOOCQ0:=OOQOCOOCQ0 or CERT_STORE_READONLY_FLAG;
case O0COO0OCQ0 of
OOQQCOOCQ0:begin
O0COCOOCQ0:=LPCSTR(CERT_STORE_PROV_MEMORY);
end;
OQQQCOOCQ0:begin
O0COCOOCQ0:=LPCSTR(CERT_STORE_PROV_FILE);
OOCOCOOCQ0:=O00Q00OCQ0;
if(OQCOO0OCQ0<>'')and(OQCOO0OCQ0[1]='.')and
(OQCQ0QQ0Q0<>'')then
OO0QQOOCQ0:=IncludeTrailingBackslash(OQCQ0QQ0Q0)+OQCOO0OCQ0
else
OO0QQOOCQ0:=OQCOO0OCQ0;
if OQCCCOOCQ0>-1 then
CloseHandle(THandle(OQCCCOOCQ0));
if OO0Q0CC0Q0 then begin
OQCCCOOCQ0:=Integer(FileOpen(OO0QQOOCQ0,fmShareDenyWrite));
end
else begin
OOQOCOOCQ0:=OOQOCOOCQ0 or CERT_FILE_STORE_COMMIT_ENABLE_FLAG;
OQCCCOOCQ0:=Integer(CreateFile(PChar(OO0QQOOCQ0),
GENERIC_READ or GENERIC_WRITE,0,nil,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,0));
end;
Win32Check(OQCCCOOCQ0>-1);
OQCOCOOCQ0:=OQOQ00OCQ0(OQCCCOOCQ0);
end;
OCQQCOOCQ0:begin
O0COCOOCQ0:=LPCSTR(CERT_STORE_PROV_REG);
if RegOpenKeyEx(OCQOCOOCQ0,PChar(OQCOO0OCQ0),0,KEY_READ,OCCOCOOCQ0)<>ERROR_SUCCESS then
if OO0Q0CC0Q0 or(RegCreateKeyEx(OCQOCOOCQ0,PChar(OQCOO0OCQ0),
0,nil,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,nil,OCCOCOOCQ0,@OQ0QQOOCQ0)<>ERROR_SUCCESS)
then
raise EScError.Create(seCannotOpenRegistry);
OQCOCOOCQ0:=OQOQ00OCQ0(OCCOCOOCQ0);
end;
O0CQCOOCQ0:begin
O0COCOOCQ0:=LPCSTR(CERT_STORE_PROV_SYSTEM);
OQCOCOOCQ0:=Marshal.StringToHGlobalUni(WideString(OQCOO0OCQ0));
OOQOCOOCQ0:=OOQOCOOCQ0 or OQQOCOOCQ0;
end;
OOCQCOOCQ0:begin
O0COCOOCQ0:=LPCSTR(CERT_STORE_PROV_SYSTEM_REGISTRY);
OQCOCOOCQ0:=Marshal.StringToHGlobalUni(WideString(OQCOO0OCQ0));
OOQOCOOCQ0:=OOQOCOOCQ0 or OQQOCOOCQ0;
end;
OQCQCOOCQ0:begin
O0COCOOCQ0:=LPCSTR(CERT_STORE_PROV_PHYSICAL);
OQCOCOOCQ0:=Marshal.StringToHGlobalUni(WideString(OQCOO0OCQ0));
OOQOCOOCQ0:=OOQOCOOCQ0 or OQQOCOOCQ0;
end;
else
O0COCOOCQ0:=LPCSTR(0);
Assert(False);
end;
try
if OQQCQOOCQ0<>nil then begin
CertCloseStore(OQQCQOOCQ0,0);
OQQCQOOCQ0:=nil;
end;
if OCQOO0OCQ0<>'' then begin
O00QQOOCQ0:=OOCQ00OCQ0.Create('',O0CCCOOCQ0,OOCCCOOCQ0,True);
try
OQQCQOOCQ0:=CertOpenStore(O0COCOOCQ0,OOCOCOOCQ0,O00QQOOCQ0.O0CC00OCQ0,OOQOCOOCQ0,OQCOCOOCQ0);
finally
O00QQOOCQ0.Free;
end;
end
else
OQQCQOOCQ0:=CertOpenStore(O0COCOOCQ0,OOCOCOOCQ0,0,OOQOCOOCQ0,OQCOCOOCQ0);
Win32Check((OQQCQOOCQ0<>nil)or
(((OOQOCOOCQ0 and CERT_STORE_DELETE_FLAG)>0)and(GetLastError=0)));
finally
if(OQCOCOOCQ0<>nil)and(O0COO0OCQ0 in[O0CQCOOCQ0,OOCQCOOCQ0,OQCQCOOCQ0])then
Marshal.FreeCoTaskMem(OQCOCOOCQ0);
if OCCOCOOCQ0<>0 then
RegCloseKey(OCCOCOOCQ0);
end;
{$ELSE MSWINDOWS}
if OQQCQOOCQ0<>nil then begin
CFRelease(OQQCQOOCQ0);
OQQCQOOCQ0:=nil;
end;
if OCQQQ0OCQ0='' then begin
OQ00OC0CQ0(SecKeychainCopyDefault(O00OQ0OCQ0));
try
OQ0OQ0OCQ0:=128;
SetLengthA(OC0OQ0OCQ0,OQ0OQ0OCQ0);
OO0OQ0OCQ0:=SecKeychainGetPath(O00OQ0OCQ0,@OQ0OQ0OCQ0,PAnsiChar(OC0OQ0OCQ0));
if OO0OQ0OCQ0=errSecBufferTooSmall then begin
Inc(OQ0OQ0OCQ0);
SetLengthA(OC0OQ0OCQ0,OQ0OQ0OCQ0);
OQ00OC0CQ0(SecKeychainGetPath(O00OQ0OCQ0,@OQ0OQ0OCQ0,PAnsiChar(OC0OQ0OCQ0)));
end
else
OQ00OC0CQ0(OO0OQ0OCQ0);
OCQQQ0OCQ0:={$IFNDEF UNIX}CRFunctions.Utf8Decode{$ENDIF}(OC0OQ0OCQ0);
finally
if O00OQ0OCQ0<>nil then
CFRelease(O00OQ0OCQ0);
end;
end;
OC0OQ0OCQ0:=CRFunctions.Utf8Encode({$IFDEF FPC}WideString{$ENDIF}(OCQQQ0OCQ0));
OQ00OC0CQ0(SecKeychainOpen(PAnsiChar(OC0OQ0OCQ0),OQQCQOOCQ0));
{$ENDIF}
end;
procedure TScCryptoAPIStorage.OO0COCC0Q0;
begin
inherited;
{$IFDEF MSWINDOWS}
if(OQQCQOOCQ0<>nil)and(O0COO0OCQ0=OQQQCOOCQ0)then
if OQCCCOOCQ0>-1 then begin
SetFilePointer(THandle(OQCCCOOCQ0),0,nil,FILE_BEGIN);
CertSaveStore(OQQCQOOCQ0,O00Q00OCQ0,
CERT_STORE_SAVE_AS_STORE,CERT_STORE_SAVE_TO_FILE,OQOQ00OCQ0(OQCCCOOCQ0),0);
FlushFileBuffers(THandle(OQCCCOOCQ0));
end;
{$ENDIF}
end;
procedure TScCryptoAPIStorage.AssignTo(O0CCQOOCQ0:TPersistent);
begin
if IsClass(O0CCQOOCQ0,TScCryptoAPIStorage)then begin
TScCryptoAPIStorage(O0CCQOOCQ0).O0C0Q00OQ0:=O0C0Q00OQ0;
{$IFDEF MSWINDOWS}
TScCryptoAPIStorage(O0CCQOOCQ0).OCQOO0OCQ0:=OCQOO0OCQ0;
TScCryptoAPIStorage(O0CCQOOCQ0).O0COO0OCQ0:=O0COO0OCQ0;
TScCryptoAPIStorage(O0CCQOOCQ0).OOCOO0OCQ0:=OOCOO0OCQ0;
TScCryptoAPIStorage(O0CCQOOCQ0).OQCOO0OCQ0:=OQCOO0OCQ0;
{$ELSE}
TScCryptoAPIStorage(O0CCQOOCQ0).OQCCOC0CQ0:=OQCCOC0CQ0;
{$ENDIF}
end
else
inherited;
end;
procedure TScCryptoAPIStorage.DefineProperties(OQCCQOOCQ0:TFiler);
begin
inherited DefineProperties(OQCCQOOCQ0);
{$IFDEF MSWINDOWS}
OQCCQOOCQ0.DefineProperty('CertStoreName',OCCCQOOCQ0,OO00QOOCQ0,OCQCCOOCQ0<>'MY');
{$ELSE}
OQCCQOOCQ0.DefineProperty('KeychainPath',OC0QOC0CQ0,OOOQOC0CQ0,OCQQQ0OCQ0<>'');
{$ENDIF}
end;
{$IFDEF MSWINDOWS}
procedure TScCryptoAPIStorage.OCCCQOOCQ0(O000QOOCQ0:TReader);
begin
OCQCCOOCQ0:=O000QOOCQ0.ReadString;
end;
procedure TScCryptoAPIStorage.OO00QOOCQ0(OQ00QOOCQ0:TWriter);
begin
OQ00QOOCQ0.WriteString(OCQCCOOCQ0);
end;
{$ELSE}
procedure TScCryptoAPIStorage.OC0QOC0CQ0(O0OQOC0CQ0:TReader);
begin
OCQQQ0OCQ0:=O0OQOC0CQ0.ReadString;
end;
procedure TScCryptoAPIStorage.OOOQOC0CQ0(OQOQOC0CQ0:TWriter);
begin
OQOQOC0CQ0.WriteString(OCQQQ0OCQ0);
end;
{$ENDIF}
{$IFDEF MSWINDOWS}
procedure TScCryptoAPIStorage.GetProviderNames(OQOOO0OCQ0:TStrings);
var
OCOOO0OCQ0,O0QOO0OCQ0:Cardinal;
OOQOO0OCQ0:Cardinal;
OQQOO0OCQ0:IntPtr;
begin
OQOOO0OCQ0.Clear;
O0QOO0OCQ0:=0;
OCOOO0OCQ0:=0;
while True do begin
if not CryptEnumProviders(OCOOO0OCQ0,nil,0,OOQOO0OCQ0,nil,O0QOO0OCQ0)then
if GetLastError=ERROR_NO_MORE_ITEMS then
break
else
RaiseLastWin32Error;
OQQOO0OCQ0:=Marshal.AllocHGlobal(O0QOO0OCQ0);
try
Win32Check(CryptEnumProviders(OCOOO0OCQ0,nil,0,OOQOO0OCQ0,OQQOO0OCQ0,O0QOO0OCQ0));
OQOOO0OCQ0.Add(OQQQ00OCQ0(OQQOO0OCQ0));
finally
Marshal.FreeHGlobal(OQQOO0OCQ0);
end;
Inc(OCOOO0OCQ0);
end;
end;
procedure TScCryptoAPIStorage.OCCCCOOCQ0(const O000COOCQ0:string);
var
OO00COOCQ0,OQ00COOCQ0:Cardinal;
OC00COOCQ0:Cardinal;
O0O0COOCQ0:IntPtr;
begin
if O000COOCQ0<>O0CCCOOCQ0 then begin
O0OOQ00OQ0;
if O000COOCQ0='' then begin
OOCCCOOCQ0:=PROV_RSA_FULL;
O0CCCOOCQ0:='';
Exit;
end;
OQ00COOCQ0:=0;
OO00COOCQ0:=0;
while True do begin
if not CryptEnumProviders(OO00COOCQ0,nil,0,OC00COOCQ0,nil,OQ00COOCQ0)then
if GetLastError=ERROR_NO_MORE_ITEMS then
raise EScError.Create(seCannotFindProviderName)
else
RaiseLastWin32Error;
O0O0COOCQ0:=Marshal.AllocHGlobal(OQ00COOCQ0);
try
Win32Check(CryptEnumProviders(OO00COOCQ0,nil,0,OC00COOCQ0,O0O0COOCQ0,OQ00COOCQ0));
if O000COOCQ0=OQQQ00OCQ0(O0O0COOCQ0)then
break;
finally
Marshal.FreeHGlobal(O0O0COOCQ0);
end;
Inc(OO00COOCQ0);
end;
OOCCCOOCQ0:=OC00COOCQ0;
O0CCCOOCQ0:=O000COOCQ0;
end;
end;
procedure TScCryptoAPIStorage.OOO0COOCQ0(const OQO0COOCQ0:OCCQCOOCQ0);
begin
if OQO0COOCQ0<>OOQCCOOCQ0 then begin
OOQCCOOCQ0:=OQO0COOCQ0;
O0OOQ00OQ0;
end;
end;
procedure TScCryptoAPIStorage.OCO0COOCQ0(const O0Q0COOCQ0:O0QCCOOCQ0);
begin
if O0Q0COOCQ0<>OQQCCOOCQ0 then begin
OQQCCOOCQ0:=O0Q0COOCQ0;
O0OOQ00OQ0;
end;
end;
procedure TScCryptoAPIStorage.OOQ0COOCQ0(const OQQ0COOCQ0:string);
begin
if OQQ0COOCQ0<>OCQCCOOCQ0 then begin
OCQCCOOCQ0:=OQQ0COOCQ0;
O0OOQ00OQ0;
end;
end;
{$ELSE}
procedure TScCryptoAPIStorage.O0CQQ0OCQ0(const OOCQQ0OCQ0:string);
begin
if OOCQQ0OCQ0<>OCQQQ0OCQ0 then begin
OCQQQ0OCQ0:=OOCQQ0OCQ0;
O0OOQ00OQ0;
end;
end;
{$ENDIF}
procedure TScCryptoAPIStorage.OQCQQOOCQ0(OCCQQOOCQ0:IntPtr);
begin
{$IFDEF MSWINDOWS}
if OCCQQOOCQ0<>nil then
CertFreeCertificateContext(OCCQQOOCQ0);
{$ELSE}
if OCCQQOOCQ0<>nil then
CFRelease(OCCQQOOCQ0);
{$ENDIF}
end;
{$IFDEF MSWINDOWS}
function TScCryptoAPIStorage.OCQ0COOCQ0(O0C0COOCQ0:TScCertificate):TScCertificate;
var
OOC0COOCQ0:PCCERT_CONTEXT;
OQC0COOCQ0:PCCERT_CONTEXT;
OCC0COOCQ0:IntPtr;
O00OCOOCQ0:string;
OO0OCOOCQ0:Cardinal;
begin
if(O0C0COOCQ0=nil)or(O0C0COOCQ0.Handle=nil)then
OOC0COOCQ0:=nil
else
OOC0COOCQ0:=CertDuplicateCertificateContext(O0C0COOCQ0.Handle);
OQC0COOCQ0:=CertFindCertificateInStore(OC0QQOOCQ0,O00Q00OCQ0,0,CERT_FIND_ANY,nil,OOC0COOCQ0);
if OQC0COOCQ0=nil then
Result:=nil
else begin
OO0OCOOCQ0:=256;
OCC0COOCQ0:=Marshal.AllocHGlobal(OO0OCOOCQ0);
try
if CertGetCertificateContextProperty(OQC0COOCQ0,CERT_FRIENDLY_NAME_PROP_ID,OCC0COOCQ0,OO0OCOOCQ0)then begin
if PWideChar(PtrOffset(OCC0COOCQ0,OO0OCOOCQ0-2))^=#0 then
Dec(OO0OCOOCQ0,2);
O00OCOOCQ0:=string(Marshal.PtrToStringUni(OCC0COOCQ0,OO0OCOOCQ0 shr 1));
end
else
O00OCOOCQ0:='';
finally
Marshal.FreeHGlobal(OCC0COOCQ0);
end;
Result:=TScCertificate.Create(nil);
try
Result.SetRawData(OQC0COOCQ0,OQCQQOOCQ0,OQCCO0OCQ0(OQC0COOCQ0));
if O00OCOOCQ0='' then
Result.CertName:=Result.Subject
else
Result.CertName:=O00OCOOCQ0;
except
Result.Free;
raise;
end;
end;
end;
function TScCryptoAPIStorage.OQ0OCOOCQ0(const OC0OCOOCQ0:TBytes;O0OOCOOCQ0:OOOOCOQOQ0):PCCERT_CONTEXT;
var
OOOOCOOCQ0:Integer;
OQOOCOOCQ0:CRYPTOAPI_BLOB;
OCOOCOOCQ0:IntPtr;
begin
if Length(OC0OCOOCQ0)=0 then
raise EScError.Create(seInvalidInputArgs);
if O0OOCOOCQ0=OOC0COQOQ0 then
OOOOCOOCQ0:=CERT_FIND_SHA1_HASH
else if O0OOCOOCQ0=OQ0OCOQOQ0 then
OOOOCOOCQ0:=CERT_FIND_MD5_HASH
else
OOOOCOOCQ0:=CERT_FIND_HASH;
OQOOCOOCQ0.cbData:=Length(OC0OCOOCQ0);
OQOOCOOCQ0.pbData:=Marshal.AllocHGlobal(Length(OC0OCOOCQ0));
try
Marshal.Copy(OC0OCOOCQ0,0,OQOOCOOCQ0.pbData,Length(OC0OCOOCQ0));
OCOOCOOCQ0:=@OQOOCOOCQ0;
Result:=CertFindCertificateInStore(OC0QQOOCQ0,O00Q00OCQ0,0,OOOOCOOCQ0,OCOOCOOCQ0,nil);
finally
Marshal.FreeHGlobal(OQOOCOOCQ0.pbData);
end;
end;
{$ELSE MSWINDOWS}
procedure TScCryptoAPIStorage.OQCQQ0OCQ0(OCCQQ0OCQ0:TStrings;
O00CQ0OCQ0:SecItemClass;OO0CQ0OCQ0:CFTypeID);
var
OQ0CQ0OCQ0:SecKeychainSearchRef;
OC0CQ0OCQ0:SecKeychainItemRef;
O0OCQ0OCQ0:UInt32;
OOOCQ0OCQ0:UInt32;
OQOCQ0OCQ0:SecKeychainAttributeInfo;
OCOCQ0OCQ0:PSecKeychainAttributeList;
O0QCQ0OCQ0:OSStatus;
OOQCQ0OCQ0:AnsiString;
OQQCQ0OCQ0:TScCertificate;
begin
OQ00OC0CQ0(SecKeychainSearchCreateFromAttributes(OC0QQOOCQ0,O00CQ0OCQ0,nil,OQ0CQ0OCQ0));
try
O0OCQ0OCQ0:=kSecKeyPrintName;
OOOCQ0OCQ0:=CSSM_DB_ATTRIBUTE_FORMAT_BLOB;
OQOCQ0OCQ0.Count:=1;
OQOCQ0OCQ0.Tag:=@O0OCQ0OCQ0;
OQOCQ0OCQ0.Format:=@OOOCQ0OCQ0;
O0QCQ0OCQ0:=SecKeychainSearchCopyNext(OQ0CQ0OCQ0,OC0CQ0OCQ0);
while O0QCQ0OCQ0=0 do begin
try
if CFGetTypeID(OC0CQ0OCQ0)=OO0CQ0OCQ0 then begin
if O00CQ0OCQ0=kSecCertificateItemClass then begin
OQQCQ0OCQ0:=TScCertificate.Create(nil);
try
OQQCQ0OCQ0.SetRawData(CFRetain(OC0CQ0OCQ0),OQCQQOOCQ0,OQCCO0OCQ0(OC0CQ0OCQ0));
OQQCQ0OCQ0.CertName:=OQQCQ0OCQ0.Subject;
except
OQQCQ0OCQ0.Free;
raise;
end;
OCCQQ0OCQ0.AddObject(OQQCQ0OCQ0.CertName,OQQCQ0OCQ0);
end
else begin
OQ00OC0CQ0(SecKeychainItemCopyAttributesAndData(OC0CQ0OCQ0,@OQOCQ0OCQ0,nil,@OCOCQ0OCQ0,nil,nil));
Assert(OCOCQ0OCQ0.Count=1);
Assert(OCOCQ0OCQ0.Attr.Tag=kSecKeyPrintName);
SetLengthA(OOQCQ0OCQ0,OCOCQ0OCQ0.Attr.Length);
Move(OCOCQ0OCQ0.Attr.Data^,PAnsiChar(OOQCQ0OCQ0)^,LengthA(OOQCQ0OCQ0));
OCCQQ0OCQ0.AddObject({$IFDEF FPC}string{$ENDIF}(CRFunctions.Utf8Decode(OOQCQ0OCQ0)),nil);
end;
end;
finally
if OC0CQ0OCQ0<>nil then
CFRelease(OC0CQ0OCQ0);
end;
O0QCQ0OCQ0:=SecKeychainSearchCopyNext(OQ0CQ0OCQ0,OC0CQ0OCQ0);
end;
if O0QCQ0OCQ0<>errSecItemNotFound then
OQ00OC0CQ0(O0QCQ0OCQ0);
finally
if OQ0CQ0OCQ0<>nil then
CFRelease(OQ0CQ0OCQ0);
end;
end;
function TScCryptoAPIStorage.OCQCQ0OCQ0(
O0CCQ0OCQ0:SecItemClass;const OOCCQ0OCQ0:string):SecKeychainItemRef;
var
OQCCQ0OCQ0:SecKeychainAttributeList;
OCCCQ0OCQ0:SecKeychainAttribute;
O000Q0OCQ0:SecKeychainSearchRef;
OO00Q0OCQ0:AnsiString;
OQ00Q0OCQ0:OSStatus;
begin
Result:=nil;
OO00Q0OCQ0:=CRFunctions.Utf8Encode({$IFDEF FPC}WideString{$ENDIF}(OOCCQ0OCQ0));
OCCCQ0OCQ0.Tag:=kSecKeyPrintName;
OCCCQ0OCQ0.Length:=LengthA(OO00Q0OCQ0);
OCCCQ0OCQ0.Data:=PAnsiChar(OO00Q0OCQ0);
OQCCQ0OCQ0.Count:=1;
OQCCQ0OCQ0.Attr:=@OCCCQ0OCQ0;
OQ00OC0CQ0(SecKeychainSearchCreateFromAttributes(OC0QQOOCQ0,O0CCQ0OCQ0,@OQCCQ0OCQ0,O000Q0OCQ0));
try
OQ00Q0OCQ0:=SecKeychainSearchCopyNext(O000Q0OCQ0,Result);
if OQ00Q0OCQ0<>errSecItemNotFound then
OQ00OC0CQ0(OQ00Q0OCQ0);
finally
if O000Q0OCQ0<>nil then
CFRelease(O000Q0OCQ0);
end;
end;
class function TScCryptoAPIStorage.OC00Q0OCQ0(var O0O0Q0OCQ0:IntPtr;
out OOO0Q0OCQ0:OCQCQ00OQ0;out OQO0Q0OCQ0:OOQQQOQOQ0;
out OCO0Q0OCQ0:boolean):TBytes;
var
O0Q0Q0OCQ0:CSSM_KEY_PTR;
OOQ0Q0OCQ0:CFDataRef;
OQQ0Q0OCQ0:CFRange;
OCQ0Q0OCQ0:array[0..3]of pointer;
O0C0Q0OCQ0:array[0..3]of pointer;
OOC0Q0OCQ0:CFTypeRef;
OQC0Q0OCQ0:CFDictionaryRef;
OCC0Q0OCQ0:OSStatus;
begin
if _Assigned(@SecKeyGetCSSMKey)then begin
OQ00OC0CQ0(SecKeyGetCSSMKey(O0O0Q0OCQ0,O0Q0Q0OCQ0));
case O0Q0Q0OCQ0.KeyHeader.Format of
CSSM_KEYBLOB_RAW_FORMAT_NONE:
OOO0Q0OCQ0:=OOQCQ00OQ0;
CSSM_KEYBLOB_RAW_FORMAT_PKCS1:
OOO0Q0OCQ0:=OCOCQ00OQ0;
CSSM_KEYBLOB_RAW_FORMAT_PKCS8:
OOO0Q0OCQ0:=O0QCQ00OQ0;
else
raise EScError.Create(seWrongDataFormat);
end;
case O0Q0Q0OCQ0.KeyHeader.AlgorithmId of
CSSM_ALGID_RSA:
OQO0Q0OCQ0:=OCOQQOQOQ0;
CSSM_ALGID_DSA:
OQO0Q0OCQ0:=OQOQQOQOQ0;
else
raise EScError.Create(seWrongDataFormat);
end;
case O0Q0Q0OCQ0.KeyHeader.KeyClass of
CSSM_KEYCLASS_PUBLIC_KEY:
OCO0Q0OCQ0:=True;
CSSM_KEYCLASS_PRIVATE_KEY:
OCO0Q0OCQ0:=False;
else
raise EScError.Create(seWrongDataFormat);
end;
if O0Q0Q0OCQ0.KeyHeader.Format=CSSM_KEYBLOB_RAW_FORMAT_NONE then begin
OOO0Q0OCQ0:=OOQCQ00OQ0;
OQ00OC0CQ0(SecKeychainItemExport(O0O0Q0OCQ0,kSecFormatOpenSSL,0,nil,OOQ0Q0OCQ0));
OQQ0Q0OCQ0:=CFRangeMake(0,CFDataGetLength(OOQ0Q0OCQ0));
SetLength(Result,OQQ0Q0OCQ0.length);
if OQQ0Q0OCQ0.length>0 then
CFDataGetBytes(OOQ0Q0OCQ0,OQQ0Q0OCQ0,@Result[0]);
end
else begin
SetLength(Result,O0Q0Q0OCQ0.KeyData.Length);
Marshal.Copy(O0Q0Q0OCQ0.KeyData.Data,Result,0,Length(Result));
end;
end
else begin
OOO0Q0OCQ0:=OCOCQ00OQ0;
OQO0Q0OCQ0:=OCOQQOQOQ0;
OCO0Q0OCQ0:=True;
OCQ0Q0OCQ0[0]:=kSecClass;
O0C0Q0OCQ0[0]:=kSecClassKey;
OCQ0Q0OCQ0[1]:=kSecValueRef;
O0C0Q0OCQ0[1]:=O0O0Q0OCQ0;
OQC0Q0OCQ0:=CFDictionaryCreate(nil,@OCQ0Q0OCQ0,@O0C0Q0OCQ0,2,nil,nil);
SecItemAdd(OQC0Q0OCQ0,nil);
CFRelease(OQC0Q0OCQ0);
OCQ0Q0OCQ0[2]:=kSecAttrKeyClass;
O0C0Q0OCQ0[2]:=kSecAttrKeyClassPrivate;
OCQ0Q0OCQ0[3]:=kSecReturnRef;
O0C0Q0OCQ0[3]:=kCFBooleanTrue;
OQC0Q0OCQ0:=CFDictionaryCreate(nil,@OCQ0Q0OCQ0,@O0C0Q0OCQ0,4,nil,nil);
OOC0Q0OCQ0:=nil;
OCC0Q0OCQ0:=SecItemCopyMatching(OQC0Q0OCQ0,OOC0Q0OCQ0);
if OCC0Q0OCQ0=errSecSuccess then begin
CFRelease(O0O0Q0OCQ0);
O0O0Q0OCQ0:=OOC0Q0OCQ0;
OCO0Q0OCQ0:=False;
end
else
if OCC0Q0OCQ0=errSecItemNotFound then begin
OCO0Q0OCQ0:=True;
O0C0Q0OCQ0[2]:=kSecAttrKeyClassPublic;
end
else
OQ00OC0CQ0(OCC0Q0OCQ0);
OCQ0Q0OCQ0[3]:=kSecReturnData;
O0C0Q0OCQ0[3]:=kCFBooleanTrue;
OQC0Q0OCQ0:=CFDictionaryCreate(nil,@OCQ0Q0OCQ0,@O0C0Q0OCQ0,4,nil,nil);
OOQ0Q0OCQ0:=nil;
try
OQ00OC0CQ0(SecItemCopyMatching(OQC0Q0OCQ0,CFTypeRef(OOQ0Q0OCQ0)));
OQQ0Q0OCQ0:=CFRangeMake(0,CFDataGetLength(OOQ0Q0OCQ0));
SetLength(Result,OQQ0Q0OCQ0.length);
if OQQ0Q0OCQ0.length>0 then
CFDataGetBytes(OOQ0Q0OCQ0,OQQ0Q0OCQ0,@Result[0]);
finally
CFRelease(OQC0Q0OCQ0);
if OOQ0Q0OCQ0<>nil then
CFRelease(OOQ0Q0OCQ0);
end;
end;
end;
{$ENDIF}
procedure TScCryptoAPIStorage.O0OQQOOCQ0(OOOQQOOCQ0:TStrings);
{$IFDEF MSWINDOWS}
var
OQOQQOOCQ0:OOCQ00OCQ0;
OCOQQOOCQ0:IntPtr;
O0QQQOOCQ0:Cardinal;
OOQQQOOCQ0:Cardinal;
OQQQQOOCQ0:string;
{$ENDIF}
begin
{$IFDEF MSWINDOWS}
OCOQQOOCQ0:=nil;
OQOQQOOCQ0:=OOCQ00OCQ0.Create('',O0CCCOOCQ0,OOCCCOOCQ0,True);
try
O0QQQOOCQ0:=0;
Win32Check(CryptGetProvParam(OQOQQOOCQ0.O0CC00OCQ0,PP_ENUMCONTAINERS,nil,O0QQQOOCQ0,CRYPT_FIRST));
OOQQQOOCQ0:=CRYPT_FIRST;
OCOQQOOCQ0:=Marshal.AllocHGlobal(O0QQQOOCQ0);
while True do begin
if not CryptGetProvParam(OQOQQOOCQ0.O0CC00OCQ0,PP_ENUMCONTAINERS,OCOQQOOCQ0,O0QQQOOCQ0,OOQQQOOCQ0)then
if GetLastError=ERROR_NO_MORE_ITEMS then
break
else
RaiseLastWin32Error;
OQQQQOOCQ0:=string(Marshal.PtrToStringAnsi(OCOQQOOCQ0));
if LeftStr(OQQQQOOCQ0,3)=OO0Q00OCQ0 then
OOOQQOOCQ0.AddObject(Copy(OQQQQOOCQ0,4,MaxInt),nil);
OOQQQOOCQ0:=0;
end;
finally
Marshal.FreeHGlobal(OCOQQOOCQ0);
OQOQQOOCQ0.Free;
end;
{$ELSE}
OQCQQ0OCQ0(OOOQQOOCQ0,kSecPublicKeyItemClass,SecKeyGetTypeID);
OQCQQ0OCQ0(OOOQQOOCQ0,kSecPrivateKeyItemClass,SecKeyGetTypeID);
{$ENDIF}
end;
procedure TScCryptoAPIStorage.OCQQQOOCQ0(O0CQQOOCQ0:TStrings);
{$IFDEF MSWINDOWS}
var
OOCQQOOCQ0:TScCertificate;
{$ENDIF}
begin
{$IFDEF MSWINDOWS}
OOCQQOOCQ0:=OCQ0COOCQ0(nil);
while OOCQQOOCQ0<>nil do begin
O0CQQOOCQ0.AddObject(OOCQQOOCQ0.CertName,OOCQQOOCQ0);
OOCQQOOCQ0:=OCQ0COOCQ0(OOCQQOOCQ0);
end;
{$ELSE}
OQCQQ0OCQ0(O0CQQOOCQ0,kSecCertificateItemClass,SecCertificateGetTypeID);
{$ENDIF}
end;
procedure TScCryptoAPIStorage.OOCQOCC0Q0(const O0OCO0OCQ0:OCCC0CC0Q0;OOOCO0OCQ0:TStrings);
begin
if O0OCO0OCQ0=O0CQOOC0Q0 then
O0OQQOOCQ0(OOOCO0OCQ0)
else
if O0OCO0OCQ0=TScCertificate then
OCQQQOOCQ0(OOOCO0OCQ0)
else
raise EScError.Create(seNotOverriddenMethod);
end;
function TScCryptoAPIStorage.OO0OQ00OQ0:OOC0CCC0Q0;
begin
raise EScError.Create(seCryptoAPIStorageNotSupportUsers);
{$IFDEF FPC}
Result:=nil;
{$ENDIF}
end;
function TScCryptoAPIStorage.OC0OQ00OQ0:OQCQQCC0Q0;
begin
raise EScError.Create(seCryptoAPIStorageNotSupportCRLs);
{$IFDEF FPC}
Result:=nil;
{$ENDIF}
end;
procedure TScCryptoAPIStorage.O0QOQ00OQ0(OO0OQOOCQ0:O0OQ0CC0Q0);
var
{$IFDEF MSWINDOWS}
OQ0OQOOCQ0:OOCQ00OCQ0;
OC0OQOOCQ0:HCRYPTKEY;
O0OOQOOCQ0:PCCERT_CONTEXT;
OOOOQOOCQ0:Cardinal;
OQOOQOOCQ0:Cardinal;
OCOOQOOCQ0:IntPtr;
O0QOQOOCQ0:string;
{$ELSE}
O0CQOC0CQ0:SecKeychainItemRef;
OOCQOC0CQ0:OCQCQ00OQ0;
OQCQOC0CQ0:OOQQQOQOQ0;
OCCQOC0CQ0:boolean;
{$ENDIF}
OOQOQOOCQ0:TBytes;
begin
{$IFDEF MSWINDOWS}
if IsClass(OO0OQOOCQ0,O0CQOOC0Q0)then begin
OC0OQOOCQ0:=0;
OQ0OQOOCQ0:=OOCQ00OCQ0.Create(OO0Q00OCQ0+O0CQOOC0Q0(OO0OQOOCQ0).OOQOOCQ0Q0,
O0CCCOOCQ0,OOCCCOOCQ0,False);
try
OC0OQOOCQ0:=OQOCQOOCQ0(OQ0OQOOCQ0.O0CC00OCQ0);
OOOOQOOCQ0:=PRIVATEKEYBLOB;
if not CryptExportKey(OC0OQOOCQ0,0,OOOOQOOCQ0,0,nil,OQOOQOOCQ0)then begin
if HRESULT(GetLastError)=NTE_BAD_KEY_STATE then begin
OOOOQOOCQ0:=PUBLICKEYBLOB;
Win32Check(CryptExportKey(OC0OQOOCQ0,0,OOOOQOOCQ0,0,nil,OQOOQOOCQ0));
end
else
RaiseLastWin32Error;
end;
SetLength(OOQOQOOCQ0,OQOOQOOCQ0);
Win32Check(CryptExportKey(OC0OQOOCQ0,0,OOOOQOOCQ0,0,Windows.PBYTE(OOQOQOOCQ0),OQOOQOOCQ0));
finally
if OC0OQOOCQ0<>0 then
CryptDestroyKey(OC0OQOOCQ0);
OQ0OQOOCQ0.Free;
end;
O00OOQQ0Q0.OOQOOQQ0Q0(O0CQOOC0Q0(OO0OQOOCQ0),OOQOQOOCQ0,OQQCQ00OQ0,OCOQQOQOQ0,True);
end
else
if IsClass(OO0OQOOCQ0,TScCertificate)then begin
if Length(TScCertificate(OO0OQOOCQ0).CertName)=0 then
raise EScError.Create(seNullName);
O0OOQOOCQ0:=nil;
if TScCertificate(OO0OQOOCQ0).Handle<>nil then begin
OQOOQOOCQ0:=256;
OCOOQOOCQ0:=Marshal.AllocHGlobal(OQOOQOOCQ0);
try
repeat
O0OOQOOCQ0:=CertFindCertificateInStore(OC0QQOOCQ0,X509_ASN_ENCODING,0,CERT_FIND_EXISTING,
TScCertificate(OO0OQOOCQ0).Handle,O0OOQOOCQ0);
if O0OOQOOCQ0<>nil then begin
if CertGetCertificateContextProperty(O0OOQOOCQ0,CERT_FRIENDLY_NAME_PROP_ID,OCOOQOOCQ0,OQOOQOOCQ0)then begin
if PWideChar(PtrOffset(OCOOQOOCQ0,OQOOQOOCQ0-2))^=#0 then
Dec(OQOOQOOCQ0,2);
O0QOQOOCQ0:=string(Marshal.PtrToStringUni(OCOOQOOCQ0,OQOOQOOCQ0 shr 1));
end
else
O0QOQOOCQ0:=OO00O0OCQ0(O0OOQOOCQ0);
if O0QOQOOCQ0=TScCertificate(OO0OQOOCQ0).CertName then
break;
end;
until O0OOQOOCQ0=nil;
finally
Marshal.FreeHGlobal(OCOOQOOCQ0);
end;
end;
TScCertificate(OO0OQOOCQ0).SetRawData(O0OOQOOCQ0,OQCQQOOCQ0,OQCCO0OCQ0(O0OOQOOCQ0));
end
else
raise EScError.Create(seNotOverriddenMethod);
{$ELSE}
if IsClass(OO0OQOOCQ0,O0CQOOC0Q0)then begin
O0CQOC0CQ0:=OCQCQ0OCQ0(kSecPrivateKeyItemClass,O0CQOOC0Q0(OO0OQOOCQ0).OOQOOCQ0Q0);
try
if O0CQOC0CQ0=nil then begin
O0CQOC0CQ0:=OCQCQ0OCQ0(kSecPublicKeyItemClass,O0CQOOC0Q0(OO0OQOOCQ0).OOQOOCQ0Q0);
if O0CQOC0CQ0=nil then
OQ00OC0CQ0(errSecItemNotFound);
end;
OOQOQOOCQ0:=OC00Q0OCQ0(O0CQOC0CQ0,OOCQOC0CQ0,OQCQOC0CQ0,OCCQOC0CQ0);
O00OOQQ0Q0.OOQOOQQ0Q0(O0CQOOC0Q0(OO0OQOOCQ0),OOQOQOOCQ0,OOCQOC0CQ0,OQCQOC0CQ0,OCCQOC0CQ0);
finally
if O0CQOC0CQ0<>nil then
CFRelease(O0CQOC0CQ0);
end;
end
else
if IsClass(OO0OQOOCQ0,TScCertificate)then begin
if TScCertificate(OO0OQOOCQ0).Handle=nil then
OQ00OC0CQ0(errSecItemNotFound);
end
else
raise EScError.Create(seNotOverriddenMethod);
{$ENDIF}
end;
procedure TScCryptoAPIStorage.O0COQ00OQ0(OQQOQOOCQ0:O0OQ0CC0Q0);
var
OCQOQOOCQ0:TBytes;
{$IFDEF MSWINDOWS}
O0COQOOCQ0:OOCQ00OCQ0;
OOCOQOOCQ0:HCRYPTKEY;
OQCOQOOCQ0:TBytes;
OCCOQOOCQ0:CRYPTOAPI_BLOB;
O00QO0OCQ0:IntPtr;
OO0QO0OCQ0,OQ0QO0OCQ0:PCCERT_CONTEXT;
{$ELSE}
O00COC0CQ0:IntPtr;
OO0COC0CQ0:IntPtr;
{$ENDIF}
begin
SetLength(OCQOQOOCQ0,0);
{$IFDEF MSWINDOWS}
if IsClass(OQQOQOOCQ0,O0CQOOC0Q0)then begin
OOCOQOOCQ0:=0;
O0COQOOCQ0:=OOCQ00OCQ0.Create(OO0Q00OCQ0+O0CQOOC0Q0(OQQOQOOCQ0).OOQOOCQ0Q0,
O0CCCOOCQ0,OOCCCOOCQ0,True);
try
SetLength(OQCOQOOCQ0,0);
OQCOQOOCQ0:=O00OOQQ0Q0.OCQOOQQ0Q0(O0CQOOC0Q0(OQQOQOOCQ0));
Win32Check(CryptImportKey(O0COQOOCQ0.O0CC00OCQ0,OQCOQOOCQ0,Length(OQCOQOOCQ0),0,
CRYPT_EXPORTABLE,OOCOQOOCQ0));
finally
if OOCOQOOCQ0<>0 then
CryptDestroyKey(OOCOQOOCQ0);
O0COQOOCQ0.Free;
end;
end
else
if IsClass(OQQOQOOCQ0,TScCertificate)then begin
OCQOQOOCQ0:=TScCertificate(OQQOQOOCQ0).GetRawData;
OO0QO0OCQ0:=OQOCO0OCQ0(OCQOQOOCQ0,'');
Assert(OO0QO0OCQ0<>nil);
Win32Check(CertAddCertificateContextToStore(OC0QQOOCQ0,
OO0QO0OCQ0,CERT_STORE_ADD_NEW,OQ0QO0OCQ0));
OCCOOQQ0Q0.O00Q0QQ0Q0(TScCertificate(OQQOQOOCQ0),OQ0QO0OCQ0,OQCQQOOCQ0);
CertFreeCertificateContext(OO0QO0OCQ0);
OCCOQOOCQ0.cbData:=Length(TScCertificate(OQQOQOOCQ0).CertName)*2;
OCCOQOOCQ0.pbData:=Marshal.StringToHGlobalUni(WideString(TScCertificate(OQQOQOOCQ0).CertName));
O00QO0OCQ0:=@OCCOQOOCQ0;
Win32Check(CertSetCertificateContextProperty(OQ0QO0OCQ0,CERT_FRIENDLY_NAME_PROP_ID,0,O00QO0OCQ0));
end
else
raise EScError.Create(seNotOverriddenMethod);
{$ELSE}
if IsClass(OQQOQOOCQ0,O0CQOOC0Q0)then begin
OO0COC0CQ0:=O0OOQ0OCQ0(O00OOQQ0Q0.OCQOOQQ0Q0(O0CQOOC0Q0(OQQOQOOCQ0)),O0CQOOC0Q0(OQQOQOOCQ0).O0QOOCQ0Q0,OC0QQOOCQ0,nil);
CFRelease(OO0COC0CQ0);
end
else
if IsClass(OQQOQOOCQ0,TScCertificate)then begin
OCQOQOOCQ0:=TScCertificate(OQQOQOOCQ0).GetRawData;
O00COC0CQ0:=OQOCO0OCQ0(OCQOQOOCQ0,'');
OCCOOQQ0Q0.O00Q0QQ0Q0(TScCertificate(OQQOQOOCQ0),O00COC0CQ0,OQCQQOOCQ0);
OQ00OC0CQ0(SecCertificateAddToKeychain(O00COC0CQ0,OC0QQOOCQ0));
end
else
raise EScError.Create(seNotOverriddenMethod);
{$ENDIF}
end;
procedure TScCryptoAPIStorage.O00QOCC0Q0(OC0QO0OCQ0:O0OQ0CC0Q0);
{$IFDEF MSWINDOWS}
var
O0OQO0OCQ0:HCRYPTPROV;
OOOQO0OCQ0:PCCERT_CONTEXT;
OQOQO0OCQ0:TBytes;
OCOQO0OCQ0,O0QQO0OCQ0:IntPtr;
{$ENDIF}
begin
{$IFDEF MSWINDOWS}
if IsClass(OC0QO0OCQ0,O0CQOOC0Q0)then begin
if O0CCCOOCQ0='' then
OCOQO0OCQ0:=nil
else
OCOQO0OCQ0:=O0QQ00OCQ0(O0CCCOOCQ0);
O0QQO0OCQ0:=O0QQ00OCQ0(OO0Q00OCQ0+O0CQOOC0Q0(OC0QO0OCQ0).OOQOOCQ0Q0);
try
Win32Check(CryptAcquireContext(O0OQO0OCQ0,O0QQO0OCQ0,
OCOQO0OCQ0,OOCCCOOCQ0,CRYPT_DELETEKEYSET or CRYPT_SILENT));
finally
Marshal.FreeCoTaskMem(O0QQO0OCQ0);
if OCOQO0OCQ0<>nil then
Marshal.FreeCoTaskMem(OCOQO0OCQ0);
end;
end
else
if IsClass(OC0QO0OCQ0,TScCertificate)then begin
if TScCertificate(OC0QO0OCQ0).OQCC0CC0Q0 then begin
TScCertificate(OC0QO0OCQ0).GetFingerprint(OOC0COQOQ0,OQOQO0OCQ0);
OOOQO0OCQ0:=OQ0OCOOCQ0(OQOQO0OCQ0,OOC0COQOQ0);
if OOOQO0OCQ0=nil then
raise EScError.Create(seCannotFindCertificate);
Win32Check(CertDeleteCertificateFromStore(OOOQO0OCQ0));
end;
end
else
raise EScError.Create(seNotOverriddenMethod);
{$ELSE}
raise EScError.Create(seNotOverriddenMethod);
{$ENDIF}
end;
procedure TScCryptoAPIStorage.OQOQOCC0Q0(OOQQO0OCQ0:O0OQ0CC0Q0;const OQQQO0OCQ0:string;OCQQO0OCQ0:boolean);
{$IFDEF MSWINDOWS}
var
O0CQO0OCQ0:OOCQ00OCQ0;
OOCQO0OCQ0:HCRYPTPROV;
OQCQO0OCQ0:HCRYPTKEY;
OCCQO0OCQ0:TBytes;
O00CO0OCQ0,OO0CO0OCQ0:IntPtr;
OQ0CO0OCQ0:CRYPTOAPI_BLOB;
OC0CO0OCQ0:IntPtr;
{$ENDIF}
begin
{$IFDEF MSWINDOWS}
if IsClass(OOQQO0OCQ0,O0CQOOC0Q0)then begin
if(O0CQOOC0Q0(OOQQO0OCQ0).OOQOOCQ0Q0='')or(OQQQO0OCQ0='')then
raise EScError.Create(seNullName);
try
O0CQOOC0Q0(OOQQO0OCQ0).OQCC0CC0Q0:=True;
except
if OCQQO0OCQ0 then
raise
else
Exit;
end;
OQCQO0OCQ0:=0;
O0CQO0OCQ0:=OOCQ00OCQ0.Create(OO0Q00OCQ0+OQQQO0OCQ0,O0CCCOOCQ0,
OOCCCOOCQ0,True);
try
SetLength(OCCQO0OCQ0,0);
OCCQO0OCQ0:=O00OOQQ0Q0.OCQOOQQ0Q0(O0CQOOC0Q0(OOQQO0OCQ0));
Win32Check(CryptImportKey(O0CQO0OCQ0.O0CC00OCQ0,OCCQO0OCQ0,Length(OCCQO0OCQ0),0,
CRYPT_EXPORTABLE,OQCQO0OCQ0));
finally
if OQCQO0OCQ0<>0 then
CryptDestroyKey(OQCQO0OCQ0);
O0CQO0OCQ0.Free;
end;
if O0CCCOOCQ0='' then
O00CO0OCQ0:=nil
else
O00CO0OCQ0:=O0QQ00OCQ0(O0CCCOOCQ0);
OO0CO0OCQ0:=O0QQ00OCQ0(OO0Q00OCQ0+O0CQOOC0Q0(OOQQO0OCQ0).OOQOOCQ0Q0);
try
Win32Check(CryptAcquireContext(OOCQO0OCQ0,OO0CO0OCQ0,
O00CO0OCQ0,OOCCCOOCQ0,CRYPT_DELETEKEYSET or CRYPT_SILENT));
finally
Marshal.FreeCoTaskMem(OO0CO0OCQ0);
if O00CO0OCQ0<>nil then
Marshal.FreeCoTaskMem(O00CO0OCQ0);
end;
end
else
if IsClass(OOQQO0OCQ0,TScCertificate)then begin
if TScCertificate(OOQQO0OCQ0).Handle<>nil then begin
OQ0CO0OCQ0.cbData:=Length(OQQQO0OCQ0)*2;
OQ0CO0OCQ0.pbData:=Marshal.StringToHGlobalUni(WideString(OQQQO0OCQ0));
OC0CO0OCQ0:=@OQ0CO0OCQ0;
Win32Check(CertSetCertificateContextProperty(TScCertificate(OOQQO0OCQ0).Handle,
CERT_FRIENDLY_NAME_PROP_ID,0,OC0CO0OCQ0));
end;
end
else
raise EScError.Create(seNotOverriddenMethod);
{$ELSE}
raise EScError.Create(seNotOverriddenMethod);
{$ENDIF}
end;
function TScCryptoAPIStorage.FindCertificateBySubject(OCO0O0OCQ0:OQOCO0OOQ0):TScCertificate;
{$IFDEF MSWINDOWS}
function O0Q0O0OCQ0(OOQ0O0OCQ0:O0OOQCOOQ0):DWORD;
begin
case OOQ0O0OCQ0 of
OO00QCOOQ0:
Result:=CERT_RDN_OCTET_STRING;
OOO0QCOOQ0:
Result:=CERT_RDN_UTF8_STRING;
OQO0QCOOQ0:
Result:=CERT_RDN_NUMERIC_STRING;
OCO0QCOOQ0:
Result:=CERT_RDN_PRINTABLE_STRING;
O0Q0QCOOQ0:
Result:=CERT_RDN_TELETEX_STRING;
OOQ0QCOOQ0:
Result:=CERT_RDN_VIDEOTEX_STRING;
OQQ0QCOOQ0:
Result:=CERT_RDN_IA5_STRING;
OCQ0QCOOQ0:
Result:=CERT_RDN_GRAPHIC_STRING;
O0C0QCOOQ0:
Result:=CERT_RDN_VISIBLE_STRING;
OOC0QCOOQ0:
Result:=CERT_RDN_GENERAL_STRING;
OQC0QCOOQ0:
Result:=CERT_RDN_UNIVERSAL_STRING;
OCC0QCOOQ0:
Result:=CERT_RDN_BMP_STRING;
OQ0OQCOOQ0,OC0OQCOOQ0:
Result:=CERT_RDN_ENCODED_BLOB;
else
Result:=CERT_RDN_ANY_TYPE;
end;
end;
{$ENDIF}
{$IFDEF MSWINDOWS}
var
OQQ0O0OCQ0:PCCERT_CONTEXT;
OCQ0O0OCQ0:integer;
O0C0O0OCQ0:CERT_RDN;
OOC0O0OCQ0:array of CERT_RDN_ATTR;
OQC0O0OCQ0:array of AnsiString;
OCC0O0OCQ0:OC00COOOQ0;
O00OO0OCQ0:integer;
OO0OO0OCQ0:WideString;
{$ENDIF}
begin
{$IFDEF MSWINDOWS}
OCQ0O0OCQ0:=OCO0O0OCQ0.OOCOO0OOQ0;
SetLength(OOC0O0OCQ0,OCQ0O0OCQ0);
SetLength(OQC0O0OCQ0,OCQ0O0OCQ0);
O0C0O0OCQ0.cRDNAttr:=OCQ0O0OCQ0;
O0C0O0OCQ0.rgRDNAttr:=@OOC0O0OCQ0[0];
OO0OO0OCQ0:='';
for O00OO0OCQ0:=0 to OCQ0O0OCQ0-1 do begin
OCC0O0OCQ0:=OCO0O0OCQ0.OQCOO0OOQ0[O00OO0OCQ0].OQ0CO0OOQ0[0];
if OCC0O0OCQ0.O0OOCOOOQ0.OCOO0OOOQ0=OC0Q00OCQ0 then
OO0OO0OCQ0:=WideString(OCC0O0OCQ0.OCOOCOOOQ0);
OQC0O0OCQ0[O00OO0OCQ0]:=AnsiString(OCC0O0OCQ0.O0OOCOOOQ0.OCOO0OOOQ0);
OOC0O0OCQ0[O00OO0OCQ0].pszObjId:=PAnsiChar(OQC0O0OCQ0[O00OO0OCQ0]);
OOC0O0OCQ0[O00OO0OCQ0].dwValueType:=O0Q0O0OCQ0(OCC0O0OCQ0.OOOOCOOOQ0);
OOC0O0OCQ0[O00OO0OCQ0].Value.cbData:=Length(OCC0O0OCQ0.OQOOCOOOQ0);
if OOC0O0OCQ0[O00OO0OCQ0].Value.cbData>0 then
OOC0O0OCQ0[O00OO0OCQ0].Value.pbData:=@OCC0O0OCQ0.OQOOCOOOQ0[0];
end;
OQQ0O0OCQ0:=CertFindCertificateInStore(OC0QQOOCQ0,O00Q00OCQ0,0,CERT_FIND_SUBJECT_ATTR,@O0C0O0OCQ0,nil);
Result:=nil;
if OQQ0O0OCQ0<>nil then begin
Result:=TScCertificate.Create(nil);
try
Result.SetRawData(nil,nil,OQCCO0OCQ0(OQQ0O0OCQ0));
OQCQQOOCQ0(OQQ0O0OCQ0);
except
Result.Free;
raise;
end;
end
else
if OO0OO0OCQ0<>'' then begin
while True do begin
OQQ0O0OCQ0:=CertFindCertificateInStore(OC0QQOOCQ0,O00Q00OCQ0,0,CERT_FIND_SUBJECT_STR,PWideChar(OO0OO0OCQ0),OQQ0O0OCQ0);
if OQQ0O0OCQ0=nil then
break;
Result:=TScCertificate.Create(nil);
try
Result.SetRawData(nil,nil,OQCCO0OCQ0(OQQ0O0OCQ0));
if WideString(Result.Subject)=OO0OO0OCQ0 then begin
OQCQQOOCQ0(OQQ0O0OCQ0);
Exit;
end
else
FreeAndNil(Result);
except
Result.Free;
raise;
end;
end;
end;
{$ELSE}
Result:=nil;
{$ENDIF}
end;
function TScCryptoAPIStorage.CheckCertificateByIssuer(OQ0OO0OCQ0:TScCertificate):TScCertificateStatus;
{$IFDEF MSWINDOWS}
var
OC0OO0OCQ0:PCCERT_CONTEXT;
O0OOO0OCQ0:cardinal;
OOOOO0OCQ0:WideString;
{$ELSE}
{$IFNDEF IOS}
var
OQOCOC0CQ0:SecKeychainAttributeList;
OCOCOC0CQ0:SecKeychainAttribute;
O0QCOC0CQ0:SecKeychainSearchRef;
OOQCOC0CQ0:SecKeychainItemRef;
OQQCOC0CQ0:AnsiString;
OCQCOC0CQ0:OSStatus;
OC0OO0OCQ0:TScCertificate;
O0CCOC0CQ0:TScCertificateStatusSet;
OOCCOC0CQ0:TScCertificateStatus;
{$ENDIF}
{$ENDIF}
begin
if OQ0OO0OCQ0=nil then
raise EScError.Create(seInvalidInputArgs);
{$IFDEF MSWINDOWS}
if OQ0OO0OCQ0.Handle=nil then
raise EScError.Create(seInvalidInputArgs);
O0OOO0OCQ0:=CERT_STORE_SIGNATURE_FLAG;
OC0OO0OCQ0:=CertGetIssuerCertificateFromStore(OC0QQOOCQ0,OQ0OO0OCQ0.Handle,nil,O0OOO0OCQ0);
CertFreeCertificateContext(OC0OO0OCQ0);
if OC0OO0OCQ0=nil then begin
OOOOO0OCQ0:=WideString(OQ0OO0OCQ0.Subject);
OC0OO0OCQ0:=CertFindCertificateInStore(OC0QQOOCQ0,X509_ASN_ENCODING,0,CERT_FIND_SUBJECT_STR,PWideChar(OOOOO0OCQ0),nil);
end;
if OC0OO0OCQ0=nil then
Result:=csUntrustedRoot
else
if O0OOO0OCQ0>0 then begin
case O0OOO0OCQ0 of
CERT_STORE_SIGNATURE_FLAG:
Result:=csInvalidSignature;
CERT_STORE_TIME_VALIDITY_FLAG:
Result:=csExpired;
CERT_STORE_SIGNATURE_FLAG or CERT_STORE_TIME_VALIDITY_FLAG:
Result:=csUntrustedRoot;
else
Result:=csOtherError;
end;
end
else
Result:=csValid;
{$ELSE}
{$IFNDEF IOS}
OQQCOC0CQ0:=CRFunctions.Utf8Encode({$IFDEF FPC}WideString{$ENDIF}(OQ0OO0OCQ0.Issuer));
OCOCOC0CQ0.Tag:=kSecKeyPrintName;
OCOCOC0CQ0.Length:=LengthA(OQQCOC0CQ0);
OCOCOC0CQ0.Data:=PAnsiChar(OQQCOC0CQ0);
OQOCOC0CQ0.Count:=1;
OQOCOC0CQ0.Attr:=@OCOCOC0CQ0;
OQ00OC0CQ0(SecKeychainSearchCreateFromAttributes(OC0QQOOCQ0,kSecCertificateItemClass,@OQOCOC0CQ0,O0QCOC0CQ0));
try
OCQCOC0CQ0:=SecKeychainSearchCopyNext(O0QCOC0CQ0,OOQCOC0CQ0);
while OCQCOC0CQ0=0 do begin
try
OC0OO0OCQ0:=TScCertificate.Create(nil);
try
OC0OO0OCQ0.SetRawData(CFRetain(OOQCOC0CQ0),OQCQQOOCQ0,OQCCO0OCQ0(OOQCOC0CQ0));
if OQ0OO0OCQ0.IssuerName.Equals(OC0OO0OCQ0.SubjectName)then begin
O0CCOC0CQ0:=[];
OQ0OO0OCQ0.VerifyCertificateChain(nil,OC0OO0OCQ0,O0CCOC0CQ0);
Result:=csValid;
if O0CCOC0CQ0<>[]then begin
for OOCCOC0CQ0:=High(TScCertificateStatus)downto Low(TScCertificateStatus)do
if OOCCOC0CQ0 in O0CCOC0CQ0 then begin
Result:=OOCCOC0CQ0;
break;
end
end;
Exit;
end;
finally
OC0OO0OCQ0.Free;
end;
finally
if OOQCOC0CQ0<>nil then
CFRelease(OOQCOC0CQ0);
end;
OCQCOC0CQ0:=SecKeychainSearchCopyNext(O0QCOC0CQ0,OOQCOC0CQ0);
end;
if OCQCOC0CQ0=errSecItemNotFound then
Result:=csUntrustedRoot
else begin
OQ00OC0CQ0(OCQCOC0CQ0);
Result:=csOtherError;
end;
finally
if O0QCOC0CQ0<>nil then
CFRelease(O0QCOC0CQ0);
end;
{$ELSE}
Result:=CheckTrustCertificateByIssuer(OQ0OO0OCQ0);
{$ENDIF}
{$ENDIF}
end;
{$IFDEF IOS}
class function TScCryptoAPIStorage.CheckTrustCertificateByIssuer(OCQ0OC0CQ0:TScCertificate):TScCertificateStatus;
var
O0C0OC0CQ0:TBytes;
OOC0OC0CQ0:IntPtr;
OQC0OC0CQ0:array[0..0]of IntPtr;
OCC0OC0CQ0:CFDataRef;
O00OOC0CQ0:CFArrayRef;
OO0OOC0CQ0:SecPolicyRef;
OQ0OOC0CQ0:SecTrustRef;
OC0OOC0CQ0:SecTrustResultType;
begin
if OCQ0OC0CQ0=nil then
raise EScError.Create(seInvalidInputArgs);
Result:=csOtherError;
OCC0OC0CQ0:=nil;
OOC0OC0CQ0:=nil;
O00OOC0CQ0:=nil;
OO0OOC0CQ0:=nil;
OQ0OOC0CQ0:=nil;
try
O0C0OC0CQ0:=OCQ0OC0CQ0.GetRawData;
OCC0OC0CQ0:=CFDataCreateWithBytesNoCopy(nil,@O0C0OC0CQ0[0],Length(O0C0OC0CQ0),kCFAllocatorNull);
OOC0OC0CQ0:=SecCertificateCreateWithData(kCFAllocatorMalloc,OCC0OC0CQ0);
if OOC0OC0CQ0=nil then
raise EScError.Create(seNonCertificate);
OQC0OC0CQ0[0]:=OOC0OC0CQ0;
O00OOC0CQ0:=CFArrayCreate(kCFAllocatorMalloc,@OQC0OC0CQ0[0],1,nil);
OO0OOC0CQ0:=SecPolicyCreateBasicX509();
OQ00OC0CQ0(SecTrustCreateWithCertificates(O00OOC0CQ0,OO0OOC0CQ0,OQ0OOC0CQ0));
OQ00OC0CQ0(SecTrustEvaluate(OQ0OOC0CQ0,OC0OOC0CQ0));
if OC0OOC0CQ0 in[kSecTrustResultProceed,kSecTrustResultUnspecified]then
Result:=csValid
else
if OC0OOC0CQ0 in[kSecTrustResultRecoverableTrustFailure,kSecTrustResultFatalTrustFailure]then
Result:=csUntrustedRoot;
finally
if OCC0OC0CQ0<>nil then
CFRelease(OCC0OC0CQ0);
if OOC0OC0CQ0<>nil then
CFRelease(OOC0OC0CQ0);
if O00OOC0CQ0<>nil then
CFRelease(O00OOC0CQ0);
if OO0OOC0CQ0<>nil then
CFRelease(OO0OOC0CQ0);
if OQ0OOC0CQ0<>nil then
CFRelease(OQ0OOC0CQ0);
end;
end;
{$ENDIF}
procedure TScCryptoAPIStorage.O00COCC0Q0;
begin
OOCOOCC0Q0.OQOCCCC0Q0;
{$IFDEF MSWINDOWS}
O0QOCOOCQ0(CERT_STORE_DELETE_FLAG);
{$ENDIF}
O0OOQ00OQ0;
end;
{$IFNDEF MSWINDOWS}
function OCCCOC0CQ0(O000OC0CQ0:CFStringRef):WideString;
var
OO00OC0CQ0:CFRange;
begin
Result:='';
if O000OC0CQ0=nil then
Exit;
OO00OC0CQ0:=CFRangeMake(0,CFStringGetLength(O000OC0CQ0));
if OO00OC0CQ0.Length>0 then begin
SetLength(Result,OO00OC0CQ0.Length);
CFStringGetCharacters(O000OC0CQ0,OO00OC0CQ0,@Result[1]);
end;
end;
procedure OQ00OC0CQ0(OC00OC0CQ0:OSStatus;const O0O0OC0CQ0:string='');
var
OOO0OC0CQ0:CFStringRef;
OQO0OC0CQ0:string;
begin
if OC00OC0CQ0<>0 then begin
if _Assigned(@SecCopyErrorMessageString)then begin
OOO0OC0CQ0:=SecCopyErrorMessageString(OC00OC0CQ0,nil);
try
OQO0OC0CQ0:={$IFDEF FPC}string{$ENDIF}(OCCCOC0CQ0(OOO0OC0CQ0));
finally
if OOO0OC0CQ0<>nil then
CFRelease(OOO0OC0CQ0);
end;
end
else
OQO0OC0CQ0:=IntToStr(OC00OC0CQ0);
OQO0OC0CQ0:=O0O0OC0CQ0+OQO0OC0CQ0;
raise EScError.CreateFmt(OQO0OC0CQ0,[],seCSPError);
end;
end;
{$IFDEF UNIX}
procedure free(OQOOOC0CQ0:pointer);cdecl;external 'StdCLib' name 'free';
function memcmp(OCOOOC0CQ0:pointer;O0QOOC0CQ0:pointer;OOQOOC0CQ0:size_t):integer;cdecl;external 'StdCLib' name 'memcmp';
{$ENDIF}
procedure OCO0OC0CQ0(O0Q0OC0CQ0:PVOID);
begin
free(O0Q0OC0CQ0);
end;
{$ENDIF}
function TScCryptoAPIStorage.OQOCO0OCQ0(const OCOCO0OCQ0:TBytes;const O0QCO0OCQ0:string):IntPtr;
var
{$IFDEF MSWINDOWS}
OOQCO0OCQ0:IntPtr;
{$IFNDEF BCB}
OQQCO0OCQ0:CRYPTOAPI_BLOB;
OCQCO0OCQ0:IntPtr;
O0CCO0OCQ0:HCERTSTORE;
OOCCO0OCQ0:WideString;
{$ENDIF}
{$ELSE}
OQ0COC0CQ0:CFDataRef;
OC0COC0CQ0:CFStringRef;
{$ENDIF}
begin
if Length(OCOCO0OCQ0)=0 then
raise EScError.Create(seNonCertificate);
{$IFDEF MSWINDOWS}
OOQCO0OCQ0:=@OCOCO0OCQ0[0];
Result:=CertCreateCertificateContext(O00Q00OCQ0,OOQCO0OCQ0,Length(OCOCO0OCQ0));
{$IFNDEF BCB}
if Result=nil then begin
OQQCO0OCQ0.pbData:=OOQCO0OCQ0;
OQQCO0OCQ0.cbData:=Length(OCOCO0OCQ0);
OOCCO0OCQ0:=WideString(O0QCO0OCQ0);
OCQCO0OCQ0:=@OQQCO0OCQ0;
O0CCO0OCQ0:=PFXImportCertStore(OCQCO0OCQ0,PWideChar(OOCCO0OCQ0),CRYPT_EXPORTABLE);
if(O0CCO0OCQ0=nil)and(O0QCO0OCQ0='')then
O0CCO0OCQ0:=PFXImportCertStore(OCQCO0OCQ0,nil,CRYPT_EXPORTABLE);
Win32Check(O0CCO0OCQ0<>nil);
try
Result:=CertFindCertificateInStore(O0CCO0OCQ0,X509_ASN_ENCODING,0,CERT_FIND_ANY,nil,nil);
Win32Check(Result<>nil);
finally
CertCloseStore(O0CCO0OCQ0,0);
end;
end;
{$ENDIF}
Win32Check(Result<>nil);
{$ELSE MSWINDOWS}
Result:=nil;
try
OQ0COC0CQ0:=CFDataCreateWithBytesNoCopy(nil,@OCOCO0OCQ0[0],Length(OCOCO0OCQ0),kCFAllocatorNull);
Result:=SecCertificateCreateWithData(kCFAllocatorMalloc,OQ0COC0CQ0);
CFRelease(OQ0COC0CQ0);
if Result=nil then
raise EScError.Create(seNonCertificate);
if _Assigned(@SecCertificateCopyCommonName)then begin
OC0COC0CQ0:=nil;
OQ00OC0CQ0(SecCertificateCopyCommonName(Result,OC0COC0CQ0));
if OC0COC0CQ0<>nil then
CFRelease(OC0COC0CQ0);
end;
except
if Result<>nil then
CFRelease(Result);
raise;
end;
{$ENDIF}
end;
function TScCryptoAPIStorage.OQCCO0OCQ0(OCCCO0OCQ0:IntPtr):TBytes;
var
{$IFDEF MSWINDOWS}
O000O0OCQ0:PCCERT_CONTEXT;
{$ELSE}
O0OCOC0CQ0:CFDataRef;
{$ENDIF}
begin
{$IFDEF MSWINDOWS}
if OCCCO0OCQ0<>nil then begin
O000O0OCQ0:=PCCERT_CONTEXT(OCCCO0OCQ0);
SetLength(Result,O000O0OCQ0.cbCertEncoded);
Marshal.Copy(O000O0OCQ0.pbCertEncoded,Result,0,Length(Result));
end
else
SetLength(Result,0);
{$ELSE}
O0OCOC0CQ0:=SecCertificateCopyData(OCCCO0OCQ0);
if O0OCOC0CQ0<>nil then begin
SetLength(Result,CFDataGetLength(O0OCOC0CQ0));
Marshal.Copy(CFDataGetBytePtr(O0OCOC0CQ0),Result,0,Length(Result));
CFRelease(O0OCOC0CQ0);
end
else
SetLength(Result,0);
{$ENDIF}
end;
{$IFDEF MSWINDOWS}
class function TScCryptoAPIStorage.O00CQOOCQ0(OO0CQOOCQ0:IntPtr;OQ0CQOOCQ0:OOOOCOQOQ0):TBytes;
var
OC0CQOOCQ0:Cardinal;
O0OCQOOCQ0:IntPtr;
OOOCQOOCQ0:Cardinal;
begin
OC0CQOOCQ0:=CERT_HASH_PROP_ID;
case OQ0CQOOCQ0 of
OOC0COQOQ0:
OC0CQOOCQ0:=CERT_SHA1_HASH_PROP_ID;
OQ0OCOQOQ0:
OC0CQOOCQ0:=CERT_MD5_HASH_PROP_ID;
else
Assert(False);
end;
OOOCQOOCQ0:=32;
O0OCQOOCQ0:=Marshal.AllocHGlobal(OOOCQOOCQ0);
try
if(not CertGetCertificateContextProperty(OO0CQOOCQ0,OC0CQOOCQ0,O0OCQOOCQ0,OOOCQOOCQ0))
or(OOOCQOOCQ0<=0)or(OOOCQOOCQ0>32)then
raise EScError.CreateFmt(SErrorRetrievingHash,[O0CQ00OCQ0],seCSPError);
SetLength(Result,OOOCQOOCQ0);
Marshal.Copy(O0OCQOOCQ0,Result,0,OOOCQOOCQ0);
finally
Marshal.FreeHGlobal(O0OCQOOCQ0);
end;
end;
{$ENDIF}
function TScCryptoAPIStorage.OO00O0OCQ0(OQ00O0OCQ0:IntPtr):string;
var
{$IFDEF MSWINDOWS}
OC00O0OCQ0:Integer;
O0O0O0OCQ0:IntPtr;
OOO0O0OCQ0:{$IFDEF UNICODE}WideString{$ELSE}string{$ENDIF};
{$ELSE}
OOOCOC0CQ0:CFStringRef;
{$ENDIF}
begin
{$IFDEF MSWINDOWS}
OC00O0OCQ0:=CertGetNameString(OQ00O0OCQ0,CERT_NAME_SIMPLE_DISPLAY_TYPE,
CERT_NAME_DISABLE_IE4_UTF8_FLAG,nil,nil,0);
if OC00O0OCQ0<=0 then
raise EScError.Create(seErrorRequestingSubject);
SetLength(OOO0O0OCQ0,OC00O0OCQ0);
O0O0O0OCQ0:=O0QQ00OCQ0(OOO0O0OCQ0);
CertGetNameString(OQ00O0OCQ0,CERT_NAME_SIMPLE_DISPLAY_TYPE,
CERT_NAME_DISABLE_IE4_UTF8_FLAG,nil,O0O0O0OCQ0,OC00O0OCQ0);
Result:=OQQQ00OCQ0(O0O0O0OCQ0);
Marshal.FreeCoTaskMem(O0O0O0OCQ0);
{$ELSE}
OOOCOC0CQ0:=SecCertificateCopySubjectSummary(OQ00O0OCQ0);
try
Result:={$IFDEF FPC}string{$ENDIF}(OCCCOC0CQ0(OOOCOC0CQ0));
finally
if OOOCOC0CQ0<>nil then
CFRelease(OOOCOC0CQ0);
end;
{$ENDIF}
end;
{$IFDEF MSWINDOWS}
class function TScCryptoAPIStorage.OQOCQOOCQ0(OCOCQOOCQ0:HCRYPTPROV;O0QCQOOCQ0:IntPtr=nil):HCRYPTKEY;
var
OOQCQOOCQ0:PCERT_PUBLIC_KEY_INFO;
begin
Result:=0;
if not CryptGetUserKey(OCOCQOOCQ0,AT_KEYEXCHANGE,Result)then begin
if HRESULT(GetLastError)=NTE_NO_KEY then begin
if not CryptGetUserKey(OCOCQOOCQ0,AT_SIGNATURE,Result)then begin
if(HRESULT(GetLastError)=NTE_NO_KEY)and(O0QCQOOCQ0<>nil)then begin
OOQCQOOCQ0:=@PCCERT_CONTEXT(O0QCQOOCQ0).pCertInfo.SubjectPublicKeyInfo;
Win32Check(CryptImportPublicKeyInfoEx(OCOCQOOCQ0,O00Q00OCQ0,OOQCQOOCQ0,CALG_RSA_SIGN,0,nil,Result));
end
else
RaiseLastWin32Error;
end;
end
else
RaiseLastWin32Error;
end;
end;
{$ELSE}
class function TScCryptoAPIStorage.O0OOQ0OCQ0(const OOOOQ0OCQ0:TBytes;
OQOOQ0OCQ0:boolean;OCOOQ0OCQ0:SecKeychainRef;O0QOQ0OCQ0:IntPtr):IntPtr;
var
OOQOQ0OCQ0:CFDataRef;
OQQOQ0OCQ0:SecExternalFormat;
OCQOQ0OCQ0:SecExternalItemType;
O0COQ0OCQ0:CFArrayRef;
OOCOQ0OCQ0:CFTypeRef;
OQCOQ0OCQ0:array[0..3]of pointer;
OCCOQ0OCQ0:array[0..3]of pointer;
O00QOC0CQ0,OO0QOC0CQ0:CFDictionaryRef;
OQ0QOC0CQ0:OSStatus;
begin
if Length(OOOOQ0OCQ0)=0 then
raise EScError.Create(seBadKeyData);
Result:=nil;
OOQOQ0OCQ0:=CFDataCreateWithBytesNoCopy(nil,@OOOOQ0OCQ0[0],Length(OOOOQ0OCQ0),kCFAllocatorNull);
try
if _Assigned(@SecKeychainItemImport)then begin
O0COQ0OCQ0:=nil;
try
OQQOQ0OCQ0:=kSecFormatUnknown;
if OQOOQ0OCQ0 then
OCQOQ0OCQ0:=kSecItemTypePrivateKey
else
OCQOQ0OCQ0:=kSecItemTypePublicKey;
OQ00OC0CQ0(SecKeychainItemImport(OOQOQ0OCQ0,nil,@OQQOQ0OCQ0,@OCQOQ0OCQ0,0,nil,OCOOQ0OCQ0,O0COQ0OCQ0));
if CFArrayGetCount(O0COQ0OCQ0)<1 then
raise EScError.Create(seBadKeyData);
OOCOQ0OCQ0:=CFArrayGetValueAtIndex(O0COQ0OCQ0,0);
if(OOCOQ0OCQ0=nil)or(CFGetTypeID(OOCOQ0OCQ0)<>SecKeyGetTypeID)then
raise EScError.Create(seBadKeyData);
Result:=CFRetain(OOCOQ0OCQ0);
finally
if O0COQ0OCQ0<>nil then
CFRelease(O0COQ0OCQ0);
end;
end
else begin
OQCOQ0OCQ0[0]:=kSecValueData;
OCCOQ0OCQ0[0]:=OOQOQ0OCQ0;
OQCOQ0OCQ0[1]:=kSecAttrKeyClass;
OCCOQ0OCQ0[1]:=kSecAttrKeyClassPrivate;
OO0QOC0CQ0:=CFDictionaryCreate(nil,@OQCOQ0OCQ0,@OCCOQ0OCQ0,2,nil,nil);
OQCOQ0OCQ0[0]:=kSecClass;
OCCOQ0OCQ0[0]:=kSecClassKey;
OQCOQ0OCQ0[1]:=kSecValueRef;
OCCOQ0OCQ0[1]:=O0QOQ0OCQ0;
O00QOC0CQ0:=CFDictionaryCreate(nil,@OQCOQ0OCQ0,@OCCOQ0OCQ0,2,nil,nil);
try
OQ0QOC0CQ0:=SecItemUpdate(O00QOC0CQ0,OO0QOC0CQ0);
if OQ0QOC0CQ0<>errSecDuplicateItem then
OQ00OC0CQ0(OQ0QOC0CQ0);
OQCOQ0OCQ0[0]:=kSecClass;
OCCOQ0OCQ0[0]:=kSecClassKey;
OQCOQ0OCQ0[1]:=kSecValueRef;
OCCOQ0OCQ0[1]:=O0QOQ0OCQ0;
OQCOQ0OCQ0[2]:=kSecAttrKeyClass;
OCCOQ0OCQ0[2]:=kSecAttrKeyClassPrivate;
OQCOQ0OCQ0[3]:=kSecReturnRef;
OCCOQ0OCQ0[3]:=kCFBooleanTrue;
CFRelease(O00QOC0CQ0);
O00QOC0CQ0:=CFDictionaryCreate(nil,@OQCOQ0OCQ0,@OCCOQ0OCQ0,4,nil,nil);
OQ00OC0CQ0(SecItemCopyMatching(O00QOC0CQ0,Result));
finally
CFRelease(OO0QOC0CQ0);
CFRelease(O00QOC0CQ0);
end;
end;
finally
CFRelease(OOQOQ0OCQ0);
end;
end;
{$ENDIF}
function TScCryptoAPIStorage.OC00QOOCQ0(O0O0QOOCQ0:IntPtr;
out OOO0QOOCQ0:OCQCQ00OQ0;out OQO0QOOCQ0:OOQQQOQOQ0;
out OCO0QOOCQ0:boolean):TBytes;
var
{$IFDEF MSWINDOWS}
O0Q0QOOCQ0:HCRYPTPROV;
OOQ0QOOCQ0:Cardinal;
OQQ0QOOCQ0:BOOL;
OCQ0QOOCQ0:HCRYPTKEY;
O0C0QOOCQ0:PCERT_PUBLIC_KEY_INFO;
OOC0QOOCQ0:Cardinal;
OQC0QOOCQ0:Boolean;
OCC0QOOCQ0:Cardinal;
O00OQOOCQ0:TBytes;
{$ELSE}
OCOQOC0CQ0:OSStatus;
O0QQOC0CQ0:SecIdentityRef;
OOQQOC0CQ0:SecKeyRef;
OQQQOC0CQ0:SecPolicyRef;
OCQQOC0CQ0:SecTrustRef;
{$ENDIF}
begin
{$IFDEF MSWINDOWS}
OOO0QOOCQ0:=OQQCQ00OQ0;
OCQ0QOOCQ0:=0;
OQC0QOOCQ0:=CryptAcquireCertificatePrivateKey(O0O0QOOCQ0,
CRYPT_ACQUIRE_COMPARE_KEY_FLAG or CRYPT_ACQUIRE_SILENT_FLAG,nil,
O0Q0QOOCQ0,OOQ0QOOCQ0,OQQ0QOOCQ0);
try
if OQC0QOOCQ0 then begin
Win32Check(CryptGetUserKey(O0Q0QOOCQ0,OOQ0QOOCQ0,OCQ0QOOCQ0));
OCC0QOOCQ0:=PRIVATEKEYBLOB;
if not CryptExportKey(OCQ0QOOCQ0,0,OCC0QOOCQ0,0,nil,OOC0QOOCQ0)then begin
if HRESULT(GetLastError)=NTE_BAD_KEY_STATE then begin
OCC0QOOCQ0:=PUBLICKEYBLOB;
Win32Check(CryptExportKey(OCQ0QOOCQ0,0,OCC0QOOCQ0,0,nil,OOC0QOOCQ0));
end
else
RaiseLastWin32Error;
end;
end
else begin
O0C0QOOCQ0:=@PCCERT_CONTEXT(O0O0QOOCQ0).pCertInfo.SubjectPublicKeyInfo;
SetLength(O00OQOOCQ0,0);
O00OQOOCQ0:=O00CQOOCQ0(O0O0QOOCQ0,OOC0COQOQ0);
O0Q0QOOCQ0:=O00000OCQ0(O00QOCOOQ0(O00OQOOCQ0,''),'',PROV_RSA_FULL,True);
Win32Check(O0Q0QOOCQ0<>0);
Win32Check(CryptImportPublicKeyInfoEx(O0Q0QOOCQ0,O00Q00OCQ0,O0C0QOOCQ0,CALG_RSA_SIGN,0,nil,OCQ0QOOCQ0));
OCC0QOOCQ0:=PUBLICKEYBLOB;
Win32Check(CryptExportKey(OCQ0QOOCQ0,0,OCC0QOOCQ0,0,nil,OOC0QOOCQ0));
end;
SetLength(Result,OOC0QOOCQ0);
Win32Check(CryptExportKey(OCQ0QOOCQ0,0,OCC0QOOCQ0,0,Windows.PBYTE(Result),OOC0QOOCQ0));
finally
if OCQ0QOOCQ0<>0 then
CryptDestroyKey(OCQ0QOOCQ0);
if O0Q0QOOCQ0<>0 then
CryptReleaseContext(O0Q0QOOCQ0,0);
end;
{$ELSE MSWINDOWS}
OOQQOC0CQ0:=nil;
O0QQOC0CQ0:=nil;
OQQQOC0CQ0:=nil;
OCQQOC0CQ0:=nil;
try
if _Assigned(@SecIdentityCreateWithCertificate)then begin
OCOQOC0CQ0:=SecIdentityCreateWithCertificate(nil,O0O0QOOCQ0,O0QQOC0CQ0);
if OCOQOC0CQ0=0 then
OQ00OC0CQ0(SecIdentityCopyPrivateKey(O0QQOC0CQ0,OOQQOC0CQ0))
else
OQ00OC0CQ0(SecCertificateCopyPublicKey(O0O0QOOCQ0,OOQQOC0CQ0));
end
else begin
OQQQOC0CQ0:=SecPolicyCreateBasicX509;
OQ00OC0CQ0(SecTrustCreateWithCertificates(O0O0QOOCQ0,OQQQOC0CQ0,OCQQOC0CQ0));
OOQQOC0CQ0:=SecTrustCopyPublicKey(OCQQOC0CQ0);
if OOQQOC0CQ0=nil then
OQ00OC0CQ0(errSecItemNotFound);
end;
Result:=OC00Q0OCQ0(OOQQOC0CQ0,OOO0QOOCQ0,OQO0QOOCQ0,OCO0QOOCQ0);
finally
if OOQQOC0CQ0<>nil then
CFRelease(OOQQOC0CQ0);
if O0QQOC0CQ0<>nil then
CFRelease(O0QQOC0CQ0);
if OCQQOC0CQ0<>nil then
CFRelease(OCQQOC0CQ0);
if OQQQOC0CQ0<>nil then
CFRelease(OQQQOC0CQ0);
end;
{$ENDIF}
end;
initialization
{$IFDEF MSWINDOWS}
OCCC00OCQ0:=TCriticalSection.Create;
OOCC00OCQ0:=nil;
{$ENDIF}
finalization
{$IFDEF MSWINDOWS}
OOCC00OCQ0.Free;
OCCC00OCQ0.Free;
{$ENDIF}
{$ENDIF ANDROID}
{$ENDIF LINUX_BSD}
{$ENDIF LINUX}
end.
