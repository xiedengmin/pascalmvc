//////////////////////////////////////////////////
//  SecureBridge Components
//  Copyright © 2007-2021 Devart. All right reserved.
//////////////////////////////////////////////////
{$I Tds.inc}
unit TdsLayersUni;
interface
uses
{$IFDEF MSWINDOWS}
Windows,
{$ENDIF}
Classes,SysUtils,SyncObjs,
CLRClasses,CRTypes,CRRNG,
CRCryptoTransformIntf,CRHash,CRHashAlgorithm,CRSymmetricAlgorithm,CRHMAC,
{$IFNDEF UNIDACPRO}
TdsUtils,TdsSSLTypes,TdsMD5SHA1CSP,TdsBridge,
TdsCipherSuites,TdsSSLMessages,TdsSSLConsts,TdsSSLExtensions,
TdsCertificateExts,TdsReceiveBuffer,TdsPipe;
{$ELSE}
TdsUtilsUni,TdsSSLTypesUni,TdsMD5SHA1CSPUni,TdsBridgeUni,
TdsCipherSuitesUni,TdsSSLMessagesUni,TdsSSLConstsUni,TdsSSLExtensionsUni,
TdsCertificateExtsUni,TdsReceiveBufferUni,TdsPipeUni;
{$ENDIF}
type
OCCCC0O0Q0=class;
OOQQOC00Q0=class;
OQOO0C00Q0=class of OOQQOC00Q0;
OCOO0C00Q0=class;
OQ0COQ00Q0=procedure(const OC0COQ00Q0:TValueArr;O0OCOQ00Q0,OOOCOQ00Q0:integer)of object;
OQOCOQ00Q0=function(const OCOCOQ00Q0:TValueArr;O0QCOQ00Q0,OOQCOQ00Q0:integer):integer of object;
OQQCOQ00Q0=class(EScError)
end;
OCQCOQ00Q0=class
protected
O0CCOQ00Q0:boolean;
OOCCOQ00Q0:TCriticalSection;
OQCCOQ00Q0:Exception;
OCCCOQ00Q0:O0QOQ0Q0Q0;
O000OQ00Q0:OC00C0Q0Q0;
OO00OQ00Q0:OCCCC0O0Q0;
OQ00OQ00Q0:OQOOOQO0Q0;
OC00OQ00Q0:OQ0COQ00Q0;
O0O0OQ00Q0:OQOCOQ00Q0;
OOO0OQ00Q0:TNotifyEvent;
procedure OQO0OQ00Q0;
procedure OCO0OQ00Q0(O0Q0OQ00Q0:integer=0);
function OQQ0OQ00Q0:O0OQOOQ0Q0;
function O0C0OQ00Q0:O0OQOOQ0Q0;
procedure OOC0OQ00Q0;
procedure OO0OOQ00Q0(OQ0OOQ00Q0:Exception);
function OC0OOQ00Q0:integer;
function O0OOOQ00Q0:TScCertificate;
function OOOOOQ00Q0:OQCCQOQ0Q0;
function OQOOOQ00Q0:TNotifyEvent;
procedure OCOOOQ00Q0(O0QOOQ00Q0:TNotifyEvent);
procedure OOQOOQ00Q0;
public
constructor Create(OCQ0Q0O0Q0:O0QOQ0Q0Q0;O0C0Q0O0Q0:OQOO0C00Q0);
destructor Destroy;override;
procedure OOCOOQ00Q0;virtual;
procedure OQCOOQ00Q0;virtual;
procedure OCCOOQ00Q0;
function O00Q0Q00Q0(const OO0Q0Q00Q0:TValueArr;OQ0Q0Q00Q0,OC0Q0Q00Q0:integer):integer;
function O0OQ0Q00Q0(const OOOQ0Q00Q0:TValueArr;OQOQ0Q00Q0,OCOQ0Q00Q0:integer):integer;
function OOQQ0Q00Q0(OQQQ0Q00Q0:integer;OCQQ0Q00Q0:cardinal):boolean;
procedure O0CQ0Q00Q0;
procedure OOCQ0Q00Q0;
function OQCQ0Q00Q0:Exception;
property OCCQ0Q00Q0:integer read OC0OOQ00Q0;
property O00C0Q00Q0:O0QOQ0Q0Q0 read OCCCOQ00Q0;
property OO0C0Q00Q0:TScCertificate read O0OOOQ00Q0;
property OQ0C0Q00Q0:OQCCQOQ0Q0 read OOOOOQ00Q0;
property OC0C0Q00Q0:OQ0COQ00Q0 read OC00OQ00Q0 write OC00OQ00Q0;
property O0OC0Q00Q0:OQOCOQ00Q0 read O0O0OQ00Q0 write O0O0OQ00Q0;
property OOOC0Q00Q0:TNotifyEvent read OOO0OQ00Q0 write OOO0OQ00Q0;
property OQOC0Q00Q0:TNotifyEvent read OQOOOQ00Q0 write OCOOOQ00Q0;
end;
OCCCC0O0Q0=class
private
O000C0O0Q0:O0QOQ0Q0Q0;
OO00C0O0Q0:IScRandom;
OQ00C0O0Q0:OCQCQQO0Q0;
OC00C0O0Q0:O00C00O0Q0;
O0O0C0O0Q0:OQ0000O0Q0;
OOO0C0O0Q0:TSymmetricAlgorithm;
OQO0C0O0Q0:TSymmetricAlgorithm;
OCO0C0O0Q0,O0Q0C0O0Q0:TBytes;
OOQ0C0O0Q0,OQQ0C0O0Q0:TBytes;
OCQ0C0O0Q0:TBytes;
O0C0C0O0Q0:TKeyedHashAlgorithm;
OOC0C0O0Q0:TKeyedHashAlgorithm;
OQC0C0O0Q0:OCQQC0QOQ0;
OCC0C0O0Q0:OCQQC0QOQ0;
O00OC0O0Q0:OQOO0C00Q0;
OO0OC0O0Q0:OOQQOC00Q0;
OQ0OC0O0Q0:OQ0OC0Q0Q0;
OC0OC0O0Q0:TCriticalSection;
O0OOC0O0Q0:TCriticalSection;
OOOOC0O0Q0:TEvent;
OQOOC0O0Q0:integer;
OCOOC0O0Q0:integer;
O0QOC0O0Q0:Int64;
OOQOC0O0Q0:Int64;
function OQQOC0O0Q0:boolean;
procedure OCQOC0O0Q0(O0COC0O0Q0:boolean);
class procedure OOCOC0O0Q0(var OQCOC0O0Q0:TBytes);
class function O00QQ0O0Q0(const OO0QQ0O0Q0:Int64):TBytes;
procedure OQ0QQ0O0Q0(const OC0QQ0O0Q0:TValueArr;O0OQQ0O0Q0:integer);
procedure OQ0CQ0O0Q0(OC0CQ0O0Q0:OC00C0Q0Q0);
function O000Q0O0Q0(OO00Q0O0Q0:OC00C0Q0Q0;OQ00Q0O0Q0:OQOOOQO0Q0;out OC00Q0O0Q0:integer):O0OQOOQ0Q0;
procedure OQO0Q0O0Q0;
procedure OCO0Q0O0Q0;
procedure O0Q0Q0O0Q0;
procedure OOQ0Q0O0Q0;
public
constructor Create(OCQ0Q0O0Q0:O0QOQ0Q0Q0;O0C0Q0O0Q0:OQOO0C00Q0);
destructor Destroy;override;
procedure OCC0Q0O0Q0;
procedure O00OQ0O0Q0(const OO0OQ0O0Q0:TSymmetricAlgorithm;
const OQ0OQ0O0Q0:TBytes;const OC0OQ0O0Q0:TKeyedHashAlgorithm);
procedure O0OOQ0O0Q0(const OOOOQ0O0Q0:TSymmetricAlgorithm;
const OQOOQ0O0Q0:TBytes;const OCOOQ0O0Q0:TKeyedHashAlgorithm);
procedure O0QOQ0O0Q0(OOQOQ0O0Q0:OCQC00Q0Q0);
procedure OQQOQ0O0Q0(const OCQOQ0O0Q0:TValueArr;O0COQ0O0Q0:integer;OOCOQ0O0Q0:O0OQ0OQ0Q0);
procedure O00QOC00Q0;
procedure OO0QOC00Q0;
procedure OQ0QOC00Q0;
property OC0QOC00Q0:boolean read OQQOC0O0Q0 write OCQOC0O0Q0;
property O0OQOC00Q0:TEvent read OOOOC0O0Q0;
property OOOQOC00Q0:integer read OCOOC0O0Q0 write OCOOC0O0Q0;
property OQOQOC00Q0:OOQQOC00Q0 read OO0OC0O0Q0;
property OCOQOC00Q0:TSymmetricAlgorithm read OOO0C0O0Q0;
property O0QQOC00Q0:TSymmetricAlgorithm read OQO0C0O0Q0;
end;
OQQC0Q00Q0=(OCOC0Q00Q0,O0QC0Q00Q0,OOQC0Q00Q0);
OOQQOC00Q0=class
private
OQQQOC00Q0:OCQ0O0Q0Q0;
OCQQOC00Q0:TCriticalSection;
O0CQOC00Q0:TBytes;
OOCQOC00Q0:integer;
OQCQOC00Q0:boolean;
OCCQOC00Q0:boolean;
procedure O00COC00Q0(O0COC0O0Q0:boolean);
function OO0COC00Q0:string;
procedure OC0COC00Q0(O0OCOC00Q0:TCRList;out OOOCOC00Q0:TScCertificateStatusSet);
protected
OQOCOC00Q0:IScRandom;
OCOCOC00Q0:OCOO0C00Q0;
O0QCOC00Q0:O0QOQ0Q0Q0;
{$IFDEF AUTOREFCOUNT}[weak]{$ENDIF}
OOQCOC00Q0:OCCCC0O0Q0;
OQQCOC00Q0:OCQC00Q0Q0;
OCQCOC00Q0:OQQC0OQ0Q0;
O0CCOC00Q0:TBytes;
OOCCOC00Q0:OQCCQOQ0Q0;
OQCCOC00Q0:TCRList;
OCCCOC00Q0:TScCertificate;
O000OC00Q0:boolean;
OO00OC00Q0:boolean;
OQ00OC00Q0:boolean;
OC00OC00Q0:boolean;
O0O0OC00Q0:OCCQCOQ0Q0;
OOO0OC00Q0:boolean;
class function OQO0OC00Q0:TBytes;
procedure O0Q0OC00Q0;virtual;
procedure OOQ0OC00Q0(const OQQ0OC00Q0:OOCCCQQ0Q0);
procedure OCQ0OC00Q0(O0C0OC00Q0:OCOO0C00Q0);
procedure OOC0OC00Q0(OQC0OC00Q0:OQQC0Q00Q0);
procedure O00OOC00Q0(OO0OOC00Q0:OCQC00Q0Q0);
procedure OQQOOC00Q0(OCQOOC00Q0:OCQC00Q0Q0);
function O0COOC00Q0(OOCOOC00Q0:OC00C0Q0Q0):O0OQOOQ0Q0;
function O00Q0C00Q0(const OO0Q0C00Q0:TBytes;OQ0Q0C00Q0,OC0Q0C00Q0:integer):OCQC00Q0Q0;
procedure OOOQ0C00Q0;
procedure OQOQ0C00Q0;virtual;
function OCOQ0C00Q0:boolean;
function O0QQ0C00Q0:TScCertificate;
procedure OOQQ0C00Q0(OQQQ0C00Q0:TCRList);
procedure OCQQ0C00Q0(O0CQ0C00Q0:TScCertificate);
procedure OOCQ0C00Q0;virtual;abstract;
procedure OQCQ0C00Q0;virtual;abstract;
procedure OCCQ0C00Q0;
procedure O00C0C00Q0(OO0C0C00Q0:OCCQCOQ0Q0);
procedure OQ0C0C00Q0(OC0C0C00Q0:OCQC00Q0Q0);
procedure OOOC0C00Q0;
procedure OCOC0C00Q0(O0QC0C00Q0:OCQC00Q0Q0);virtual;abstract;
procedure OOQC0C00Q0(OQQC0C00Q0:OQQC0OQ0Q0);virtual;abstract;
function OCQC0C00Q0(O0CC0C00Q0:OC00C0Q0Q0):O0OQOOQ0Q0;
procedure OC000C00Q0;
function OOO00C00Q0(OQO00C00Q0:OC00C0Q0Q0):O0OQOOQ0Q0;
procedure OCO00C00Q0;
public
constructor Create(OQQ00C00Q0:OCCCC0O0Q0;OCQ0Q0O0Q0:O0QOQ0Q0Q0);
destructor Destroy;override;
function O0C00C00Q0:OOCCCQQ0Q0;
procedure OOC00C00Q0(OQC00C00Q0:OQCO0OQ0Q0;OCC00C00Q0:TScErrorCode);
property OQ0O0C00Q0:O0QOQ0Q0Q0 read O0QCOC00Q0;
property OC0O0C00Q0:OQCCQOQ0Q0 read OOCCOC00Q0;
property O0OO0C00Q0:boolean read OCCQOC00Q0 write O00COC00Q0;
property OOOO0C00Q0:TBytes read O0CCOC00Q0;
end;
OCOO0C00Q0=class
protected
{$IFDEF AUTOREFCOUNT}[weak]{$ENDIF}
O0QO0C00Q0:OOQQOC00Q0;
OOQO0C00Q0:OCOQOOQ0Q0;
OQQO0C00Q0:TBytes;
OCQO0C00Q0:integer;
O0CO0C00Q0:integer;
OOCO0C00Q0:TBytes;
OQCO0C00Q0:TBytes;
OCCO0C00Q0:THashAlgorithm;
function O00QCC00Q0:OC0QQQQ0Q0;
procedure OO0QCC00Q0(const OQ0QCC00Q0:TBytes);
procedure OC0QCC00Q0(out O0OQCC00Q0,OOOQCC00Q0:TBytes);
procedure OCOQCC00Q0(const O0QQCC00Q0:TBytes;out OOQQCC00Q0:TBytes);
function OQQQCC00Q0(OCQQCC00Q0:OQCCQOQ0Q0):OQQ0Q0Q0Q0;
function O0OCCC00Q0(OOOCCC00Q0:O00QQOQ0Q0;OQOCCC00Q0:OQCCQOQ0Q0):boolean;
public
constructor Create(OC00CC00Q0:OOQQOC00Q0;O0O0CC00Q0:OCOQOOQ0Q0);overload;
constructor Create(OOO0CC00Q0:OCOO0C00Q0;O0O0CC00Q0:OCOQOOQ0Q0);overload;
destructor Destroy;override;
procedure OCO0CC00Q0;
procedure O0Q0CC00Q0(OOQ0CC00Q0:OCQC00Q0Q0);overload;
procedure O0Q0CC00Q0(const OQQ0CC00Q0:TBytes;OCQ0CC00Q0,O0C0CC00Q0:integer);overload;
function OQC0CC00Q0:TBytes;
procedure OCC0CC00Q0;virtual;
function O00OCC00Q0(const OO0OCC00Q0:TCipherDefinition;
const OQ0OCC00Q0:OQQC0Q00Q0):OCQ0O0Q0Q0;virtual;abstract;
procedure OC0OCC00Q0;virtual;
procedure O0OOCC00Q0(const OOOOCC00Q0:TBytes);virtual;
procedure OQOOCC00Q0(const OCOOCC00Q0:TBytes);virtual;
procedure O0QOCC00Q0;virtual;
procedure OOQOCC00Q0;virtual;
procedure OQQOCC00Q0;virtual;
procedure OCQOCC00Q0;virtual;
procedure O0COCC00Q0(const OOCOCC00Q0:TBytes);overload;
procedure O0COCC00Q0(const OOCOCC00Q0,OQCOCC00Q0:TBytes;const OCCOCC00Q0:array of byte);overload;virtual;abstract;
procedure O00QQC00Q0(OO0QQC00Q0:OCQC00Q0Q0;OQ0QQC00Q0:OC0Q00OOQ0);virtual;
function OCOQQC00Q0(O0QQQC00Q0:OCQC00Q0Q0):OC0Q00OOQ0;virtual;
procedure OQCQQC00Q0(OCCQQC00Q0:OCQC00Q0Q0);virtual;
procedure O00CQC00Q0(OO0CQC00Q0:OCQC00Q0Q0);virtual;
procedure OQ0CQC00Q0(OC0CQC00Q0:OCQC00Q0Q0;O0OCQC00Q0:TCRList);virtual;
procedure OOQCQC00Q0(OQQCQC00Q0:OCQC00Q0Q0;OCQCQC00Q0:TCRList);virtual;
procedure OCCCQC00Q0(O000QC00Q0:OCQC00Q0Q0;OO00QC00Q0:TScCertificate);virtual;
procedure O0O0QC00Q0(OOO0QC00Q0:OCQC00Q0Q0;OQO0QC00Q0:TScCertificate);virtual;
procedure OOQ0QC00Q0(OQQ0QC00Q0:OCQC00Q0Q0;
OCQ0QC00Q0:TScCertificate);virtual;
procedure OCC0QC00Q0(O00OQC00Q0:OCQC00Q0Q0;OO0OQC00Q0:TScCertificate);virtual;
procedure OOOOQC00Q0(OQOOQC00Q0:OCQC00Q0Q0);virtual;abstract;
procedure OCOOQC00Q0(const O0QOQC00Q0:TBytes;OOQOQC00Q0,OQQOQC00Q0:integer);virtual;abstract;
procedure OCQOQC00Q0(O0COQC00Q0:OCQC00Q0Q0;OOCOQC00Q0:OQCCQOQ0Q0);virtual;
procedure OCCOQC00Q0(O00QOQ00Q0:OCQC00Q0Q0;OO0QOQ00Q0:OQCCQOQ0Q0);virtual;
procedure O0OQOQ00Q0(OOOQOQ00Q0:OCQC00Q0Q0;
OQOQOQ00Q0:OCQOC0Q0Q0;OCOQOQ00Q0:OQCCQOQ0Q0;
out O0QQOQ00Q0:integer);virtual;
procedure OCQQOQ00Q0(O0CQOQ00Q0:OCQC00Q0Q0;const OOCQOQ00Q0,OQCQOQ00Q0:TBytes);virtual;
function OCCQOQ00Q0:THashAlgorithm;virtual;abstract;
function O00COQ00Q0:OOCCCQQ0Q0;virtual;abstract;
property OO0COQ00Q0:TBytes read OQCO0C00Q0 write OO0QCC00Q0;
end;
OCQC0Q00Q0=class
public
class function O0CC0Q00Q0(const OOCC0Q00Q0,OQCC0Q00Q0:string):boolean;
class function OQ000Q00Q0(OC000Q00Q0:TCRList;O0O00Q00Q0:O0QOQ0Q0Q0):TScCertificateStatusSet;
end;
implementation
{$UNDEF TRIAL}
{$UNDEF TRIALCALL}
uses
Types,
CRDECUtil,CRFunctions,CRCipher,
{$IFNDEF UNIDACPRO}
TdsCryptoAPIStorage,
TdsAlgorithmSupport,TdsCertificateConsts,
TdsSSL3HandshakeLayer,TdsTLS1HandshakeLayer,TdsTLS13HandshakeLayer;
{$ELSE}
TdsCryptoAPIStorageUni,
TdsAlgorithmSupportUni,TdsCertificateConstsUni,
TdsSSL3HandshakeLayerUni,TdsTLS1HandshakeLayerUni,TdsTLS13HandshakeLayerUni;
{$ENDIF}
{$UNDEF USE_CRYPTOAPI_STORAGE}
{$IFNDEF ANDROID}
{$IFNDEF LINUX}
{$IFNDEF LINUX_BSD}
{$DEFINE USE_CRYPTOAPI_STORAGE}
{$ENDIF}
{$ENDIF}
{$ENDIF}
var
{$IFDEF USE_CRYPTOAPI_STORAGE}
OC0O0Q00Q0,O0OO0Q00Q0:TScCryptoAPIStorage;
{$ELSE}
OC0O0Q00Q0,O0OO0Q00Q0:OO0Q0CQ0Q0;
{$ENDIF}
var
OOOO0Q00Q0,OQOO0Q00Q0:TBytes;
OCOO0Q00Q0,O0QO0Q00Q0:TBytes;
OOQO0Q00Q0:cardinal=0;
OQQO0Q00Q0:TCriticalSection;
const
OCQO0Q00Q0=8;
O0CO0Q00Q0=16777216;
const
OOCO0Q00Q0:array[0..12]of byte=
(109,97,115,116,101,114,32,115,101,99,114,101,116);
OQCO0Q00Q0:array[0..21]of byte=
(101,120,116,101,110,100,101,100,32,109,97,115,116,101,114,32,115,101,99,114,101,116);
constructor OCQCOQ00Q0.Create(OCQ0Q0O0Q0:O0QOQ0Q0Q0;O0C0Q0O0Q0:OQOO0C00Q0);
begin
inherited Create;
OCCCOQ00Q0:=OCQ0Q0O0Q0;
O000OQ00Q0:=OC00C0Q0Q0.Create;
OO00OQ00Q0:=OCCCC0O0Q0.Create(OCQ0Q0O0Q0,O0C0Q0O0Q0);
OQ00OQ00Q0:=OQOOOQO0Q0.Create(OOQC00Q0Q0);
OOCCOQ00Q0:=TCriticalSection.Create;
OQCCOQ00Q0:=nil;
end;
destructor OCQCOQ00Q0.Destroy;
begin
try
if not OCCCOQ00Q0.OOQOOCO0Q0 then
OCCOOQ00Q0;
except
end;
OQCCOQ00Q0.Free;
OOCCOQ00Q0.Free;
OQ00OQ00Q0.Free;
OO00OQ00Q0.Free;
O000OQ00Q0.Free;
inherited;
end;
procedure OCQCOQ00Q0.OOQOOQ00Q0;
var
OQQOOQ00Q0:Exception;
begin
OOCCOQ00Q0.Enter;
try
if OQCCOQ00Q0<>nil then begin
OQQOOQ00Q0:=OQCCOQ00Q0;
OQCCOQ00Q0:=nil;
raise OQQOOQ00Q0;
end;
finally
OOCCOQ00Q0.Leave;
end;
end;
procedure OCQCOQ00Q0.OQCOOQ00Q0;
begin
OO00OQ00Q0.OCC0Q0O0Q0;
OOCOOQ00Q0;
end;
procedure OCQCOQ00Q0.OCCOOQ00Q0;
begin
OO0OOQ00Q0(nil);
if Assigned(OOOC0Q00Q0)then
OOOC0Q00Q0(Self);
end;
procedure OCQCOQ00Q0.OOCOOQ00Q0;
begin
if not(Assigned(OC00OQ00Q0)and Assigned(O0O0OQ00Q0))then
raise EScError.Create(seInvalidInputArgs);
if OCCCOQ00Q0.OCO0OCO0Q0=[]then
raise EScError.Create(seNormalConnectionIsNotSupported);
if Length(OCCCOQ00Q0.OOO0OCO0Q0)=0 then
raise EScError.Create(seInvalidCipherAlgorithm);
if(OCCCOQ00Q0.O0O0OCO0Q0=OQOQOOQ0Q0)and not Assigned(OCCCOQ00Q0.O0Q0OCO0Q0)then
raise EScError.Create(seServerCertificateNotSpecified);
if(OCCCOQ00Q0.O0O0OCO0Q0=OOOQOOQ0Q0)or not OCCCOQ00Q0.OOCOOCO0Q0 then
OQO0OQ00Q0;
end;
procedure OCQCOQ00Q0.OQO0OQ00Q0;
begin
if OCCCOQ00Q0.O0O0OCO0Q0=OOOQOOQ0Q0 then begin
OO00OQ00Q0.O00QOC00Q0;
OOC0OQ00Q0;
end;
while OO00OQ00Q0.OC0QOC00Q0 do begin
OCO0OQ00Q0;
O0C0OQ00Q0;
end;
end;
procedure OCQCOQ00Q0.OCO0OQ00Q0(O0Q0OQ00Q0:integer=0);
var
OOQ0OQ00Q0:integer;
begin
if O0Q0OQ00Q0>0 then begin
O000OQ00Q0.OOC0C0Q0Q0(O0Q0OQ00Q0);
while O0Q0OQ00Q0>0 do begin
OOQ0OQ00Q0:=O0O0OQ00Q0(TValueArr(O000OQ00Q0.OQO0C0Q0Q0),O000OQ00Q0.OOQ0C0Q0Q0,O0Q0OQ00Q0);
if OOQ0OQ00Q0<=0 then
raise EScError.Create(seConnectionClosed);
O000OQ00Q0.OOQ0C0Q0Q0:=O000OQ00Q0.OOQ0C0Q0Q0+OOQ0OQ00Q0;
Dec(O0Q0OQ00Q0,OOQ0OQ00Q0);
end;
end
else
if O000OQ00Q0.OOQ0C0Q0Q0<=O000OQ00Q0.O0Q0C0Q0Q0 then begin
O000OQ00Q0.OOC0C0Q0Q0(OQQC00Q0Q0*2);
OOQ0OQ00Q0:=O0O0OQ00Q0(TValueArr(O000OQ00Q0.OQO0C0Q0Q0),O000OQ00Q0.OOQ0C0Q0Q0,OQQC00Q0Q0*2);
if OOQ0OQ00Q0<=0 then
raise EScError.Create(seConnectionClosed);
O000OQ00Q0.OOQ0C0Q0Q0:=O000OQ00Q0.OOQ0C0Q0Q0+OOQ0OQ00Q0;
end;
end;
function OCQCOQ00Q0.OQQ0OQ00Q0:O0OQOOQ0Q0;
var
OCQ0OQ00Q0:integer;
begin
Result:=OO00OQ00Q0.O000Q0O0Q0(O000OQ00Q0,OQ00OQ00Q0,OCQ0OQ00Q0);
while OCQ0OQ00Q0>0 do begin
OCO0OQ00Q0(OCQ0OQ00Q0);
Result:=OO00OQ00Q0.O000Q0O0Q0(O000OQ00Q0,OQ00OQ00Q0,OCQ0OQ00Q0);
end;
end;
function OCQCOQ00Q0.O0C0OQ00Q0:O0OQOOQ0Q0;
begin
try
Result:=OQQ0OQ00Q0;
finally
OOC0OQ00Q0;
end;
end;
function OCQCOQ00Q0.O00Q0Q00Q0(const OO0Q0Q00Q0:TValueArr;OQ0Q0Q00Q0,OC0Q0Q00Q0:integer):integer;
begin
OOQOOQ00Q0;
if O0CCOQ00Q0 then
raise EScError.Create(seConnectionClosed);
if OO00OQ00Q0.OC0QOC00Q0 then begin
if(OO00OQ00Q0.O0OQOC00Q0.WaitFor(cardinal(OCCCOQ00Q0.OOOOOCO0Q0))<>wrSignaled)or O0CCOQ00Q0 then
raise EScError.Create(seTimeoutSession);
end;
OO00OQ00Q0.OQQOQ0O0Q0(@OO0Q0Q00Q0[OQ0Q0Q00Q0],OC0Q0Q00Q0,OO0Q0OQ0Q0);
OOC0OQ00Q0;
Result:=OC0Q0Q00Q0;
OOQOOQ00Q0;
end;
procedure OCQCOQ00Q0.OOC0OQ00Q0;
var
OQC0OQ00Q0:O0CQ00O0Q0;
OCC0OQ00Q0:OC0QQOO0Q0;
O00OOQ00Q0:OCC00OO0Q0;
begin
OO00OQ00Q0.O0Q0Q0O0Q0;
try
if OO00OQ00Q0.OC00C0O0Q0.O0OC00O0Q0(OQC0OQ00Q0)then
if OQC0OQ00Q0.OCCQ00O0Q0<>nil then begin
try
try
try
OCC0OQ00Q0:=OQC0OQ00Q0.OCCQ00O0Q0.OCO0O0O0Q0;
while OQC0OQ00Q0.OCCQ00O0Q0.OC0QO0O0Q0(OCC0OQ00Q0,O00OOQ00Q0)do
OC00OQ00Q0(TValueArr(O00OOQ00Q0.O00O0OO0Q0),O00OOQ00Q0.OO0O0OO0Q0,O00OOQ00Q0.OQ0O0OO0Q0);
finally
OO00OQ00Q0.OC00C0O0Q0.OQQC00O0Q0(OQC0OQ00Q0.OCCQ00O0Q0.O0Q0O0O0Q0);
end;
finally
OQC0OQ00Q0.OCCQ00O0Q0.Free;
end;
except
on e:Exception do
OO0OOQ00Q0(e);
end;
end;
finally
OO00OQ00Q0.OOQ0Q0O0Q0;
end;
end;
function OCQCOQ00Q0.O0OQ0Q00Q0(const OOOQ0Q00Q0:TValueArr;OQOQ0Q00Q0,OCOQ0Q00Q0:integer):integer;
var
O0QQ0Q00Q0:O0OQOOQ0Q0;
begin
Result:=OQ00OQ00Q0.OQQQ0QO0Q0(OOOQ0Q00Q0,OQOQ0Q00Q0,OCOQ0Q00Q0);
if Result>0 then
Exit;
OCO0OQ00Q0(O0QC00Q0Q0);
O0QQ0Q00Q0:=O0C0OQ00Q0;
Result:=OQ00OQ00Q0.OQQQ0QO0Q0(OOOQ0Q00Q0,OQOQ0Q00Q0,OCOQ0Q00Q0);
if O0QQ0Q00Q0=OC0QOOQ0Q0 then
OO0OOQ00Q0(nil);
end;
procedure OCQCOQ00Q0.OO0OOQ00Q0(OQ0OOQ00Q0:Exception);
begin
if O0CCOQ00Q0 then
Exit;
OOCCOQ00Q0.Enter;
try
if O0CCOQ00Q0 then
Exit;
O0CCOQ00Q0:=True;
OQCCOQ00Q0:=O0COOCOOQ0(OQ0OOQ00Q0);
finally
OOCCOQ00Q0.Leave;
end;
try
if Assigned(OOOC0Q00Q0)then
OOOC0Q00Q0(Self);
except
end;
OO00OQ00Q0.OC0QOC00Q0:=False;
OQ00OQ00Q0.OOQQ0QO0Q0;
end;
function OCQCOQ00Q0.OOQQ0Q00Q0(OQQQ0Q00Q0:integer;OCQQ0Q00Q0:cardinal):boolean;
begin
Result:=OQ00OQ00Q0.OQOC0QO0Q0(OQQQ0Q00Q0,OCQQ0Q00Q0);
end;
procedure OCQCOQ00Q0.O0CQ0Q00Q0;
begin
if O0CCOQ00Q0 or OO00OQ00Q0.OC0QOC00Q0 then
raise EScError.Create(seInvalidOperation);
OO00OQ00Q0.OO0QOC00Q0;
OOC0OQ00Q0;
OOQOOQ00Q0;
end;
procedure OCQCOQ00Q0.OOCQ0Q00Q0;
begin
OOQOOQ00Q0;
if not O0CCOQ00Q0 then begin
if OO00OQ00Q0.OC0QOC00Q0 then
raise EScError.Create(seInvalidOperation);
OO00OQ00Q0.OQ0QOC00Q0;
OOC0OQ00Q0;
end;
end;
function OCQCOQ00Q0.OQCQ0Q00Q0:Exception;
begin
Result:=OQCCOQ00Q0;
end;
function OCQCOQ00Q0.OC0OOQ00Q0:integer;
begin
Result:=OQ00OQ00Q0.OCO00QO0Q0;
end;
function OCQCOQ00Q0.O0OOOQ00Q0:TScCertificate;
begin
Result:=OO00OQ00Q0.OQOQOC00Q0.OCCCOC00Q0;
end;
function OCQCOQ00Q0.OOOOOQ00Q0:OQCCQOQ0Q0;
begin
Result:=OO00OQ00Q0.OQOQOC00Q0.OOCCOC00Q0;
end;
function OCQCOQ00Q0.OQOOOQ00Q0:TNotifyEvent;
begin
Result:=OQ00OQ00Q0.O0Q00QO0Q0;
end;
procedure OCQCOQ00Q0.OCOOOQ00Q0(O0QOOQ00Q0:TNotifyEvent);
begin
OQ00OQ00Q0.O0Q00QO0Q0:=O0QOOQ00Q0;
end;
constructor OCCCC0O0Q0.Create(OCQ0Q0O0Q0:O0QOQ0Q0Q0;O0C0Q0O0Q0:OQOO0C00Q0);
var
OOC0Q0O0Q0:O0QO00O0Q0;
begin
inherited Create;
if OCCQ0QQ0Q0=nil then
raise Exception.Create(SInternalError);
OO00C0O0Q0:=OCCQ0QQ0Q0;
OC0OC0O0Q0:=TCriticalSection.Create;
O0OOC0O0Q0:=TCriticalSection.Create;
OOC0Q0O0Q0.OOQO00O0Q0:=OQOCQQO0Q0;
OOC0Q0O0Q0.OQQO00O0Q0:=0;
OOC0Q0O0Q0.OCQO00O0Q0:=0;
OQ00C0O0Q0:=OCQCQQO0Q0.Create(OOC0Q0O0Q0);
OC00C0O0Q0:=OQ00C0O0Q0.O0C00OO0Q0;
O0O0C0O0Q0:=OQ00C0O0Q0.OOC00OO0Q0;
OQ0OC0O0Q0:=OQ0OC0Q0Q0.Create;
OOOOC0O0Q0:=CreateEvent;
OOO0C0O0Q0:=nil;
OQO0C0O0Q0:=nil;
O0C0C0O0Q0:=nil;
OOC0C0O0Q0:=nil;
OQC0C0O0Q0:=nil;
OCC0C0O0Q0:=nil;
OQOOC0O0Q0:=2048;
OCOOC0O0Q0:=OOQC00Q0Q0;
O000C0O0Q0:=OCQ0Q0O0Q0;
O00OC0O0Q0:=O0C0Q0O0Q0;
OO0OC0O0Q0:=O00OC0O0Q0.Create(Self,OCQ0Q0O0Q0);
end;
destructor OCCCC0O0Q0.Destroy;
begin
{$IFNDEF AUTOREFCOUNT}
OO0OC0O0Q0.Free;
{$ELSE}
OO0OC0O0Q0:=nil;
{$ENDIF}
OQC0C0O0Q0:=nil;
OCC0C0O0Q0:=nil;
OOO0C0O0Q0.Free;
OQO0C0O0Q0.Free;
O0C0C0O0Q0.Free;
OOC0C0O0Q0.Free;
OC0OC0O0Q0.Free;
O0OOC0O0Q0.Free;
OQ0OC0O0Q0.Free;
OOOOC0O0Q0.Free;
OQ00C0O0Q0.Free;
inherited;
end;
procedure OCCCC0O0Q0.OCC0Q0O0Q0;
begin
OC0OC0O0Q0.Enter;
O0OOC0O0Q0.Enter;
try
{$IFNDEF AUTOREFCOUNT}
FreeAndNil(OO0OC0O0Q0);
{$ELSE}
OO0OC0O0Q0:=nil;
{$ENDIF}
O0QOC0O0Q0:=0;
OOQOC0O0Q0:=0;
OQC0C0O0Q0:=nil;
OCC0C0O0Q0:=nil;
FreeAndNil(OOO0C0O0Q0);
FreeAndNil(OQO0C0O0Q0);
FreeAndNil(O0C0C0O0Q0);
FreeAndNil(OOC0C0O0Q0);
OO0OC0O0Q0:=O00OC0O0Q0.Create(Self,O000C0O0Q0);
finally
OC0OC0O0Q0.Leave;
O0OOC0O0Q0.Leave;
end;
end;
procedure OCCCC0O0Q0.O00OQ0O0Q0(const OO0OQ0O0Q0:TSymmetricAlgorithm;
const OQ0OQ0O0Q0:TBytes;const OC0OQ0O0Q0:TKeyedHashAlgorithm);
begin
if OO0OQ0O0Q0=nil then
raise EScError.Create(seInvalidInputArgs);
OOQOC0O0Q0:=0;
FreeAndNil(OOO0C0O0Q0);
OOO0C0O0Q0:=OO0OQ0O0Q0;
if OOO0C0O0Q0.Mode=cmGCM then begin
if(Length(OQ0OQ0O0Q0)<4)or(Length(OQ0OQ0O0Q0)>12)then
OO0OC0O0Q0.OOC00C00Q0(OQC00OQ0Q0,seInvalidInputArgs);
SetLength(OCO0C0O0Q0,12);
Move(OQ0OQ0O0Q0[0],OCO0C0O0Q0[0],Length(OQ0OQ0O0Q0));
if Length(OQ0OQ0O0Q0)<12 then
OO00C0O0Q0.Random(OCO0C0O0Q0,Length(OQ0OQ0O0Q0),12-Length(OQ0OQ0O0Q0));
if OO0OC0O0Q0.O0C00C00Q0=OCQCCQQ0Q0 then
SetLength(O0Q0C0O0Q0,5)
else
SetLength(O0Q0C0O0Q0,13);
end;
FreeAndNil(O0C0C0O0Q0);
O0C0C0O0Q0:=OC0OQ0O0Q0;
if OO0OC0O0Q0.OOCCOC00Q0.OQOOQOQ0Q0=O00QO0QOQ0 then
OQC0C0O0Q0:=OO00C0QOQ0.Create
else
OQC0C0O0Q0:=nil;
end;
procedure OCCCC0O0Q0.O0OOQ0O0Q0(const OOOOQ0O0Q0:TSymmetricAlgorithm;
const OQOOQ0O0Q0:TBytes;const OCOOQ0O0Q0:TKeyedHashAlgorithm);
begin
if OOOOQ0O0Q0=nil then
raise EScError.Create(seInvalidInputArgs);
O0QOC0O0Q0:=0;
FreeAndNil(OQO0C0O0Q0);
OQO0C0O0Q0:=OOOOQ0O0Q0;
if OQO0C0O0Q0.Mode=cmGCM then begin
if(Length(OQOOQ0O0Q0)<4)or(Length(OQOOQ0O0Q0)>12)then
OO0OC0O0Q0.OOC00C00Q0(OQC00OQ0Q0,seInvalidInputArgs);
SetLength(OOQ0C0O0Q0,12);
Move(OQOOQ0O0Q0[0],OOQ0C0O0Q0[0],Length(OQOOQ0O0Q0));
if Length(OQOOQ0O0Q0)<12 then
FillChar(OOQ0C0O0Q0[Length(OQOOQ0O0Q0)],12-Length(OQOOQ0O0Q0),0);
if OO0OC0O0Q0.O0C00C00Q0=OCQCCQQ0Q0 then
SetLength(OQQ0C0O0Q0,5)
else
SetLength(OQQ0C0O0Q0,13);
end;
FreeAndNil(OOC0C0O0Q0);
OOC0C0O0Q0:=OCOOQ0O0Q0;
if OOC0C0O0Q0<>nil then
SetLength(OCQ0C0O0Q0,OOC0C0O0Q0.HashSize);
if OO0OC0O0Q0.OOCCOC00Q0.OQOOQOQ0Q0=O00QO0QOQ0 then
OCC0C0O0Q0:=OO00C0QOQ0.Create
else
OCC0C0O0Q0:=nil;
if OO0OC0O0Q0.O0C00C00Q0=OCQCCQQ0Q0 then
OQOOC0O0Q0:=256
else
if OCC0C0O0Q0<>nil then
OQOOC0O0Q0:=2048
else
OQOOC0O0Q0:=1024;
end;
class procedure OCCCC0O0Q0.OOCOC0O0Q0(var OQCOC0O0Q0:TBytes);
var
OCCOC0O0Q0:integer;
begin
for OCCOC0O0Q0:=Length(OQCOC0O0Q0)-1 downto 4 do begin
OQCOC0O0Q0[OCCOC0O0Q0]:=byte(OQCOC0O0Q0[OCCOC0O0Q0]+1);
if OQCOC0O0Q0[OCCOC0O0Q0]<>0 then
break;
end;
end;
class function OCCCC0O0Q0.O00QQ0O0Q0(const OO0QQ0O0Q0:Int64):TBytes;
begin
Result:=BitConverter.GetBytes(OO0QQ0O0Q0);
if BitConverter.IsLittleEndian then
ArrayReverse(Result,0,Length(Result));
end;
procedure OCCCC0O0Q0.OQ0QQ0O0Q0(const OC0QQ0O0Q0:TValueArr;O0OQQ0O0Q0:integer);
var
OOOQQ0O0Q0:OCC00OO0Q0;
OQOQQ0O0Q0:integer;
OCOQQ0O0Q0:OOCCCQQ0Q0;
O0QQQ0O0Q0:array[0..11]of byte;
OOQQQ0O0Q0:boolean;
OQQQQ0O0Q0:cardinal;
OCQQQ0O0Q0,O0CQQ0O0Q0,OOCQQ0O0Q0,OQCQQ0O0Q0:integer;
OCCQQ0O0Q0:byte;
O00CQ0O0Q0:integer;
OO0CQ0O0Q0:OOQQ00O0Q0;
begin
OCOQQ0O0Q0:=OO0OC0O0Q0.O0C00C00Q0;
OOOQQ0O0Q0:=O0O0C0O0Q0.OOO000O0Q0(O0OQQ0O0Q0+2048);
OOOQQ0O0Q0.O00O0OO0Q0:=PtrOffset(OOOQQ0O0Q0.O00O0OO0Q0,OOOQQ0O0Q0.OO0O0OO0Q0);
OOOQQ0O0Q0.OO0O0OO0Q0:=0;
OQOQQ0O0Q0:=O0QC00Q0Q0;
if(OOO0C0O0Q0<>nil)and
not((OCOQQ0O0Q0=OCQCCQQ0Q0)and(OQ0OC0O0Q0.OC0OC0Q0Q0=OQCOOOQ0Q0)and OO0OC0O0Q0.O0OO0C00Q0)then
begin
O0CQQ0O0Q0:=0;
OOQQQ0O0Q0:=(OCOQQ0O0Q0 in[OOQCCQQ0Q0,OQQCCQQ0Q0])and(OOO0C0O0Q0.Mode=cmCBC);
if OOQQQ0O0Q0 then begin
OO00C0O0Q0.Random(@OOOQQ0O0Q0.O00O0OO0Q0[OQOQQ0O0Q0],OOO0C0O0Q0.BlockSize);
OOO0C0O0Q0.SetIV(TValueArr(OOOQQ0O0Q0.O00O0OO0Q0),OQOQQ0O0Q0,OOO0C0O0Q0.BlockSize);
Inc(OQOQQ0O0Q0,OOO0C0O0Q0.BlockSize);
end
else
if(OOO0C0O0Q0.Mode=cmGCM)and(OCOQQ0O0Q0<>OCQCCQQ0Q0)then begin
Move(OCO0C0O0Q0[4],OOOQQ0O0Q0.O00O0OO0Q0[OQOQQ0O0Q0],8);
Inc(OQOQQ0O0Q0,8);
O0CQQ0O0Q0:=8;
OOO0C0O0Q0.SetIV(TValueArr(OCO0C0O0Q0),0,Length(OCO0C0O0Q0));
OOCOC0O0Q0(OCO0C0O0Q0);
end;
if(OQC0C0O0Q0<>nil)and(O0OQQ0O0Q0>0)then begin
OQQQQ0O0Q0:=OOOQQ0O0Q0.OQ0O0OO0Q0-OQOQQ0O0Q0;
OQC0C0O0Q0.O0CQC0QOQ0(OC0QQ0O0Q0,0,O0OQQ0O0Q0,TValueArr(OOOQQ0O0Q0.O00O0OO0Q0),OQOQQ0O0Q0,OQQQQ0O0Q0,True);
OQ0OC0O0Q0.OQOOC0Q0Q0:=OQQQQ0O0Q0;
end
else begin
if O0OQQ0O0Q0>0 then
Move(OC0QQ0O0Q0^,OOOQQ0O0Q0.O00O0OO0Q0[OQOQQ0O0Q0],O0OQQ0O0Q0);
OQ0OC0O0Q0.OQOOC0Q0Q0:=O0OQQ0O0Q0;
end;
if O0C0C0O0Q0<>nil then begin
OQ0OC0O0Q0.OCOOC0Q0Q0(OOOQQ0O0Q0.O00O0OO0Q0,OQ0OC0O0Q0.OQOOC0Q0Q0);
O0C0C0O0Q0.Initialize;
O0C0C0O0Q0.TransformBlock(O00QQ0O0Q0(OOQOC0O0Q0),0,OCQO0Q00Q0);
if OCOQQ0O0Q0=O0CCCQQ0Q0 then begin
O0C0C0O0Q0.TransformBlock(TValueArr(OOOQQ0O0Q0.O00O0OO0Q0),0,1,TValueArr(OOOQQ0O0Q0.O00O0OO0Q0),0);
O0C0C0O0Q0.TransformFinalBlock(@TValueArr(OOOQQ0O0Q0.O00O0OO0Q0)[3],OQ0OC0O0Q0.OQOOC0Q0Q0+2);
end
else begin
O0C0C0O0Q0.TransformBlock(TValueArr(OOOQQ0O0Q0.O00O0OO0Q0),0,O0QC00Q0Q0,TValueArr(OOOQQ0O0Q0.O00O0OO0Q0),0);
O0C0C0O0Q0.TransformFinalBlock(@TValueArr(OOOQQ0O0Q0.O00O0OO0Q0)[OQOQQ0O0Q0],OQ0OC0O0Q0.OQOOC0Q0Q0);
end;
OOCQQ0O0Q0:=O0C0C0O0Q0.HashSize;
Move(O0C0C0O0Q0.Hash[0],OOOQQ0O0Q0.O00O0OO0Q0[OQOQQ0O0Q0+OQ0OC0O0Q0.OQOOC0Q0Q0],OOCQQ0O0Q0);
end
else
OOCQQ0O0Q0:=0;
case OOO0C0O0Q0.Mode of
cmECB:begin
OQ0OC0O0Q0.OOOOC0Q0Q0:=OQ0OC0O0Q0.OQOOC0Q0Q0+OOCQQ0O0Q0;
end;
cmCBC:begin
OQCQQ0O0Q0:=OOO0C0O0Q0.BlockSize;
OCCQQ0O0Q0:=Byte((OQCQQ0O0Q0-(OQ0OC0O0Q0.OQOOC0Q0Q0+OOCQQ0O0Q0+1)mod OQCQQ0O0Q0)mod OQCQQ0O0Q0);
OQ0OC0O0Q0.OOOOC0Q0Q0:=OQ0OC0O0Q0.OQOOC0Q0Q0+OOCQQ0O0Q0+OCCQQ0O0Q0+1;
if OCOQQ0O0Q0=O0CCCQQ0Q0 then begin
OO00C0O0Q0.Random(@TValueArr(OOOQQ0O0Q0.O00O0OO0Q0)[OQOQQ0O0Q0+OQ0OC0O0Q0.OQOOC0Q0Q0+OOCQQ0O0Q0],OCCQQ0O0Q0);
OOOQQ0O0Q0.O00O0OO0Q0[OQOQQ0O0Q0+OQ0OC0O0Q0.OOOOC0Q0Q0-1]:=OCCQQ0O0Q0;
end
else
for O00CQ0O0Q0:=OQ0OC0O0Q0.OQOOC0Q0Q0+OOCQQ0O0Q0 to OQ0OC0O0Q0.OOOOC0Q0Q0-1 do
OOOQQ0O0Q0.O00O0OO0Q0[OQOQQ0O0Q0+O00CQ0O0Q0]:=OCCQQ0O0Q0;
end;
cmGCM:begin
if OCOQQ0O0Q0=OCQCCQQ0Q0 then begin
PutInt64BE(OOQOC0O0Q0,TValueArr(@O0QQQ0O0Q0),4);
Move(OCO0C0O0Q0[0],O0QQQ0O0Q0[0],4);
for O00CQ0O0Q0:=4 to 11 do
O0QQQ0O0Q0[O00CQ0O0Q0]:=O0QQQ0O0Q0[O00CQ0O0Q0]xor OCO0C0O0Q0[O00CQ0O0Q0];
OOO0C0O0Q0.SetIV(TValueArr(@O0QQQ0O0Q0),0,Length(O0QQQ0O0Q0));
OOOQQ0O0Q0.O00O0OO0Q0[OQOQQ0O0Q0+OQ0OC0O0Q0.OQOOC0Q0Q0]:=OOOQ0OQ0Q0[OQ0OC0O0Q0.OC0OC0Q0Q0];
OQ0OC0O0Q0.OC0OC0Q0Q0:=OO0Q0OQ0Q0;
Inc(OQ0OC0O0Q0.OQOOC0Q0Q0);
OQ0OC0O0Q0.OOOOC0Q0Q0:=OQ0OC0O0Q0.OQOOC0Q0Q0;
OCQQQ0O0Q0:=OQ0OC0O0Q0.OOOOC0Q0Q0+OOO0C0O0Q0.BlockSize;
O0Q0C0O0Q0[0]:=OOOQ0OQ0Q0[OO0Q0OQ0Q0];
O0Q0C0O0Q0[1]:=OQ0OC0O0Q0.O0OOC0Q0Q0.OQ0CCOQ0Q0;
O0Q0C0O0Q0[2]:=OQ0OC0O0Q0.O0OOC0Q0Q0.OC0CCOQ0Q0;
O0Q0C0O0Q0[3]:=Byte(OCQQQ0O0Q0 shr 8);
O0Q0C0O0Q0[4]:=Byte(OCQQQ0O0Q0);
OOO0C0O0Q0.AAD:=O0Q0C0O0Q0;
end
else begin
PutInt64BE(OOQOC0O0Q0,TValueArr(O0Q0C0O0Q0),0);
O0Q0C0O0Q0[8]:=OOOQ0OQ0Q0[OQ0OC0O0Q0.OC0OC0Q0Q0];
O0Q0C0O0Q0[9]:=OQ0OC0O0Q0.O0OOC0Q0Q0.OQ0CCOQ0Q0;
O0Q0C0O0Q0[10]:=OQ0OC0O0Q0.O0OOC0Q0Q0.OC0CCOQ0Q0;
O0Q0C0O0Q0[11]:=Byte(OQ0OC0O0Q0.OQOOC0Q0Q0 shr 8);
O0Q0C0O0Q0[12]:=Byte(OQ0OC0O0Q0.OQOOC0Q0Q0);
OOO0C0O0Q0.AAD:=O0Q0C0O0Q0;
OQ0OC0O0Q0.OOOOC0Q0Q0:=OQ0OC0O0Q0.OQOOC0Q0Q0;
end;
end;
else
Assert(False);
end;
OOO0C0O0Q0.EncodeBuffer(TValueArr(OOOQQ0O0Q0.O00O0OO0Q0),OQOQQ0O0Q0,OQ0OC0O0Q0.OOOOC0Q0Q0,
TValueArr(OOOQQ0O0Q0.O00O0OO0Q0),OQOQQ0O0Q0);
Inc(OQOQQ0O0Q0,OQ0OC0O0Q0.OOOOC0Q0Q0);
if OOQQQ0O0Q0 then
OQ0OC0O0Q0.OOOOC0Q0Q0:=OQ0OC0O0Q0.OOOOC0Q0Q0+OOO0C0O0Q0.BlockSize
else
if OOO0C0O0Q0.Mode=cmGCM then begin
Move(OOO0C0O0Q0.Tag[0],OOOQQ0O0Q0.O00O0OO0Q0[OQOQQ0O0Q0],OOO0C0O0Q0.BlockSize);
Inc(OQOQQ0O0Q0,OOO0C0O0Q0.BlockSize);
OQ0OC0O0Q0.OOOOC0Q0Q0:=OQ0OC0O0Q0.OOOOC0Q0Q0+O0CQQ0O0Q0+OOO0C0O0Q0.BlockSize;
end;
Inc(OOQOC0O0Q0);
end
else begin
if O0OQQ0O0Q0>0 then begin
Move(OC0QQ0O0Q0^,OOOQQ0O0Q0.O00O0OO0Q0[OQOQQ0O0Q0],O0OQQ0O0Q0);
Inc(OQOQQ0O0Q0,O0OQQ0O0Q0);
end;
OQ0OC0O0Q0.OOOOC0Q0Q0:=O0OQQ0O0Q0;
end;
OQ0OC0O0Q0.OCOOC0Q0Q0(OOOQQ0O0Q0.O00O0OO0Q0,OQ0OC0O0Q0.OOOOC0Q0Q0);
O0O0C0O0Q0.OCQ000O0Q0(OQOQQ0O0Q0);
OO0CQ0O0Q0:=O0O0C0O0Q0.OQO000O0Q0;
if OO0CQ0O0Q0.OQQQ00O0Q0 or OO0CQ0O0Q0.OCQQ00O0Q0 then
OO0OC0O0Q0.OOC00C00Q0(O0000OQ0Q0,seErrorHandshakeProcedure);
end;
procedure OCCCC0O0Q0.OQ0CQ0O0Q0(OC0CQ0O0Q0:OC00C0Q0Q0);
var
O0OCQ0O0Q0:OOCCCQQ0Q0;
OOOCQ0O0Q0:array[0..11]of byte;
OQOCQ0O0Q0,OCOCQ0O0Q0:boolean;
O0QCQ0O0Q0:byte;
OOQCQ0O0Q0:integer;
OQQCQ0O0Q0:integer;
OCQCQ0O0Q0,O0CCQ0O0Q0,OOCCQ0O0Q0,OQCCQ0O0Q0:cardinal;
OCCCQ0O0Q0:integer;
begin
OCOCQ0O0Q0:=False;
O0OCQ0O0Q0:=OO0OC0O0Q0.O0C00C00Q0;
if(OQO0C0O0Q0<>nil)and not((O0OCQ0O0Q0=OCQCCQQ0Q0)and(OC0CQ0O0Q0.O0O0C0Q0Q0=OQCOOOQ0Q0)and OO0OC0O0Q0.O0OO0C00Q0)then begin
if(OOC0C0O0Q0<>nil)and(OC0CQ0O0Q0.OQQ0C0Q0Q0<=OOC0C0O0Q0.HashSize)then
OO0OC0O0Q0.OOC00C00Q0(OO000OQ0Q0,seInvalidMessageLength);
OQOCQ0O0Q0:=(O0OCQ0O0Q0 in[OOQCCQQ0Q0,OQQCCQQ0Q0])and(OQO0C0O0Q0.Mode=cmCBC);
OQQCQ0O0Q0:=OC0CQ0O0Q0.O0Q0C0Q0Q0+O0QC00Q0Q0;
case OQO0C0O0Q0.Mode of
cmECB:begin
OQO0C0O0Q0.DecodeBuffer(TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0,OC0CQ0O0Q0.OQQ0C0Q0Q0,
TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0);
Buffer.BlockCopy(OC0CQ0O0Q0.OQO0C0Q0Q0,OQQCQ0O0Q0+OC0CQ0O0Q0.OQQ0C0Q0Q0-Length(OCQ0C0O0Q0),OCQ0C0O0Q0,0,Length(OCQ0C0O0Q0));
OC0CQ0O0Q0.OCQ0C0Q0Q0:=OC0CQ0O0Q0.OQQ0C0Q0Q0-Length(OCQ0C0O0Q0);
end;
cmCBC:begin
if(OC0CQ0O0Q0.OQQ0C0Q0Q0 mod OQO0C0O0Q0.BlockSize)<>0 then
OO0OC0O0Q0.OOC00C00Q0(OO000OQ0Q0,seInvalidMessageLength);
if OQOCQ0O0Q0 then begin
OQO0C0O0Q0.SetIV(TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0,OQO0C0O0Q0.BlockSize);
OC0CQ0O0Q0.OQQ0C0Q0Q0:=OC0CQ0O0Q0.OQQ0C0Q0Q0-OQO0C0O0Q0.BlockSize;
OQQCQ0O0Q0:=OQQCQ0O0Q0+OQO0C0O0Q0.BlockSize;
end;
OQO0C0O0Q0.DecodeBuffer(TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0,OC0CQ0O0Q0.OQQ0C0Q0Q0,
TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0);
O0QCQ0O0Q0:=OC0CQ0O0Q0.OQO0C0Q0Q0[OQQCQ0O0Q0+OC0CQ0O0Q0.OQQ0C0Q0Q0-1];
if OC0CQ0O0Q0.OQQ0C0Q0Q0<(O0QCQ0O0Q0+OOC0C0O0Q0.HashSize+1)then begin
OCOCQ0O0Q0:=True;
OC0CQ0O0Q0.OCQ0C0Q0Q0:=OC0CQ0O0Q0.OQQ0C0Q0Q0-1-OOC0C0O0Q0.HashSize;
end
else begin
OOQCQ0O0Q0:=OC0CQ0O0Q0.OQQ0C0Q0Q0-O0QCQ0O0Q0-1;
Buffer.BlockCopy(OC0CQ0O0Q0.OQO0C0Q0Q0,OQQCQ0O0Q0+OOQCQ0O0Q0-Length(OCQ0C0O0Q0),OCQ0C0O0Q0,0,Length(OCQ0C0O0Q0));
if O0OCQ0O0Q0<>O0CCCQQ0Q0 then begin
for OCCCQ0O0Q0:=0 to O0QCQ0O0Q0-1 do
if OC0CQ0O0Q0.OQO0C0Q0Q0[OQQCQ0O0Q0+OOQCQ0O0Q0+OCCCQ0O0Q0]<>O0QCQ0O0Q0 then begin
OCOCQ0O0Q0:=True;
Break;
end;
end;
OC0CQ0O0Q0.OCQ0C0Q0Q0:=OOQCQ0O0Q0-Length(OCQ0C0O0Q0);
end;
end;
cmGCM:begin
if O0OCQ0O0Q0=OCQCCQQ0Q0 then begin
if OC0CQ0O0Q0.OQQ0C0Q0Q0<OQO0C0O0Q0.BlockSize then
OO0OC0O0Q0.OOC00C00Q0(OO000OQ0Q0,seInvalidMessageLength);
PutInt64BE(O0QOC0O0Q0,TValueArr(@OOOCQ0O0Q0),4);
Move(OOQ0C0O0Q0[0],OOOCQ0O0Q0[0],4);
for OCCCQ0O0Q0:=4 to 11 do
OOOCQ0O0Q0[OCCCQ0O0Q0]:=OOOCQ0O0Q0[OCCCQ0O0Q0]xor OOQ0C0O0Q0[OCCCQ0O0Q0];
OQO0C0O0Q0.SetIV(TValueArr(@OOOCQ0O0Q0),0,Length(OOOCQ0O0Q0));
OQQ0C0O0Q0[0]:=OOOQ0OQ0Q0[OC0CQ0O0Q0.O0O0C0Q0Q0];
OQQ0C0O0Q0[1]:=OC0CQ0O0Q0.OOO0C0Q0Q0.OQ0CCOQ0Q0;
OQQ0C0O0Q0[2]:=OC0CQ0O0Q0.OOO0C0Q0Q0.OC0CCOQ0Q0;
OQQ0C0O0Q0[3]:=Byte(OC0CQ0O0Q0.OQQ0C0Q0Q0 shr 8);
OQQ0C0O0Q0[4]:=Byte(OC0CQ0O0Q0.OQQ0C0Q0Q0);
OQO0C0O0Q0.AAD:=OQQ0C0O0Q0;
OC0CQ0O0Q0.OCQ0C0Q0Q0:=OC0CQ0O0Q0.OQQ0C0Q0Q0-OQO0C0O0Q0.BlockSize;
OQO0C0O0Q0.SetReceivedTag(TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0+OC0CQ0O0Q0.OCQ0C0Q0Q0,OQO0C0O0Q0.BlockSize);
OQO0C0O0Q0.DecodeBuffer(TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0,OC0CQ0O0Q0.OCQ0C0Q0Q0,
TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0);
while(OC0CQ0O0Q0.OCQ0C0Q0Q0>0)and(OC0CQ0O0Q0.OQO0C0Q0Q0[OQQCQ0O0Q0+OC0CQ0O0Q0.OCQ0C0Q0Q0-1]=0)do
Dec(OC0CQ0O0Q0.OCQ0C0Q0Q0);
if OC0CQ0O0Q0.OCQ0C0Q0Q0=0 then
OO0OC0O0Q0.OOC00C00Q0(OO000OQ0Q0,seCorruptMessage);
OC0CQ0O0Q0.O0O0C0Q0Q0:=O00QO0Q0Q0.OO0QO0Q0Q0(OC0CQ0O0Q0.OQO0C0Q0Q0[OQQCQ0O0Q0+OC0CQ0O0Q0.OCQ0C0Q0Q0-1]);
if OC0CQ0O0Q0.O0O0C0Q0Q0=OQCOOOQ0Q0 then
OO0OC0O0Q0.OOC00C00Q0(OO000OQ0Q0,seCorruptMessage);
Dec(OC0CQ0O0Q0.OCQ0C0Q0Q0);
end
else begin
if OC0CQ0O0Q0.OQQ0C0Q0Q0<(8+OQO0C0O0Q0.BlockSize)then
OO0OC0O0Q0.OOC00C00Q0(OO000OQ0Q0,seInvalidMessageLength);
Move(OC0CQ0O0Q0.OQO0C0Q0Q0[OQQCQ0O0Q0],OOQ0C0O0Q0[4],8);
OQO0C0O0Q0.SetIV(TValueArr(OOQ0C0O0Q0),0,Length(OOQ0C0O0Q0));
OQQCQ0O0Q0:=OQQCQ0O0Q0+8;
OC0CQ0O0Q0.O0Q0C0Q0Q0:=OC0CQ0O0Q0.O0Q0C0Q0Q0+8;
OC0CQ0O0Q0.OQQ0C0Q0Q0:=OC0CQ0O0Q0.OQQ0C0Q0Q0-8;
OC0CQ0O0Q0.OCQ0C0Q0Q0:=OC0CQ0O0Q0.OQQ0C0Q0Q0-OQO0C0O0Q0.BlockSize;
PutInt64BE(O0QOC0O0Q0,TValueArr(OQQ0C0O0Q0),0);
OQQ0C0O0Q0[8]:=OOOQ0OQ0Q0[OC0CQ0O0Q0.O0O0C0Q0Q0];
OQQ0C0O0Q0[9]:=OC0CQ0O0Q0.OOO0C0Q0Q0.OQ0CCOQ0Q0;
OQQ0C0O0Q0[10]:=OC0CQ0O0Q0.OOO0C0Q0Q0.OC0CCOQ0Q0;
OQQ0C0O0Q0[11]:=Byte(OC0CQ0O0Q0.OCQ0C0Q0Q0 shr 8);
OQQ0C0O0Q0[12]:=Byte(OC0CQ0O0Q0.OCQ0C0Q0Q0);
OQO0C0O0Q0.AAD:=OQQ0C0O0Q0;
OQO0C0O0Q0.SetReceivedTag(TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0+OC0CQ0O0Q0.OCQ0C0Q0Q0,OQO0C0O0Q0.BlockSize);
OQO0C0O0Q0.DecodeBuffer(TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0,OC0CQ0O0Q0.OCQ0C0Q0Q0,
TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OQQCQ0O0Q0);
end;
end;
else
Assert(False);
end;
if OOC0C0O0Q0<>nil then begin
OOC0C0O0Q0.Initialize;
OOC0C0O0Q0.TransformBlock(O00QQ0O0Q0(O0QOC0O0Q0),0,OCQO0Q00Q0);
OC0CQ0O0Q0.O00OC0Q0Q0(OC0CQ0O0Q0.OCQ0C0Q0Q0);
if O0OCQ0O0Q0=O0CCCQQ0Q0 then begin
OOC0C0O0Q0.TransformBlock(OC0CQ0O0Q0.OQO0C0Q0Q0,OC0CQ0O0Q0.O0Q0C0Q0Q0,1);
OOC0C0O0Q0.TransformFinalBlock(OC0CQ0O0Q0.OQO0C0Q0Q0,OC0CQ0O0Q0.O0Q0C0Q0Q0+3,OC0CQ0O0Q0.OCQ0C0Q0Q0+2);
end
else begin
OOC0C0O0Q0.TransformBlock(OC0CQ0O0Q0.OQO0C0Q0Q0,OC0CQ0O0Q0.O0Q0C0Q0Q0,O0QC00Q0Q0);
if OQOCQ0O0Q0 then
OC0CQ0O0Q0.O0Q0C0Q0Q0:=OC0CQ0O0Q0.O0Q0C0Q0Q0+OQO0C0O0Q0.BlockSize;
OOC0C0O0Q0.TransformFinalBlock(OC0CQ0O0Q0.OQO0C0Q0Q0,OC0CQ0O0Q0.O0Q0C0Q0Q0+O0QC00Q0Q0,OC0CQ0O0Q0.OCQ0C0Q0Q0);
end;
if(Length(OOC0C0O0Q0.Hash)<>Length(OCQ0C0O0Q0))or
(MemCompare(@OOC0C0O0Q0.Hash[0],@OCQ0C0O0Q0[0],Length(OCQ0C0O0Q0))<>0)then
OCOCQ0O0Q0:=True;
end;
if OCOCQ0O0Q0 then
OO0OC0O0Q0.OOC00C00Q0(OO000OQ0Q0,seCorruptMessage);
OC0CQ0O0Q0.O0Q0C0Q0Q0:=OC0CQ0O0Q0.O0Q0C0Q0Q0+O0QC00Q0Q0;
if(OCC0C0O0Q0<>nil)and(OC0CQ0O0Q0.OCQ0C0Q0Q0>0)then begin
if OC0CQ0O0Q0.OQO0C0Q0Q0=OC0CQ0O0Q0.OCO0C0Q0Q0 then
OC0CQ0O0Q0.OCO0C0Q0Q0:=nil;
if Length(OC0CQ0O0Q0.OCO0C0Q0Q0)<(OC0CQ0O0Q0.OCQ0C0Q0Q0 shl 2)+OC0CQ0O0Q0.O0Q0C0Q0Q0 then
SetLength(OC0CQ0O0Q0.OCO0C0Q0Q0,(OC0CQ0O0Q0.OCQ0C0Q0Q0 shl 2)+OC0CQ0O0Q0.O0Q0C0Q0Q0);
OCQCQ0O0Q0:=OC0CQ0O0Q0.O0Q0C0Q0Q0;
O0CCQ0O0Q0:=OC0CQ0O0Q0.OCQ0C0Q0Q0;
OOCCQ0O0Q0:=OCQCQ0O0Q0;
OQCCQ0O0Q0:=Length(OC0CQ0O0Q0.OCO0C0Q0Q0)-OC0CQ0O0Q0.O0Q0C0Q0Q0;
while not OCC0C0O0Q0.O0OCC0QOQ0(TValueArr(OC0CQ0O0Q0.OQO0C0Q0Q0),OCQCQ0O0Q0,O0CCQ0O0Q0,TValueArr(OC0CQ0O0Q0.OCO0C0Q0Q0),OOCCQ0O0Q0,OQCCQ0O0Q0)do begin
Inc(OOCCQ0O0Q0,OQCCQ0O0Q0);
OQCCQ0O0Q0:=O0CCQ0O0Q0 shl 2;
SetLength(OC0CQ0O0Q0.OCO0C0Q0Q0,Length(OC0CQ0O0Q0.OCO0C0Q0Q0)+integer(OQCCQ0O0Q0));
end;
OC0CQ0O0Q0.OCQ0C0Q0Q0:=integer(OOCCQ0O0Q0+OQCCQ0O0Q0)-OC0CQ0O0Q0.O0Q0C0Q0Q0;
end
else
OC0CQ0O0Q0.OCO0C0Q0Q0:=OC0CQ0O0Q0.OQO0C0Q0Q0;
Inc(O0QOC0O0Q0);
end
else begin
OC0CQ0O0Q0.OCO0C0Q0Q0:=OC0CQ0O0Q0.OQO0C0Q0Q0;
OC0CQ0O0Q0.OCQ0C0Q0Q0:=OC0CQ0O0Q0.OQQ0C0Q0Q0;
OC0CQ0O0Q0.O0Q0C0Q0Q0:=OC0CQ0O0Q0.O0Q0C0Q0Q0+O0QC00Q0Q0;
end;
end;
procedure OCCCC0O0Q0.O0QOQ0O0Q0(OOQOQ0O0Q0:OCQC00Q0Q0);
begin
OQQOQ0O0Q0(TValueArr(@OOQOQ0O0Q0.OCCCC0Q0Q0[OOQOQ0O0Q0.O000C0Q0Q0-OCOC00Q0Q0]),
OOQOQ0O0Q0.OQ00C0Q0Q0-OOQOQ0O0Q0.O000C0Q0Q0+OCOC00Q0Q0,O00Q0OQ0Q0);
end;
procedure OCCCC0O0Q0.OQQOQ0O0Q0(const OCQOQ0O0Q0:TValueArr;O0COQ0O0Q0:integer;OOCOQ0O0Q0:O0OQ0OQ0Q0);
var
OQCOQ0O0Q0,OCCOQ0O0Q0:integer;
begin
OC0OC0O0Q0.Enter;
try
OQ0OC0O0Q0.OC0OC0Q0Q0:=OOCOQ0O0Q0;
OQ0OC0O0Q0.O0OOC0Q0Q0:=O0OCCOQ0Q0.OCCCCOQ0Q0(OO0OC0O0Q0.O0C00C00Q0);
OQCOQ0O0Q0:=0;
repeat
if O0COQ0O0Q0>OCOOC0O0Q0 then
OCCOQ0O0Q0:=OCOOC0O0Q0
else
OCCOQ0O0Q0:=O0COQ0O0Q0;
OQ0QQ0O0Q0(@OCQOQ0O0Q0[OQCOQ0O0Q0],OCCOQ0O0Q0);
Inc(OQCOQ0O0Q0,OCCOQ0O0Q0);
Dec(O0COQ0O0Q0,OCCOQ0O0Q0);
until O0COQ0O0Q0=0;
if OOQOC0O0Q0>O0CO0Q00Q0 then
OO0OC0O0Q0.OCCQ0C00Q0;
finally
OC0OC0O0Q0.Leave;
end;
end;
procedure OCCCC0O0Q0.OQO0Q0O0Q0;
begin
OC0OC0O0Q0.Enter;
end;
procedure OCCCC0O0Q0.OCO0Q0O0Q0;
begin
OC0OC0O0Q0.Leave;
end;
procedure OCCCC0O0Q0.O0Q0Q0O0Q0;
begin
O0OOC0O0Q0.Enter;
end;
procedure OCCCC0O0Q0.OOQ0Q0O0Q0;
begin
O0OOC0O0Q0.Leave;
end;
function OCCCC0O0Q0.O000Q0O0Q0(OO00Q0O0Q0:OC00C0Q0Q0;OQ00Q0O0Q0:OQOOOQO0Q0;
out OC00Q0O0Q0:integer):O0OQOOQ0Q0;
procedure O0O0Q0O0Q0;
var
OOO0Q0O0Q0:integer;
begin
OOO0Q0O0Q0:=OO00Q0O0Q0.OOQ0C0Q0Q0-OO00Q0O0Q0.O0Q0C0Q0Q0;
if OOO0Q0O0Q0<O0QC00Q0Q0 then begin
OO00Q0O0Q0.OQQ0C0Q0Q0:=0;
if OOO0Q0O0Q0=0 then
OC00Q0O0Q0:=0
else
OC00Q0O0Q0:=O0QC00Q0Q0-OOO0Q0O0Q0;
end
else begin
OO00Q0O0Q0.OQQ0C0Q0Q0:=(OO00Q0O0Q0.OQO0C0Q0Q0[OO00Q0O0Q0.O0Q0C0Q0Q0+3]shl 8)+
OO00Q0O0Q0.OQO0C0Q0Q0[OO00Q0O0Q0.O0Q0C0Q0Q0+4];
if OO00Q0O0Q0.OQQ0C0Q0Q0>OCOOC0O0Q0+OQOOC0O0Q0 then
OO0OC0O0Q0.OOC00C00Q0(OC000OQ0Q0,seInvalidMessageLength);
OC00Q0O0Q0:=OO00Q0O0Q0.OQQ0C0Q0Q0+O0QC00Q0Q0-OOO0Q0O0Q0;
end;
end;
begin
Result:=OQ0QOOQ0Q0;
O0O0Q0O0Q0;
if OC00Q0O0Q0>0 then
Exit;
while(OO00Q0O0Q0.OQQ0C0Q0Q0>0)and(OC00Q0O0Q0<=0)do begin
OO00Q0O0Q0.O0O0C0Q0Q0:=O00QO0Q0Q0.OO0QO0Q0Q0(OO00Q0O0Q0.OQO0C0Q0Q0[OO00Q0O0Q0.O0Q0C0Q0Q0]);
OO00Q0O0Q0.OOO0C0Q0Q0.OQ0CCOQ0Q0:=OO00Q0O0Q0.OQO0C0Q0Q0[OO00Q0O0Q0.O0Q0C0Q0Q0+1];
OO00Q0O0Q0.OOO0C0Q0Q0.OC0CCOQ0Q0:=OO00Q0O0Q0.OQO0C0Q0Q0[OO00Q0O0Q0.O0Q0C0Q0Q0+2];
OQ0CQ0O0Q0(OO00Q0O0Q0);
if OO00Q0O0Q0.OCQ0C0Q0Q0>OCOOC0O0Q0 then
OO0OC0O0Q0.OOC00C00Q0(OC000OQ0Q0,seInvalidMessageLength);
if OO00Q0O0Q0.O0O0C0Q0Q0=OO0Q0OQ0Q0 then begin
if OO0OC0O0Q0.O0OO0C00Q0 then
OO0OC0O0Q0.OOC00C00Q0(O0000OQ0Q0,seErrorHandshakeProcedure)
else
OQ00Q0O0Q0.OO0C0QO0Q0(TValueArr(OO00Q0O0Q0.OCO0C0Q0Q0),OO00Q0O0Q0.O0Q0C0Q0Q0,OO00Q0O0Q0.OCQ0C0Q0Q0);
Result:=O00QOOQ0Q0;
end
else
if OO00Q0O0Q0.O0O0C0Q0Q0=OQCOOOQ0Q0 then
Result:=OO0OC0O0Q0.OOO00C00Q0(OO00Q0O0Q0)
else
if OO00Q0O0Q0.O0O0C0Q0Q0=O00Q0OQ0Q0 then
Result:=OO0OC0O0Q0.OCQC0C00Q0(OO00Q0O0Q0)
else
if OO00Q0O0Q0.O0O0C0Q0Q0=OCCOOOQ0Q0 then
Result:=OO0OC0O0Q0.O0COOC00Q0(OO00Q0O0Q0)
else
OO0OC0O0Q0.OOC00C00Q0(O0000OQ0Q0,seUnknownMessageType);
OO00Q0O0Q0.O0Q0C0Q0Q0:=OO00Q0O0Q0.O0Q0C0Q0Q0+OO00Q0O0Q0.OQQ0C0Q0Q0;
if Result=OC0QOOQ0Q0 then
break;
O0O0Q0O0Q0;
end;
OO00Q0O0Q0.OCC0C0Q0Q0;
if OO0OC0O0Q0.OOO0OC00Q0 then begin
if O0QOC0O0Q0>(O0CO0Q00Q0+20)then
OO0OC0O0Q0.OOC00C00Q0(O0000OQ0Q0,seErrorHandshakeProcedure);
end
else
if O0QOC0O0Q0>O0CO0Q00Q0 then
OO0OC0O0Q0.OCCQ0C00Q0;
end;
procedure OCCCC0O0Q0.O00QOC00Q0;
begin
OQO0Q0O0Q0;
try
OO0OC0O0Q0.OOCQ0C00Q0;
finally
OCO0Q0O0Q0;
end;
end;
procedure OCCCC0O0Q0.OO0QOC00Q0;
begin
OQO0Q0O0Q0;
try
OO0OC0O0Q0.OCCQ0C00Q0;
finally
OCO0Q0O0Q0;
end;
end;
procedure OCCCC0O0Q0.OQ0QOC00Q0;
begin
OQO0Q0O0Q0;
try
OO0OC0O0Q0.OOOC0C00Q0;
finally
OCO0Q0O0Q0;
end;
end;
function OCCCC0O0Q0.OQQOC0O0Q0:boolean;
begin
Result:=OO0OC0O0Q0.O0OO0C00Q0;
end;
procedure OCCCC0O0Q0.OCQOC0O0Q0(O0COC0O0Q0:boolean);
begin
OO0OC0O0Q0.O0OO0C00Q0:=O0COC0O0Q0;
end;
constructor OOQQOC00Q0.Create(OQQ00C00Q0:OCCCC0O0Q0;OCQ0Q0O0Q0:O0QOQ0Q0Q0);
begin
inherited Create;
if OQQ00C00Q0=nil then
raise EScError.Create(seInvalidInputArgs);
if OCQ0Q0O0Q0=nil then
raise EScError.Create(seInvalidInputArgs);
if OCCQ0QQ0Q0=nil then
raise Exception.Create(SInternalError);
OQOCOC00Q0:=OCCQ0QQ0Q0;
OQCCOC00Q0:=TCRList.Create;
OOCCOC00Q0:=OQCCQOQ0Q0.Create;
OCQQOC00Q0:=TCriticalSection.Create;
OQQCOC00Q0:=OCQC00Q0Q0.Create;
OOQCOC00Q0:=OQQ00C00Q0;
O0QCOC00Q0:=OCQ0Q0O0Q0;
OCOCOC00Q0:=nil;
OCQCOC00Q0:=OOQC0OQ0Q0;
SetLength(O0CQOC00Q0,OOQC00Q0Q0*2);
OCCQOC00Q0:=True;
OC00OC00Q0:=False;
O000OC00Q0:=False;
OO00OC00Q0:=False;
OOO0OC00Q0:=False;
OOCCOC00Q0.OOOOQOQ0Q0:=OQCCCQQ0Q0;
OCCCOC00Q0:=nil;
SetLength(O0CCOC00Q0,64);
if O0QCOC00Q0.OC0Q0CO0Q0>604800 then
O0QCOC00Q0.OC0Q0CO0Q0:=604800;
if(O0QCOC00Q0.OQQOOCO0Q0<>nil)and O0QCOC00Q0.OQQOOCO0Q0.O0OOQOQ0Q0 then
OOCCOC00Q0.Assign(O0QCOC00Q0.OQQOOCO0Q0);
case O0OCCOQ0Q0.OO00COQ0Q0(O0QCOC00Q0.OCO0OCO0Q0)of
OCQCCQQ0Q0:
OCQ0OC00Q0(OQCQQCOCQ0.Create(Self,O0QCOC00Q0.O0O0OCO0Q0));
OQQCCQQ0Q0:
OCQ0OC00Q0(OQCOCQOCQ0.Create(Self,O0QCOC00Q0.O0O0OCO0Q0));
OOQCCQQ0Q0:
OCQ0OC00Q0(OOCOCQOCQ0.Create(Self,O0QCOC00Q0.O0O0OCO0Q0));
O0QCCQQ0Q0:
OCQ0OC00Q0(O0COCQOCQ0.Create(Self,O0QCOC00Q0.O0O0OCO0Q0));
O0CCCQQ0Q0:
OCQ0OC00Q0(O0CCOOOCQ0.Create(Self,O0QCOC00Q0.O0O0OCO0Q0));
else
Assert(False);
end;
O0Q0OC00Q0;
end;
destructor OOQQOC00Q0.Destroy;
begin
OOOQ0C00Q0;
OQOQ0C00Q0;
OCOCOC00Q0.Free;
OQQCOC00Q0.Free;
OQCCOC00Q0.Free;
OCCCOC00Q0.Free;
OOCCOC00Q0.Free;
OCQQOC00Q0.Free;
inherited;
end;
procedure OOQQOC00Q0.O0Q0OC00Q0;
begin
OQCQOC00Q0:=False;
OQ00OC00Q0:=False;
end;
procedure OOQQOC00Q0.OOQ0OC00Q0(const OQQ0OC00Q0:OOCCCQQ0Q0);
begin
if O000OC00Q0 then begin
if O0C00C00Q0<>OQQ0OC00Q0 then
OOC00C00Q0(OO0O0OQ0Q0,seNotAgreeOnProtocol);
end
else
if OQQ0OC00Q0 in O0QCOC00Q0.OCO0OCO0Q0 then begin
if O0C00C00Q0<>OQQ0OC00Q0 then begin
case OQQ0OC00Q0 of
OCQCCQQ0Q0:
OCQ0OC00Q0(OQCQQCOCQ0.Create(OCOCOC00Q0,O0QCOC00Q0.O0O0OCO0Q0));
OQQCCQQ0Q0:
OCQ0OC00Q0(OQCOCQOCQ0.Create(OCOCOC00Q0,O0QCOC00Q0.O0O0OCO0Q0));
OOQCCQQ0Q0:
OCQ0OC00Q0(OOCOCQOCQ0.Create(OCOCOC00Q0,O0QCOC00Q0.O0O0OCO0Q0));
O0QCCQQ0Q0:
OCQ0OC00Q0(O0COCQOCQ0.Create(OCOCOC00Q0,O0QCOC00Q0.O0O0OCO0Q0));
O0CCCQQ0Q0:
OCQ0OC00Q0(O0CCOOOCQ0.Create(OCOCOC00Q0,O0QCOC00Q0.O0O0OCO0Q0));
else
Assert(False);
end;
end;
end
else
OOC00C00Q0(OO0O0OQ0Q0,seNotAgreeOnProtocol);
end;
procedure OOQQOC00Q0.OCQ0OC00Q0(O0C0OC00Q0:OCOO0C00Q0);
begin
FreeAndNil(OCOCOC00Q0);
OCOCOC00Q0:=O0C0OC00Q0;
OOCCOC00Q0.OCOOQOQ0Q0:=OCOCOC00Q0.O00COQ00Q0;
end;
procedure OOQQOC00Q0.OOC0OC00Q0(OQC0OC00Q0:OQQC0Q00Q0);
var
OCC0OC00Q0:OCQ0O0Q0Q0;
begin
OCC0OC00Q0:=OCOCOC00Q0.O00OCC00Q0(OO0C00Q0Q0[OOCCOC00Q0.OOOOQOQ0Q0],OQC0OC00Q0);
try
if(OQC0OC00Q0=OCOC0Q00Q0)or(OQC0OC00Q0=OOQC0Q00Q0)then begin
OOQCOC00Q0.O00OQ0O0Q0(OCC0OC00Q0.O0C0O0Q0Q0,OCC0OC00Q0.O00OO0Q0Q0,OCC0OC00Q0.OQC0O0Q0Q0);
OCC0OC00Q0.O0C0O0Q0Q0:=nil;
OCC0OC00Q0.OQC0O0Q0Q0:=nil;
end;
if(OQC0OC00Q0=O0QC0Q00Q0)or(OQC0OC00Q0=OOQC0Q00Q0)then begin
OOQCOC00Q0.O0OOQ0O0Q0(OCC0OC00Q0.OOC0O0Q0Q0,OCC0OC00Q0.OO0OO0Q0Q0,OCC0OC00Q0.OCC0O0Q0Q0);
OCC0OC00Q0.OOC0O0Q0Q0:=nil;
OCC0OC00Q0.OCC0O0Q0Q0:=nil;
end;
finally
OCC0OC00Q0.Free;
end;
end;
procedure OOQQOC00Q0.OOOQ0C00Q0;
begin
OCOCOC00Q0.OCO0CC00Q0;
end;
procedure OOQQOC00Q0.OQOQ0C00Q0;
begin
FillChar(O0CCOC00Q0[0],Length(O0CCOC00Q0),0);
FreeAndNil(OQQQOC00Q0);
end;
function OOQQOC00Q0.O00Q0C00Q0(const OO0Q0C00Q0:TBytes;OQ0Q0C00Q0,OC0Q0C00Q0:integer):OCQC00Q0Q0;
var
O0OQ0C00Q0:integer;
begin
Result:=nil;
if(OQ0Q0C00Q0+4)>OC0Q0C00Q0 then
Exit;
O0OQ0C00Q0:=(OO0Q0C00Q0[OQ0Q0C00Q0+1]shl 16)+(OO0Q0C00Q0[OQ0Q0C00Q0+2]shl 8)+OO0Q0C00Q0[OQ0Q0C00Q0+3];
if(OQ0Q0C00Q0+4+O0OQ0C00Q0)>OC0Q0C00Q0 then
Exit;
Result:=OCQC00Q0Q0.Create(OO0Q0C00Q0,OQ0Q0C00Q0);
end;
function OOQQOC00Q0.OCQC0C00Q0(O0CC0C00Q0:OC00C0Q0Q0):O0OQOOQ0Q0;
var
OOCC0C00Q0:OCQC00Q0Q0;
OQCC0C00Q0:TBytes;
OCCC0C00Q0,O0000C00Q0,OO000C00Q0:integer;
OQ000C00Q0:boolean;
begin
if O0CC0C00Q0.OCQ0C0Q0Q0=0 then
OOC00C00Q0(OQC00OQ0Q0,seInvalidMessage);
Result:=O00QOOQ0Q0;
OOQCOC00Q0.OQO0Q0O0Q0;
try
OCCC0C00Q0:=OOCQOC00Q0;
if OCCC0C00Q0>0 then begin
if Length(O0CQOC00Q0)<OOCQOC00Q0+O0CC0C00Q0.OCQ0C0Q0Q0 then
SetLength(O0CQOC00Q0,OOCQOC00Q0+O0CC0C00Q0.OCQ0C0Q0Q0);
Buffer.BlockCopy(O0CC0C00Q0.OCO0C0Q0Q0,O0CC0C00Q0.O0Q0C0Q0Q0,O0CQOC00Q0,OOCQOC00Q0,O0CC0C00Q0.OCQ0C0Q0Q0);
Inc(OOCQOC00Q0,O0CC0C00Q0.OCQ0C0Q0Q0);
OQCC0C00Q0:=O0CQOC00Q0;
O0000C00Q0:=0;
OO000C00Q0:=OOCQOC00Q0;
end
else begin
OQCC0C00Q0:=O0CC0C00Q0.OCO0C0Q0Q0;
O0000C00Q0:=O0CC0C00Q0.O0Q0C0Q0Q0;
OO000C00Q0:=O0CC0C00Q0.O0Q0C0Q0Q0+O0CC0C00Q0.OCQ0C0Q0Q0;
end;
OQ000C00Q0:=True;
OOCC0C00Q0:=O00Q0C00Q0(OQCC0C00Q0,O0000C00Q0,OO000C00Q0);
while OOCC0C00Q0<>nil do begin
try
if((OOCC0C00Q0.OQCCC0Q0Q0 in[OCOQ0OQ0Q0,O0QQ0OQ0Q0,OQQQ0OQ0Q0,OC0C0OQ0Q0])and
((OCCC0C00Q0>0)or not OQ000C00Q0))or
((OOCC0C00Q0.OQCCC0Q0Q0=OQ0C0OQ0Q0)and(OCCC0C00Q0>0))then
OOC00C00Q0(O0000OQ0Q0,seUnexpectedPacketType);
OCOC0C00Q0(OOCC0C00Q0);
OCQCOC00Q0:=OOCC0C00Q0.OQCCC0Q0Q0;
if(OOCC0C00Q0.OQCCC0Q0Q0<>OQOQ0OQ0Q0)and(OOCC0C00Q0.OQCCC0Q0Q0<>OC0C0OQ0Q0)then
OCOCOC00Q0.O0Q0CC00Q0(OOCC0C00Q0);
OOQC0C00Q0(OOCC0C00Q0.OQCCC0Q0Q0);
O0000C00Q0:=O0000C00Q0+(OOCC0C00Q0.OQ00C0Q0Q0-OOCC0C00Q0.O000C0Q0Q0)+4;
finally
OOCC0C00Q0.Free;
end;
OQ000C00Q0:=False;
OOCC0C00Q0:=O00Q0C00Q0(OQCC0C00Q0,O0000C00Q0,OO000C00Q0);
end;
if OO000C00Q0>O0000C00Q0 then begin
Buffer.BlockCopy(OQCC0C00Q0,O0000C00Q0,O0CQOC00Q0,0,OO000C00Q0-O0000C00Q0);
OOCQOC00Q0:=OO000C00Q0-O0000C00Q0;
end
else
OOCQOC00Q0:=0;
finally
OOQCOC00Q0.OCO0Q0O0Q0;
end;
end;
function OOQQOC00Q0.OOO00C00Q0(OQO00C00Q0:OC00C0Q0Q0):O0OQOOQ0Q0;
begin
if(OQO00C00Q0.OCQ0C0Q0Q0<>1)or(OQO00C00Q0.OCO0C0Q0Q0[OQO00C00Q0.O0Q0C0Q0Q0]<>1)then
OOC00C00Q0(OQC00OQ0Q0,seInvalidMessage);
if O0C00C00Q0=OCQCCQQ0Q0 then begin
if(OCQCOC00Q0<>OCOQ0OQ0Q0)and(OCQCOC00Q0<>O0QQ0OQ0Q0)then
OOC00C00Q0(O0000OQ0Q0,seUnexpectedPacketType);
end
else begin
if O0QCOC00Q0.O0O0OCO0Q0=OOOQOOQ0Q0 then begin
if OQ00OC00Q0 then begin
if(OCQCOC00Q0<>O0QQ0OQ0Q0)and(OCQCOC00Q0<>OOQQ0OQ0Q0)then
OOC00C00Q0(O0000OQ0Q0,seUnexpectedPacketType);
end
else
if(OCQCOC00Q0<>OCCQ0OQ0Q0)and(OCQCOC00Q0<>OOQQ0OQ0Q0)then
OOC00C00Q0(O0000OQ0Q0,seUnexpectedPacketType);
end
else begin
if OQ00OC00Q0 then begin
if OCQCOC00Q0<>OCOQ0OQ0Q0 then
OOC00C00Q0(O0000OQ0Q0,seUnexpectedPacketType);
end
else
if OCCCOC00Q0=nil then begin
if OCQCOC00Q0<>OO0C0OQ0Q0 then
OOC00C00Q0(O0000OQ0Q0,seUnexpectedPacketType);
end
else
if OCQCOC00Q0<>O00C0OQ0Q0 then
OOC00C00Q0(O0000OQ0Q0,seUnexpectedPacketType);
end;
if OQQQOC00Q0=nil then
OQQQOC00Q0:=OCOCOC00Q0.O00OCC00Q0(OO0C00Q0Q0[OOCCOC00Q0.OOOOQOQ0Q0],OOQC0Q00Q0);
OOQCOC00Q0.O0OOQ0O0Q0(OQQQOC00Q0.OOC0O0Q0Q0,OQQQOC00Q0.OO0OO0Q0Q0,OQQQOC00Q0.OCC0O0Q0Q0);
OQQQOC00Q0.OOC0O0Q0Q0:=nil;
OQQQOC00Q0.OCC0O0Q0Q0:=nil;
OCQCOC00Q0:=O0QC0OQ0Q0;
end;
Result:=OQ0QOOQ0Q0;
end;
procedure OOQQOC00Q0.OC000C00Q0;
var
O0O00C00Q0:TBytes;
begin
if OQCQOC00Q0 then
Exit;
SetLength(O0O00C00Q0,1);
O0O00C00Q0[0]:=1;
OOQCOC00Q0.OQQOQ0O0Q0(TValueArr(O0O00C00Q0),Length(O0O00C00Q0),OQCOOOQ0Q0);
OQCQOC00Q0:=True;
if O0C00C00Q0<>OCQCCQQ0Q0 then begin
if OQQQOC00Q0=nil then
OQQQOC00Q0:=OCOCOC00Q0.O00OCC00Q0(OO0C00Q0Q0[OOCCOC00Q0.OOOOQOQ0Q0],OOQC0Q00Q0);
OOQCOC00Q0.O00OQ0O0Q0(OQQQOC00Q0.O0C0O0Q0Q0,OQQQOC00Q0.O00OO0Q0Q0,OQQQOC00Q0.OQC0O0Q0Q0);
OQQQOC00Q0.O0C0O0Q0Q0:=nil;
OQQQOC00Q0.OQC0O0Q0Q0:=nil;
end;
end;
function OOQQOC00Q0.OCOQ0C00Q0:boolean;
begin
Result:=(O0C00C00Q0=OCQCCQQ0Q0)and
(O0QCOC00Q0.OQOOOCO0Q0.OOCCQ0Q0Q0(OOC0OQO0Q0)<>nil);
end;
function OOQQOC00Q0.O0QQ0C00Q0:TScCertificate;
begin
if OQCCOC00Q0.Count>0 then
Result:=TScCertificate(OQCCOC00Q0[0])
else
Result:=nil;
end;
procedure OOQQOC00Q0.OOQQ0C00Q0(OQQQ0C00Q0:TCRList);
begin
OQQCOC00Q0.OCQ000Q0Q0(O0CQ0OQ0Q0);
OCOCOC00Q0.OQ0CQC00Q0(OQQCOC00Q0,OQQQ0C00Q0);
OQQCOC00Q0.OOC000Q0Q0;
OCOCOC00Q0.O0Q0CC00Q0(OQQCOC00Q0);
OOQCOC00Q0.O0QOQ0O0Q0(OQQCOC00Q0);
end;
procedure OOQQOC00Q0.OCQQ0C00Q0(O0CQ0C00Q0:TScCertificate);
begin
OQQCOC00Q0.OCQ000Q0Q0(O00C0OQ0Q0);
OCOCOC00Q0.OCCCQC00Q0(OQQCOC00Q0,O0CQ0C00Q0);
OQQCOC00Q0.OOC000Q0Q0;
OCOCOC00Q0.O0Q0CC00Q0(OQQCOC00Q0);
OOQCOC00Q0.O0QOQ0O0Q0(OQQCOC00Q0);
end;
procedure OOQQOC00Q0.O00OOC00Q0(OO0OOC00Q0:OCQC00Q0Q0);
const
OQ0OOC00Q0:TScCertificateStatusSet=[
csOtherError,csExpired];
OC0OOC00Q0:TScCertificateStatusSet=[
csInvalidBasicConstraints,csInvalidKeyUsage];
O0OOOC00Q0:TScCertificateStatusSet=[
csInsecureSignature];
var
OOOOOC00Q0:TScCertificateStatusSet;
OQOOOC00Q0:TScCertificateStatus;
OCOOOC00Q0:boolean;
O0QOOC00Q0:TCRList;
OOQOOC00Q0:integer;
begin
FreeAndNil(OCCCOC00Q0);
O0QOOC00Q0:=TCRList.Create;
try
OCOCOC00Q0.OOQCQC00Q0(OO0OOC00Q0,O0QOOC00Q0);
if O0QOOC00Q0.Count=0 then begin
if O0QCOC00Q0.O0O0OCO0Q0=OOOQOOQ0Q0 then
OOC00C00Q0(OQC00OQ0Q0,sePeerCertificateNotReceived)
else begin
OCCCOC00Q0:=nil;
if Assigned(O0QCOC00Q0.OOQ0OCO0Q0)then begin
OOOOOC00Q0:=[];
O0QCOC00Q0.OOQ0OCO0Q0(Self,nil,O0QOOC00Q0,OOOOOC00Q0);
if OOOOOC00Q0<>[]then
OOC00C00Q0(OQO00OQ0Q0,seCertificateNotValid);
end;
Exit;
end;
end;
OCCCOC00Q0:=TScCertificate(O0QOOC00Q0[0]);
OOCCOC00Q0.O0QOQOQ0Q0:=OCCCOC00Q0;
if OCCCOC00Q0.Key.OQOOOCQ0Q0=OQOQQOQOQ0 then
OOC00C00Q0(OOO00OQ0Q0,seInvalidPublicKeyAlgorithm);
if(OCCCOC00Q0.Key.OQOOOCQ0Q0=OCOQQOQOQ0)and(OCCCOC00Q0.Key.OCOOOCQ0Q0<1024)then
OOC00C00Q0(OQ0O0OQ0Q0,seErrorPublicKeyLength);
if Assigned(O0QCOC00Q0.OCQ0OCO0Q0)then
O0QCOC00Q0.OCQ0OCO0Q0(OCOOOC00Q0)
else
OCOOOC00Q0:=True;
if not OCOOOC00Q0 or O0QCOC00Q0.OQ0OOCO0Q0 then
Exit;
OC0COC00Q0(O0QOOC00Q0,OOOOOC00Q0);
if OOOOOC00Q0<>[]then begin
for OQOOOC00Q0:=High(TScCertificateStatus)downto Low(TScCertificateStatus)do
if(OQOOOC00Q0<>csValid)and(OQOOOC00Q0 in OOOOOC00Q0)then begin
if O0QCOC00Q0.OQC0OCO0Q0 and(OQOOOC00Q0 in OQ0OOC00Q0)then
else
if O0QCOC00Q0.OCC0OCO0Q0 and(OQOOOC00Q0 in OC0OOC00Q0)then
else
if O0QCOC00Q0.O00OOCO0Q0 and(OQOOOC00Q0 in O0OOOC00Q0)then
else
OOC00C00Q0(OQO00OQ0Q0,OOCQ0QQ0Q0[OQOOOC00Q0]);
end;
end;
finally
if OCCCOC00Q0<>nil then
O0QOOC00Q0.Remove(OCCCOC00Q0);
for OOQOOC00Q0:=0 to O0QOOC00Q0.Count-1 do
{$IFNDEF AUTOREFCOUNT}
TScCertificate(O0QOOC00Q0[OOQOOC00Q0]).Free;
{$ELSE}
O0QOOC00Q0[OOQOOC00Q0]:=nil;
{$ENDIF}
O0QOOC00Q0.Free;
end;
end;
procedure OOQQOC00Q0.OC0COC00Q0(O0OCOC00Q0:TCRList;out OOOCOC00Q0:TScCertificateStatusSet);
begin
if O0OCOC00Q0.Count=0 then
OOC00C00Q0(OOO00OQ0Q0,seCertificateNotExists);
O0QCOC00Q0.O0OOOCO0Q0:=True;
O0QCOC00Q0.OC0OOCO0Q0:=OO0COC00Q0;
OOOCOC00Q0:=OCQC0Q00Q0.OQ000Q00Q0(O0OCOC00Q0,O0QCOC00Q0);
end;
function OOQQOC00Q0.OO0COC00Q0:string;
var
OQ0COC00Q0:OQOQCCO0Q0;
begin
OQ0COC00Q0:=OQOQCCO0Q0(O0QCOC00Q0.OQOOOCO0Q0.OOCCQ0Q0Q0(OQOQCCO0Q0));
if(OQ0COC00Q0<>nil)and(OQ0COC00Q0.O0CQCCO0Q0.Count>0)then
Result:=OQ0COC00Q0.O0CQCCO0Q0[OQ0COC00Q0.O0CQCCO0Q0.Count-1]
else
Result:='';
end;
procedure OOQQOC00Q0.OQQOOC00Q0(OCQOOC00Q0:OCQC00Q0Q0);
begin
OCOCOC00Q0.OCC0QC00Q0(OCQOOC00Q0,OCCCOC00Q0);
end;
procedure OOQQOC00Q0.OCO00C00Q0;
var
O0Q00C00Q0:O00O0CO0Q0;
begin
OQQCOC00Q0.OCQ000Q0Q0(OQ0C0OQ0Q0);
OCOCOC00Q0.OOOOQC00Q0(OQQCOC00Q0);
OQQCOC00Q0.OOC000Q0Q0;
if O0QCOC00Q0.O0O0OCO0Q0=OOOQOOQ0Q0 then begin
O0Q00C00Q0:=O00O0CO0Q0(O0QCOC00Q0.OQOOOCO0Q0.OOCCQ0Q0Q0(O00O0CO0Q0));
if O0Q00C00Q0<>nil then
O0Q00C00Q0.OOCO0CO0Q0(OQQCOC00Q0.OCCCC0Q0Q0,
OQQCOC00Q0.O000C0Q0Q0,OQQCOC00Q0.OQ00C0Q0Q0-OQQCOC00Q0.O000C0Q0Q0);
end
else begin
O0Q00C00Q0:=O00O0CO0Q0(O0QCOC00Q0.OCOOOCO0Q0.OOCCQ0Q0Q0(O00O0CO0Q0));
if O0Q00C00Q0<>nil then
O0Q00C00Q0.OO0QCCO0Q0(OQQCOC00Q0.OCCCC0Q0Q0,
OQQCOC00Q0.O000C0Q0Q0,OQQCOC00Q0.OQ00C0Q0Q0-OQQCOC00Q0.O000C0Q0Q0);
end;
OCOCOC00Q0.O0Q0CC00Q0(OQQCOC00Q0);
OOQCOC00Q0.O0QOQ0O0Q0(OQQCOC00Q0);
OO00OC00Q0:=True;
OQCQOC00Q0:=False;
end;
class function OOQQOC00Q0.OQO0OC00Q0:TBytes;
var
OCO0OC00Q0:cardinal;
begin
OCO0OC00Q0:=OCO0OCOOQ0;
Result:=BitConverter.GetBytes(OCO0OC00Q0);
if BitConverter.IsLittleEndian then
ArrayReverse(Result,0,Length(Result));
end;
procedure OOQQOC00Q0.O00COC00Q0(O0COC0O0Q0:boolean);
begin
if OCCQOC00Q0<>O0COC0O0Q0 then begin
OCCQOC00Q0:=O0COC0O0Q0;
if OCCQOC00Q0 then
OOQCOC00Q0.OOOOC0O0Q0.ResetEvent
else
OOQCOC00Q0.OOOOC0O0Q0.SetEvent;
end;
end;
procedure OOQQOC00Q0.OOC00C00Q0(OQC00C00Q0:OQCO0OQ0Q0;OCC00C00Q0:TScErrorCode);
var
O00O0C00Q0:TBytes;
OO0O0C00Q0:boolean;
begin
SetLength(O00O0C00Q0,2);
OO0O0C00Q0:=not(OQC00C00Q0 in OO0QCOQ0Q0);
if OO0O0C00Q0 then
O00O0C00Q0[0]:=OCCO0OQ0Q0[OOCC0OQ0Q0]
else
O00O0C00Q0[0]:=OCCO0OQ0Q0[O0CC0OQ0Q0];
O00O0C00Q0[1]:=O00QCOQ0Q0[OQC00C00Q0];
OOQCOC00Q0.OQQOQ0O0Q0(TValueArr(O00O0C00Q0),Length(O00O0C00Q0),OCCOOOQ0Q0);
raise OQQCOQ00Q0.Create(OCC00C00Q0);
end;
function OOQQOC00Q0.O0COOC00Q0(OOCOOC00Q0:OC00C0Q0Q0):O0OQOOQ0Q0;
var
OQCOOC00Q0,OCCOOC00Q0:byte;
begin
if OOCOOC00Q0.OCQ0C0Q0Q0<>2 then
OOC00C00Q0(OQC00OQ0Q0,seInvalidMessage);
OQCOOC00Q0:=OOCOOC00Q0.OCO0C0Q0Q0[OOCOOC00Q0.O0Q0C0Q0Q0];
OCCOOC00Q0:=OOCOOC00Q0.OCO0C0Q0Q0[OOCOOC00Q0.O0Q0C0Q0Q0+1];
if OQCOOC00Q0=OCCO0OQ0Q0[OOCC0OQ0Q0]then
raise EScError.CreateFmt(SFailureAlert,[OCCOOC00Q0],seFailureAlert);
if OCCOOC00Q0=O00QCOQ0Q0[OCCC0OQ0Q0]then begin
OCQQOC00Q0.Enter;
try
if OCQCOC00Q0 in[OOOC0OQ0Q0,OCOC0OQ0Q0]then
OCQCOC00Q0:=OCOC0OQ0Q0
else begin
OCQCOC00Q0:=OQOC0OQ0Q0;
OOOC0C00Q0;
end;
finally
OCQQOC00Q0.Leave;
end;
Result:=OC0QOOQ0Q0;
end
else
Result:=O00QOOQ0Q0;
end;
procedure OOQQOC00Q0.OOOC0C00Q0;
var
OQOC0C00Q0:TBytes;
begin
OCQQOC00Q0.Enter;
try
if OCQCOC00Q0 in[OOOC0OQ0Q0,OCOC0OQ0Q0]then
Exit
else
if OCQCOC00Q0=OQOC0OQ0Q0 then
OCQCOC00Q0:=OCOC0OQ0Q0
else
OCQCOC00Q0:=OOOC0OQ0Q0;
finally
OCQQOC00Q0.Leave;
end;
SetLength(OQOC0C00Q0,2);
OQOC0C00Q0[0]:=OCCO0OQ0Q0[O0CC0OQ0Q0];
OQOC0C00Q0[1]:=O00QCOQ0Q0[OCCC0OQ0Q0];
OOQCOC00Q0.OQQOQ0O0Q0(TValueArr(OQOC0C00Q0),Length(OQOC0C00Q0),OCCOOOQ0Q0);
end;
procedure OOQQOC00Q0.OCCQ0C00Q0;
begin
if O0OO0C00Q0 then
Exit;
if OOO0OC00Q0 then
Exit;
if O0C00C00Q0=OCQCCQQ0Q0 then
O00C0C00Q0(OQCQCOQ0Q0)
else
OQCQ0C00Q0;
OOO0OC00Q0:=True;
end;
procedure OOQQOC00Q0.O00C0C00Q0(OO0C0C00Q0:OCCQCOQ0Q0);
begin
OQQCOC00Q0.OCQ000Q0Q0(OC0C0OQ0Q0);
OQQCOC00Q0.OCQO00Q0Q0(O00CCOQ0Q0[OO0C0C00Q0]);
OQQCOC00Q0.OOC000Q0Q0;
OOQCOC00Q0.O0QOQ0O0Q0(OQQCOC00Q0);
if O0QCOC00Q0.O0O0OCO0Q0=OOOQOOQ0Q0 then
OCOCOC00Q0.OQQOCC00Q0
else
OCOCOC00Q0.OCQOCC00Q0;
OOC0OC00Q0(OCOC0Q00Q0);
end;
procedure OOQQOC00Q0.OQ0C0C00Q0(OC0C0C00Q0:OCQC00Q0Q0);
var
O0OC0C00Q0:byte;
begin
if OC0C0C00Q0.OOCCC0Q0Q0<>1 then
OOC00C00Q0(OQC00OQ0Q0,seInvalidMessage);
OOO0OC00Q0:=False;
O0OC0C00Q0:=OC0C0C00Q0.O00CC0Q0Q0;
if O0OC0C00Q0=O00CCOQ0Q0[OOCQCOQ0Q0]then
O0O0OC00Q0:=OOCQCOQ0Q0
else
if O0OC0C00Q0=O00CCOQ0Q0[OQCQCOQ0Q0]then
O0O0OC00Q0:=OQCQCOQ0Q0
else
OOC00C00Q0(OCQ00OQ0Q0,seInvalidMessage);
if O0QCOC00Q0.O0O0OCO0Q0=OOOQOOQ0Q0 then
OCOCOC00Q0.OCQOCC00Q0
else
OCOCOC00Q0.OQQOCC00Q0;
OOC0OC00Q0(O0QC0Q00Q0);
end;
function OOQQOC00Q0.O0C00C00Q0:OOCCCQQ0Q0;
begin
Result:=OCOCOC00Q0.O00COQ00Q0;
end;
constructor OCOO0C00Q0.Create(OC00CC00Q0:OOQQOC00Q0;O0O0CC00Q0:OCOQOOQ0Q0);
begin
inherited Create;
O0QO0C00Q0:=OC00CC00Q0;
OOQO0C00Q0:=O0O0CC00Q0;
end;
constructor OCOO0C00Q0.Create(OOO0CC00Q0:OCOO0C00Q0;O0O0CC00Q0:OCOQOOQ0Q0);
begin
if OOO0CC00Q0=nil then
raise EScError.Create(seInvalidInputArgs);
Create(OOO0CC00Q0.O0QO0C00Q0,O0O0CC00Q0);
OQQO0C00Q0:=OOO0CC00Q0.OQQO0C00Q0;
OOO0CC00Q0.OQQO0C00Q0:=nil;
OCQO0C00Q0:=OOO0CC00Q0.OCQO0C00Q0;
OQCO0C00Q0:=OOO0CC00Q0.OQCO0C00Q0;
OOO0CC00Q0.OQCO0C00Q0:=nil;
end;
destructor OCOO0C00Q0.Destroy;
begin
OCO0CC00Q0;
OCCO0C00Q0.Free;
inherited;
end;
function OCOO0C00Q0.O00QCC00Q0:OC0QQQQ0Q0;
begin
Result:=O0QO0C00Q0.OOCCOC00Q0.OOOOQOQ0Q0;
end;
procedure OCOO0C00Q0.OCO0CC00Q0;
begin
if Length(OQQO0C00Q0)>0 then
FillChar(OQQO0C00Q0[0],OCQO0C00Q0,0);
OCQO0C00Q0:=0;
if Length(OQCO0C00Q0)>0 then begin
FillChar(OQCO0C00Q0[0],Length(OQCO0C00Q0),0);
SetLength(OQCO0C00Q0,0);
end;
end;
procedure OCOO0C00Q0.OO0QCC00Q0(const OQ0QCC00Q0:TBytes);
begin
SetLength(OQCO0C00Q0,Length(OQ0QCC00Q0));
if Length(OQ0QCC00Q0)>0 then
Move(OQ0QCC00Q0[0],OQCO0C00Q0[0],Length(OQ0QCC00Q0));
end;
procedure OCOO0C00Q0.O0Q0CC00Q0(OOQ0CC00Q0:OCQC00Q0Q0);
begin
O0Q0CC00Q0(OOQ0CC00Q0.OCCCC0Q0Q0,OOQ0CC00Q0.O000C0Q0Q0-OCOC00Q0Q0,
OOQ0CC00Q0.OQ00C0Q0Q0-OOQ0CC00Q0.O000C0Q0Q0+OCOC00Q0Q0);
end;
procedure OCOO0C00Q0.O0Q0CC00Q0(const OQQ0CC00Q0:TBytes;OCQ0CC00Q0,O0C0CC00Q0:integer);
var
OOC0CC00Q0:integer;
begin
if O0C0CC00Q0=0 then
Exit;
OOC0CC00Q0:=Length(OQQO0C00Q0);
if(OCQO0C00Q0+O0C0CC00Q0)>OOC0CC00Q0 then begin
if OOC0CC00Q0=0 then
OOC0CC00Q0:=OOQC00Q0Q0
else
OOC0CC00Q0:=OOC0CC00Q0+OOC0CC00Q0 div 2;
if(OCQO0C00Q0+O0C0CC00Q0)>OOC0CC00Q0 then
SetLength(OQQO0C00Q0,OCQO0C00Q0+O0C0CC00Q0)
else
SetLength(OQQO0C00Q0,OOC0CC00Q0);
end;
Move(OQQ0CC00Q0[OCQ0CC00Q0],OQQO0C00Q0[OCQO0C00Q0],O0C0CC00Q0);
Inc(OCQO0C00Q0,O0C0CC00Q0);
end;
function OCOO0C00Q0.OQC0CC00Q0:TBytes;
begin
if OCCO0C00Q0=nil then
OCCO0C00Q0:=OCCQOQ00Q0;
if O0CO0C00Q0<>OCQO0C00Q0 then begin
OOCO0C00Q0:=OCCO0C00Q0.ComputeHash(TValueArr(OQQO0C00Q0),0,OCQO0C00Q0);
O0CO0C00Q0:=OCQO0C00Q0;
end;
Result:=OOCO0C00Q0;
end;
procedure OCOO0C00Q0.OCC0CC00Q0;
begin
end;
procedure OCOO0C00Q0.OC0OCC00Q0;
begin
end;
procedure OCOO0C00Q0.O0OOCC00Q0(const OOOOCC00Q0:TBytes);
begin
end;
procedure OCOO0C00Q0.OQOOCC00Q0(const OCOOCC00Q0:TBytes);
begin
end;
procedure OCOO0C00Q0.O0QOCC00Q0;
begin
end;
procedure OCOO0C00Q0.OOQOCC00Q0;
begin
end;
procedure OCOO0C00Q0.OQQOCC00Q0;
begin
end;
procedure OCOO0C00Q0.OCQOCC00Q0;
begin
end;
procedure OCOO0C00Q0.O0COCC00Q0(const OOCOCC00Q0:TBytes);
begin
if O0QO0C00Q0.OC00OC00Q0 then
O0COCC00Q0(OOCOCC00Q0,OQC0CC00Q0(),OQCO0Q00Q0)
else
O0COCC00Q0(OOCOCC00Q0,O0QO0C00Q0.OOOO0C00Q0,OOCO0Q00Q0);
if(O0QO0C00Q0.OQ0O0C00Q0.OCOOOCO0Q0.OOCCQ0Q0Q0(OQCCCCO0Q0)<>nil)or
(Length(O0QO0C00Q0.OC0O0C00Q0.OQQOQOQ0Q0)>0)
then
O0QO0C00Q0.OC0O0C00Q0.OCQOQOQ0Q0:=OQCO0C00Q0;
end;
procedure OCOO0C00Q0.OQ0CQC00Q0(OC0CQC00Q0:OCQC00Q0Q0;
O0OCQC00Q0:TCRList);
var
OOOCQC00Q0:TScCertificate;
OQOCQC00Q0:TBytes;
OCOCQC00Q0:integer;
O0QCQC00Q0:integer;
begin
if O0OCQC00Q0=nil then begin
OC0CQC00Q0.OOOQC0Q0Q0(0);
Exit;
end;
OCOCQC00Q0:=OC0CQC00Q0.OQ00C0Q0Q0;
OC0CQC00Q0.OQCQC0Q0Q0(3);
SetLength(OQOCQC00Q0,0);
for O0QCQC00Q0:=0 to O0OCQC00Q0.Count-1 do begin
OOOCQC00Q0:=TScCertificate(O0OCQC00Q0[O0QCQC00Q0]);
if OOOCQC00Q0=nil then
Continue;
OQOCQC00Q0:=OOOCQC00Q0.GetRawData;
OC0CQC00Q0.O0QO00Q0Q0(OQOCQC00Q0);
end;
OC0CQC00Q0.OCOQC0Q0Q0(OC0CQC00Q0.OQ00C0Q0Q0-OCOCQC00Q0-3,OCOCQC00Q0);
end;
procedure OCOO0C00Q0.OOQCQC00Q0(OQQCQC00Q0:OCQC00Q0Q0;OCQCQC00Q0:TCRList);
var
O0CCQC00Q0:TMemoryStream;
OOCCQC00Q0:TScCertificate;
OQCCQC00Q0:integer;
begin
OQCCQC00Q0:=OQQCQC00Q0.OQ0CC0Q0Q0;
if OQCCQC00Q0>OQQCQC00Q0.OOCCC0Q0Q0 then
O0QO0C00Q0.OOC00C00Q0(OQC00OQ0Q0,seInvalidMessage);
O0CCQC00Q0:=TMemoryStream.Create;
try
while OQQCQC00Q0.OOCCC0Q0Q0>0 do begin
OQCCQC00Q0:=OQQCQC00Q0.OQ0CC0Q0Q0;
if OQCCQC00Q0>OQQCQC00Q0.OOCCC0Q0Q0 then
O0QO0C00Q0.OOC00C00Q0(OQC00OQ0Q0,seInvalidMessage);
O0CCQC00Q0.Position:=0;
O0CCQC00Q0.WriteBuffer(OQQCQC00Q0.OCCCC0Q0Q0[OQQCQC00Q0.OO00C0Q0Q0],OQCCQC00Q0);
OQQCQC00Q0.OCQCC0Q0Q0(OQCCQC00Q0);
O0CCQC00Q0.Size:=OQCCQC00Q0;
O0CCQC00Q0.Position:=0;
OOCCQC00Q0:=TScCertificate.Create(nil);
try
OOCCQC00Q0.ImportFrom(O0CCQC00Q0);
OOCCQC00Q0.CertName:=IntToStr(OCQCQC00Q0.Count);
OCQCQC00Q0.Add(OOCCQC00Q0);
except
OOCCQC00Q0.Free;
O0QO0C00Q0.OOC00C00Q0(OQC00OQ0Q0,seInvalidMessage);
end;
end;
finally
O0CCQC00Q0.Free;
end;
end;
procedure OCOO0C00Q0.OCCCQC00Q0(O000QC00Q0:OCQC00Q0Q0;
OO00QC00Q0:TScCertificate);
var
OQ00QC00Q0:OCOCO0Q0Q0;
OC00QC00Q0:TBytes;
begin
if OO00QC00Q0=nil then
raise EScError.Create(seInvalidInputArgs);
OQ00QC00Q0:=OCOCO0Q0Q0.Create;
try
OQ00QC00Q0.OOQ0O0Q0Q0:=O00COQ00Q0;
OQ00QC00Q0.OQQ0O0Q0Q0:=OQCO0C00Q0;
OQ00QC00Q0.TransformFinalBlock(OQQO0C00Q0,0,OCQO0C00Q0);
OC00QC00Q0:=OO00QC00Q0.Sign(OQ00QC00Q0.Hash,O0C0COQOQ0);
O000QC00Q0.OOOO00Q0Q0(OC00QC00Q0);
finally
OQ00QC00Q0.Free;
end;
end;
procedure OCOO0C00Q0.OCC0QC00Q0(O00OQC00Q0:OCQC00Q0Q0;
OO0OQC00Q0:TScCertificate);
var
OQ0OQC00Q0:OCOCO0Q0Q0;
OC0OQC00Q0:TBytes;
O0OOQC00Q0:integer;
begin
if OO0OQC00Q0=nil then
O0QO0C00Q0.OOC00C00Q0(OOO00OQ0Q0,seServerCertificateNotReceived);
O0OOQC00Q0:=O00OQC00Q0.OO0CC0Q0Q0;
OC0OQC00Q0:=O00OQC00Q0.OOOCC0Q0Q0(O0OOQC00Q0);
OQ0OQC00Q0:=OCOCO0Q0Q0.Create;
try
OQ0OQC00Q0.OOQ0O0Q0Q0:=O00COQ00Q0;
OQ0OQC00Q0.OQQ0O0Q0Q0:=OQCO0C00Q0;
OQ0OQC00Q0.TransformFinalBlock(OQQO0C00Q0,0,OCQO0C00Q0);
if not OO0OQC00Q0.VerifyHashSign(OQ0OQC00Q0.Hash,OC0OQC00Q0,O0C0COQOQ0)then
O0QO0C00Q0.OOC00C00Q0(OCC00OQ0Q0,seHashVerificationNotCorrespond);
finally
OQ0OQC00Q0.Free;
end;
end;
procedure OCOO0C00Q0.O0O0QC00Q0(OOO0QC00Q0:OCQC00Q0Q0;
OQO0QC00Q0:TScCertificate);
var
OCO0QC00Q0:THashAlgorithm;
O0Q0QC00Q0:TBytes;
begin
if OQO0QC00Q0=nil then
O0QO0C00Q0.OOC00C00Q0(OOO00OQ0Q0,seServerCertificateNotSpecified);
OCO0QC00Q0:=OCOCO0Q0Q0.Create;
try
OCO0QC00Q0.TransformBlock(O0QO0C00Q0.OOOO0C00Q0,0,64);
OCO0QC00Q0.TransformFinalBlock(OOO0QC00Q0.OCCCC0Q0Q0,OOO0QC00Q0.O000C0Q0Q0,OOO0QC00Q0.OQ00C0Q0Q0-OOO0QC00Q0.O000C0Q0Q0);
O0Q0QC00Q0:=OQO0QC00Q0.Sign(OCO0QC00Q0.Hash,O0C0COQOQ0);
OOO0QC00Q0.OOOO00Q0Q0(O0Q0QC00Q0);
finally
OCO0QC00Q0.Free;
end;
end;
procedure OCOO0C00Q0.OOQ0QC00Q0(OQQ0QC00Q0:OCQC00Q0Q0;
OCQ0QC00Q0:TScCertificate);
var
O0C0QC00Q0:THashAlgorithm;
OOC0QC00Q0:TBytes;
OQC0QC00Q0:integer;
begin
if OCQ0QC00Q0=nil then
O0QO0C00Q0.OOC00C00Q0(OOO00OQ0Q0,seServerCertificateNotReceived);
O0C0QC00Q0:=OCOCO0Q0Q0.Create;
try
O0C0QC00Q0.TransformBlock(O0QO0C00Q0.OOOO0C00Q0,0,64);
O0C0QC00Q0.TransformFinalBlock(OQQ0QC00Q0.OCCCC0Q0Q0,OQQ0QC00Q0.O000C0Q0Q0,OQQ0QC00Q0.OO00C0Q0Q0-OQQ0QC00Q0.O000C0Q0Q0);
OQC0QC00Q0:=OQQ0QC00Q0.OO0CC0Q0Q0;
OOC0QC00Q0:=OQQ0QC00Q0.OOOCC0Q0Q0(OQC0QC00Q0);
if not OCQ0QC00Q0.VerifySign(O0C0QC00Q0.Hash,OOC0QC00Q0,O0C0COQOQ0)then
O0QO0C00Q0.OOC00C00Q0(OCC00OQ0Q0,seHashVerificationNotCorrespond);
finally
O0C0QC00Q0.Free;
end;
end;
procedure OCOO0C00Q0.O00QQC00Q0(OO0QQC00Q0:OCQC00Q0Q0;
OQ0QQC00Q0:OC0Q00OOQ0);
var
OC0QQC00Q0:OQOCO0OOQ0;
O0OQQC00Q0:TBytes;
OOOQQC00Q0:integer;
OQOQQC00Q0:integer;
begin
OO0QQC00Q0.OCQO00Q0Q0(2);
OO0QQC00Q0.OCQO00Q0Q0(OC0QCOQ0Q0);
OO0QQC00Q0.OCQO00Q0Q0(OQQQCOQ0Q0);
OQCQQC00Q0(OO0QQC00Q0);
if OQ0QQC00Q0=nil then begin
OO0QQC00Q0.O00QC0Q0Q0(0);
Exit;
end;
OOOQQC00Q0:=OO0QQC00Q0.OQ00C0Q0Q0;
OO0QQC00Q0.OQCQC0Q0Q0(2);
SetLength(O0OQQC00Q0,0);
for OQOQQC00Q0:=0 to OQ0QQC00Q0.OOO000QOQ0-1 do begin
OC0QQC00Q0:=OQOCO0OOQ0(OQ0QQC00Q0[OQOQQC00Q0]);
if OC0QQC00Q0=nil then
continue;
O0OQQC00Q0:=OC0QQC00Q0.OO0OO0OOQ0;
OO0QQC00Q0.OOOO00Q0Q0(O0OQQC00Q0);
end;
OO0QQC00Q0.OQ0QC0Q0Q0(OO0QQC00Q0.OQ00C0Q0Q0-OOOQQC00Q0-2,OOOQQC00Q0);
end;
function OCOO0C00Q0.OCOQQC00Q0(O0QQQC00Q0:OCQC00Q0Q0):OC0Q00OOQ0;
var
OOQQQC00Q0:OQOCO0OOQ0;
OQQQQC00Q0:boolean;
OCQQQC00Q0,O0CQQC00Q0:integer;
OOCQQC00Q0:integer;
begin
OQQQQC00Q0:=False;
OCQQQC00Q0:=O0QQQC00Q0.O00CC0Q0Q0;
for OOCQQC00Q0:=1 to OCQQQC00Q0 do begin
if O0QQQC00Q0.O00CC0Q0Q0 in[OC0QCOQ0Q0,OQQQCOQ0Q0]then
OQQQQC00Q0:=True;
end;
O00CQC00Q0(O0QQQC00Q0);
Result:=OC0Q00OOQ0.Create;
try
if O0QQQC00Q0.OOCCC0Q0Q0=0 then
Exit;
O0CQQC00Q0:=O0QQQC00Q0.OO0CC0Q0Q0;
while O0CQQC00Q0>0 do begin
OCQQQC00Q0:=O0QQQC00Q0.OO0CC0Q0Q0;
if OCQQQC00Q0=0 then
Break;
if OCQQQC00Q0>O0QQQC00Q0.OOCCC0Q0Q0 then
O0QO0C00Q0.OOC00C00Q0(OQC00OQ0Q0,seInvalidMessage);
OOQQQC00Q0:=OQOCO0OOQ0.Create;
Result.OOQC00QOQ0(OOQQQC00Q0);
OOQQQC00Q0.OOC0O0OOQ0(O0QQQC00Q0.OCCCC0Q0Q0,O0QQQC00Q0.OO00C0Q0Q0,OCQQQC00Q0);
O0QQQC00Q0.OCQCC0Q0Q0(OCQQQC00Q0);
Dec(O0CQQC00Q0,OCQQQC00Q0+2);
end;
if not OQQQQC00Q0 then
FreeAndNil(Result);
except
Result.Free;
O0QO0C00Q0.OOC00C00Q0(OQC00OQ0Q0,seInvalidMessage);
end;
end;
procedure OCOO0C00Q0.OQCQQC00Q0(OCCQQC00Q0:OCQC00Q0Q0);
begin
end;
procedure OCOO0C00Q0.O00CQC00Q0(OO0CQC00Q0:OCQC00Q0Q0);
begin
end;
procedure OCOO0C00Q0.OC0QCC00Q0(out O0OQCC00Q0,OOOQCC00Q0:TBytes);
var
OQOQCC00Q0:cardinal;
begin
if Assigned(O0QO0C00Q0.OQ0O0C00Q0.OCOQ0CO0Q0)then
O0QO0C00Q0.OQ0O0C00Q0.OCOQ0CO0Q0(Self,O0OQCC00Q0,OOOQCC00Q0)
else begin
OQQO0Q00Q0.Enter;
try
OQOQCC00Q0:=OCO0OCOOQ0-OOQO0Q00Q0;
if(OQOQCC00Q0>SecsPerDay)or(Length(OQOO0Q00Q0)=0)then begin
OCOO0Q00Q0:=OOOO0Q00Q0;
O0QO0Q00Q0:=OQOO0Q00Q0;
OOOO0Q00Q0:=nil;
OQOO0Q00Q0:=nil;
SetLength(OOOO0Q00Q0,16);
OCCQ0QQ0Q0.Random(OOOO0Q00Q0,0,Length(OOOO0Q00Q0));
SetLength(OQOO0Q00Q0,16);
OCCQ0QQ0Q0.Random(OQOO0Q00Q0,0,Length(OQOO0Q00Q0));
end;
finally
OQQO0Q00Q0.Leave;
end;
O0OQCC00Q0:=OOOO0Q00Q0;
OOOQCC00Q0:=OQOO0Q00Q0;
end;
end;
procedure OCOO0C00Q0.OCOQCC00Q0(const O0QQCC00Q0:TBytes;out OOQQCC00Q0:TBytes);
begin
if Assigned(O0QO0C00Q0.OQ0O0C00Q0.O0QQ0CO0Q0)then
O0QO0C00Q0.OQ0O0C00Q0.O0QQ0CO0Q0(Self,O0QQCC00Q0,OOQQCC00Q0)
else begin
if(Length(OOOO0Q00Q0)>0)and(Length(O0QQCC00Q0)>=Length(OOOO0Q00Q0))and
(MemCompare(@O0QQCC00Q0[0],@OOOO0Q00Q0[0],Length(OOOO0Q00Q0))=0)then
OOQQCC00Q0:=OQOO0Q00Q0
else
if(Length(OCOO0Q00Q0)>0)and(Length(O0QQCC00Q0)>=Length(OCOO0Q00Q0))and
(MemCompare(@O0QQCC00Q0[0],@OCOO0Q00Q0[0],Length(OCOO0Q00Q0))=0)then
OOQQCC00Q0:=O0QO0Q00Q0
else
SetLength(OOQQCC00Q0,0);
end;
end;
function OCOO0C00Q0.OQQQCC00Q0(
OCQQCC00Q0:OQCCQOQ0Q0):OQQ0Q0Q0Q0;
var
O0CQCC00Q0:OQQ0Q0Q0Q0;
OOCQCC00Q0,OQCQCC00Q0,OCCQCC00Q0:TBytes;
O00CCC00Q0:TBytes;
OO0CCC00Q0:integer;
OQ0CCC00Q0:TSymmetricAlgorithm;
OC0CCC00Q0:THMAC;
begin
{$IFNDEF VER25P}
Result:=nil;
{$ENDIF}
O0CQCC00Q0:=OQQ0Q0Q0Q0.Create;
try
O0CQCC00Q0.OQQQQOQ0Q0:=OCO0OCOOQ0;
O0CQCC00Q0.OCQQQOQ0Q0:=O0QO0C00Q0.OQ0O0C00Q0.OC0Q0CO0Q0;
OCCQ0QQ0Q0.Random(@O0CQCC00Q0.O0CQQOQ0Q0,4);
SetLength(OOCQCC00Q0,8);
OOCQCC00Q0[7]:=byte(OCQQCC00Q0.OCCOQOQ0Q0);
OCQQCC00Q0.OCCOQOQ0Q0:=OCQQCC00Q0.OCCOQOQ0Q0+1;
O0CQCC00Q0.OOCQQOQ0Q0:=OOCQCC00Q0;
if Assigned(O0QO0C00Q0.OQ0O0C00Q0.OOQQ0CO0Q0)then begin
O0QO0C00Q0.OQ0O0C00Q0.OOQQ0CO0Q0(Self,OCQQCC00Q0,O0CQCC00Q0);
end
else begin
SetLength(O00CCC00Q0,192);
OC0QCC00Q0(OQCQCC00Q0,OCCQCC00Q0);
if Length(OQCQCC00Q0)<>16 then
raise EScError.Create(seInternalError);
Move(OQCQCC00Q0[0],O00CCC00Q0[0],16);
OCCQ0QQ0Q0.Random(O00CCC00Q0,16,16);
Move(O0CQCC00Q0.OQQQQOQ0Q0,O00CCC00Q0[32],4);
Move(O0CQCC00Q0.O0CQQOQ0Q0,O00CCC00Q0[36],4);
Move(O0CQCC00Q0.OOCQQOQ0Q0[0],O00CCC00Q0[40],8);
O00CCC00Q0[48]:=byte(O00COQ00Q0);
OC0OO0Q0Q0.OOQOO0Q0Q0(OCQQCC00Q0.OOOOQOQ0Q0,O00CCC00Q0,49);
if OCQQCC00Q0.OQOOQOQ0Q0=O00QO0QOQ0 then
O00CCC00Q0[51]:=1
else
O00CCC00Q0[51]:=0;
OO0CCC00Q0:=Length(OCQQCC00Q0.OQQOQOQ0Q0);
O00CCC00Q0[52]:=OO0CCC00Q0;
if(OO0CCC00Q0>0)and(OO0CCC00Q0<=32)then
Move(OCQQCC00Q0.OQQOQOQ0Q0[0],O00CCC00Q0[53],OO0CCC00Q0);
OO0CCC00Q0:=Length(OCQQCC00Q0.OCQOQOQ0Q0);
O00CCC00Q0[85]:=OO0CCC00Q0;
if(OO0CCC00Q0>0)and(OO0CCC00Q0<=48)then
Move(OCQQCC00Q0.OCQOQOQ0Q0[0],O00CCC00Q0[86],OO0CCC00Q0);
OCCQ0QQ0Q0.Random(O00CCC00Q0,134,26);
OQ0CCC00Q0:=TCipher_Rijndael.Create;
try
OQ0CCC00Q0.Mode:=cmCBC;
OQ0CCC00Q0.Key:=OCCQCC00Q0;
OQ0CCC00Q0.SetIV(TValueArr(O00CCC00Q0),16,16);
OQ0CCC00Q0.EncodeBuffer(TValueArr(O00CCC00Q0),32,160-32,TValueArr(O00CCC00Q0),32);
finally
OQ0CCC00Q0.Free;
end;
OC0CCC00Q0:=THMAC.Create(THash_SHA2_256,OCCQCC00Q0);
try
OC0CCC00Q0.ComputeHash(TValueArr(O00CCC00Q0),0,160);
Move(OC0CCC00Q0.Hash[0],O00CCC00Q0[160],32);
finally
OC0CCC00Q0.Free;
end;
O0CQCC00Q0.OQCQQOQ0Q0:=O00CCC00Q0;
end;
Result:=O0CQCC00Q0;
O0CQCC00Q0:=nil;
finally
O0CQCC00Q0.Free;
end;
end;
function OCOO0C00Q0.O0OCCC00Q0(
OOOCCC00Q0:O00QQOQ0Q0;OQOCCC00Q0:OQCCQOQ0Q0):boolean;
var
OCOCCC00Q0,O0QCCC00Q0:TBytes;
OOQCCC00Q0,OQQCCC00Q0,OCQCCC00Q0:TBytes;
O0CCCC00Q0:integer;
OOCCCC00Q0:TSymmetricAlgorithm;
OQCCCC00Q0:THMAC;
OCCCCC00Q0:integer;
O000CC00Q0:cardinal;
OO00CC00Q0:word;
begin
Result:=False;
SetLength(O0QCCC00Q0,0);
if Assigned(O0QO0C00Q0.OQ0O0C00Q0.OQQQ0CO0Q0)then begin
O0QO0C00Q0.OQ0O0C00Q0.OQQQ0CO0Q0(Self,OOOCCC00Q0,OQOCCC00Q0,Result);
if not Result then
Exit;
end
else begin
O0QCCC00Q0:=OOOCCC00Q0.OQCQQOQ0Q0;
if Length(O0QCCC00Q0)<192 then
Exit;
OCOQCC00Q0(O0QCCC00Q0,OCOCCC00Q0);
if Length(OCOCCC00Q0)=0 then
Exit;
OQCCCC00Q0:=THMAC.Create(THash_SHA2_256,OCOCCC00Q0);
try
OQCCCC00Q0.ComputeHash(TValueArr(O0QCCC00Q0),0,160);
if(Length(OQCCCC00Q0.Hash)<>32)or
(MemCompare(@O0QCCC00Q0[160],@OQCCCC00Q0.Hash[0],32)<>0)then
Exit;
finally
OQCCCC00Q0.Free;
end;
OOCCCC00Q0:=TCipher_Rijndael.Create;
try
OOCCCC00Q0.Mode:=cmCBC;
OOCCCC00Q0.Key:=OCOCCC00Q0;
OOCCCC00Q0.SetIV(TValueArr(O0QCCC00Q0),16,16);
OOCCCC00Q0.DecodeBuffer(TValueArr(O0QCCC00Q0),32,160-32,TValueArr(O0QCCC00Q0),32);
finally
OOCCCC00Q0.Free;
end;
Move(O0QCCC00Q0[32],O000CC00Q0,4);
OOOCCC00Q0.OQQQQOQ0Q0:=O000CC00Q0;
Move(O0QCCC00Q0[36],O000CC00Q0,4);
OOOCCC00Q0.O0CQQOQ0Q0:=O000CC00Q0;
SetLength(OOQCCC00Q0,8);
Move(O0QCCC00Q0[40],OOQCCC00Q0[0],8);
OQOCCC00Q0.OOCOQOQ0Q0:=OOQCCC00Q0;
OQOCCC00Q0.OCOOQOQ0Q0:=OOCCCQQ0Q0(O0QCCC00Q0[48]);
if O0QCCC00Q0[48]>byte(High(OOCCCQQ0Q0))then
Exit;
OO00CC00Q0:=(O0QCCC00Q0[49]shl 8)+O0QCCC00Q0[50];
OQOCCC00Q0.OOOOQOQ0Q0:=OC0OO0Q0Q0.O0OOO0Q0Q0(OO00CC00Q0);
if OQOCCC00Q0.OOOOQOQ0Q0=OQCCCQQ0Q0 then
Exit;
if O0QCCC00Q0[51]=1 then
OQOCCC00Q0.OQOOQOQ0Q0:=O00QO0QOQ0
else
OQOCCC00Q0.OQOOQOQ0Q0:=OQCOQOQOQ0;
O0CCCC00Q0:=O0QCCC00Q0[52];
if(O0CCCC00Q0>0)and(O0CCCC00Q0<=32)then begin
SetLength(OQQCCC00Q0,O0CCCC00Q0);
Move(O0QCCC00Q0[53],OQQCCC00Q0[0],O0CCCC00Q0);
OQOCCC00Q0.OQQOQOQ0Q0:=OQQCCC00Q0;
end
else
OQOCCC00Q0.OQQOQOQ0Q0:=nil;
O0CCCC00Q0:=O0QCCC00Q0[85];
if(O0CCCC00Q0>0)and(O0CCCC00Q0<=48)then begin
SetLength(OCQCCC00Q0,O0CCCC00Q0);
Move(O0QCCC00Q0[86],OCQCCC00Q0[0],O0CCCC00Q0);
OQOCCC00Q0.OCQOQOQ0Q0:=OCQCCC00Q0;
end
else begin
OQOCCC00Q0.OCQOQOQ0Q0:=nil;
Exit;
end;
end;
if OOOCCC00Q0.OCQQQOQ0Q0>0 then begin
if OOOCCC00Q0.OCQQQOQ0Q0>=OOOCCC00Q0.O0CQQOQ0Q0 then
OCCCCC00Q0:=OOOCCC00Q0.OCQQQOQ0Q0-OOOCCC00Q0.O0CQQOQ0Q0
else
OCCCCC00Q0:=Cardinal($FFFFFFFF)-OOOCCC00Q0.O0CQQOQ0Q0+OOOCCC00Q0.OCQQQOQ0Q0+1;
if OCCCCC00Q0>O0QO0C00Q0.OQ0O0C00Q0.OC0Q0CO0Q0*1000 then
Exit;
end;
OCCCCC00Q0:=OCO0OCOOQ0-OOOCCC00Q0.OQQQQOQ0Q0;
if(OCCCCC00Q0<0)or(OCCCCC00Q0>O0QO0C00Q0.OQ0O0C00Q0.OC0Q0CO0Q0)then
Exit;
Result:=True;
end;
procedure OCOO0C00Q0.OCQOQC00Q0(
O0COQC00Q0:OCQC00Q0Q0;OOCOQC00Q0:OQCCQOQ0Q0);
var
OQCOQC00Q0:OQQ0Q0Q0Q0;
begin
OOCOQC00Q0.OCQOQOQ0Q0:=OQCO0C00Q0;
OQCOQC00Q0:=OQQQCC00Q0(OOCOQC00Q0);
try
O0COQC00Q0.OQQQC0Q0Q0(OQCOQC00Q0.OCQQQOQ0Q0);
O0COQC00Q0.OOOO00Q0Q0(OQCOQC00Q0.OQCQQOQ0Q0);
finally
OQCOQC00Q0.Free;
end;
end;
procedure OCOO0C00Q0.OCCOQC00Q0(
O00QOQ00Q0:OCQC00Q0Q0;OO0QOQ00Q0:OQCCQOQ0Q0);
var
OQ0QOQ00Q0:OQQ0Q0Q0Q0;
OC0QOQ00Q0:integer;
begin
OQ0QOQ00Q0:=OQQ0Q0Q0Q0.Create;
OO0QOQ00Q0.OQCOQOQ0Q0.OQOCQOQ0Q0(OQ0QOQ00Q0);
OQ0QOQ00Q0.OCQQQOQ0Q0:=O00QOQ00Q0.OC0CC0Q0Q0;
OC0QOQ00Q0:=O00QOQ00Q0.OO0CC0Q0Q0;
OQ0QOQ00Q0.OQCQQOQ0Q0:=O00QOQ00Q0.OOOCC0Q0Q0(OC0QOQ00Q0);
OQ0QOQ00Q0.OQQQQOQ0Q0:=OCO0OCOOQ0;
OO0QOQ00Q0.OCQOQOQ0Q0:=OQCO0C00Q0;
end;
procedure OCOO0C00Q0.O0OQOQ00Q0(OOOQOQ00Q0:OCQC00Q0Q0;
OQOQOQ00Q0:OCQOC0Q0Q0;OCOQOQ00Q0:OQCCQOQ0Q0;
out O0QQOQ00Q0:integer);
var
OOQQOQ00Q0:OQCCCCO0Q0;
OQQQOQ00Q0:O00QQOQ0Q0;
begin
O0QQOQ00Q0:=-1;
OOQQOQ00Q0:=OQCCCCO0Q0(OQOQOQ00Q0.OOCCQ0Q0Q0(OQCCCCO0Q0));
if(OOQQOQ00Q0=nil)or(Length(OOQQOQ00Q0.O000CCO0Q0)=0)then
Exit;
OQQQOQ00Q0:=O00QQOQ0Q0.Create;
try
OQQQOQ00Q0.OQCQQOQ0Q0:=OOQQOQ00Q0.O000CCO0Q0;
if O0OCCC00Q0(OQQQOQ00Q0,OCOQOQ00Q0)then begin
OO0QCC00Q0(OCOQOQ00Q0.OCQOQOQ0Q0);
O0QQOQ00Q0:=0;
end;
finally
OQQQOQ00Q0.Free;
end;
end;
procedure OCOO0C00Q0.OCQQOQ00Q0(O0CQOQ00Q0:OCQC00Q0Q0;
const OOCQOQ00Q0,OQCQOQ00Q0:TBytes);
begin
end;
class function OCQC0Q00Q0.OQ000Q00Q0(OC000Q00Q0:TCRList;
O0O00Q00Q0:O0QOQ0Q0Q0):TScCertificateStatusSet;
var
OOO00Q00Q0:OOQ000OOQ0;
OQO00Q00Q0:OOQQ00OOQ0;
OCO00Q00Q0,O0Q00Q00Q0:boolean;
OOQ00Q00Q0:OOQO0OOOQ0;
OQQ00Q00Q0:boolean;
OCQ00Q00Q0,O0C00Q00Q0:integer;
OOC00Q00Q0:TCRList;
OQC00Q00Q0,OCC00Q00Q0:TScCertificate;
O00O0Q00Q0:TScCertificate;
OO0O0Q00Q0:TScCertificate;
{$IFNDEF IOS}
OQ0O0Q00Q0:TScCertificate;
{$ELSE}
OQQ0OC0CQ0:TScCertificateStatus;
{$ENDIF}
begin
if OC000Q00Q0.Count=0 then
raise EScError.Create(seCertificateNotExists);
OOC00Q00Q0:=TCRList.Create;
try
OQC00Q00Q0:=TScCertificate(OC000Q00Q0[0]);
OOC00Q00Q0.Add(OQC00Q00Q0);
if O0O00Q00Q0.O0OOOCO0Q0 then begin
if not OQC00Q00Q0.IssuerName.Equals(OQC00Q00Q0.SubjectName)then begin
for O0C00Q00Q0:=1 to OC000Q00Q0.Count-1 do begin
OCQ00Q00Q0:=O0C00Q00Q0;
while OCQ00Q00Q0<OC000Q00Q0.Count do begin
if OQC00Q00Q0.IssuerName.Equals(TScCertificate(OC000Q00Q0[OCQ00Q00Q0]).SubjectName)then begin
OC000Q00Q0.Move(OCQ00Q00Q0,O0C00Q00Q0);
break;
end;
Inc(OCQ00Q00Q0);
end;
if OCQ00Q00Q0=OC000Q00Q0.Count then
break;
OCC00Q00Q0:=TScCertificate(OC000Q00Q0[O0C00Q00Q0]);
if OCC00Q00Q0.IssuerName.Equals(OCC00Q00Q0.SubjectName)then
break;
OQC00Q00Q0:=OCC00Q00Q0;
OOC00Q00Q0.Add(OQC00Q00Q0);
end;
end;
end
else begin
for OCQ00Q00Q0:=1 to OC000Q00Q0.Count-1 do begin
OQC00Q00Q0:=TScCertificate(OC000Q00Q0[OCQ00Q00Q0]);
OOC00Q00Q0.Add(OQC00Q00Q0);
end;
end;
if(OOC00Q00Q0.Count=1)and OQC00Q00Q0.IsSelfSigned then begin
OQC00Q00Q0.VerifyCertificateChain(nil,nil,Result);
if O0O00Q00Q0.OO0OOCO0Q0 then
Result:=[]
else
Result:=[csUntrustedRoot,csOtherError];
end
else begin
if O0O00Q00Q0.O0C0OCO0Q0<>nil then begin
OOC00Q00Q0.Add(O0O00Q00Q0.O0C0OCO0Q0);
TScCertificateChain.VerifyChain(O0O00Q00Q0.OQQ0OCO0Q0,OOC00Q00Q0,Result);
OOC00Q00Q0.Remove(O0O00Q00Q0.O0C0OCO0Q0);
end
else begin
OO0O0Q00Q0:=nil;
OQC00Q00Q0:=TScCertificate(OOC00Q00Q0[OOC00Q00Q0.Count-1]);
{$IFNDEF IOS}
if OC0O0Q00Q0<>nil then
OO0O0Q00Q0:=OC0O0Q00Q0.OCCOOCC0Q0.OQQQQCC0Q0(OQC00Q00Q0.IssuerName);
if(OO0O0Q00Q0=nil)and(O0OO0Q00Q0<>nil)then begin
OQ0O0Q00Q0:=O0OO0Q00Q0.OCCOOCC0Q0.OQQQQCC0Q0(OQC00Q00Q0.IssuerName);
if OQ0O0Q00Q0<>nil then begin
OOC00Q00Q0.Add(OQ0O0Q00Q0);
if OC0O0Q00Q0<>nil then
OO0O0Q00Q0:=OC0O0Q00Q0.OCCOOCC0Q0.OQQQQCC0Q0(OQ0O0Q00Q0.IssuerName);
end;
end;
if OO0O0Q00Q0<>nil then
OOC00Q00Q0.Add(OO0O0Q00Q0);
{$ENDIF IOS}
if(OO0O0Q00Q0=nil)and(O0O00Q00Q0.OOC0OCO0Q0<>nil)then begin
OO0O0Q00Q0:=O0O00Q00Q0.OOC0OCO0Q0.OCCOOCC0Q0.OQQQQCC0Q0(OQC00Q00Q0.IssuerName);
if OO0O0Q00Q0<>nil then begin
OOC00Q00Q0.Add(OO0O0Q00Q0);
{$IFNDEF IOS}
if not OO0O0Q00Q0.IsSelfSigned and(OC0O0Q00Q0<>nil)then begin
OO0O0Q00Q0:=OC0O0Q00Q0.OCCOOCC0Q0.OQQQQCC0Q0(OO0O0Q00Q0.IssuerName);
if OO0O0Q00Q0<>nil then
OOC00Q00Q0.Add(OO0O0Q00Q0);
end;
{$ENDIF IOS}
end;
end;
TScCertificateChain.VerifyChain(O0O00Q00Q0.OQQ0OCO0Q0,OOC00Q00Q0,Result);
{$IFDEF IOS}
OQQ0OC0CQ0:=TScCryptoAPIStorage.CheckTrustCertificateByIssuer(OQC00Q00Q0);
if OQQ0OC0CQ0=csValid then
Exclude(Result,csUntrustedRoot)
else
Include(Result,OQQ0OC0CQ0);
{$ENDIF}
end;
end;
O00O0Q00Q0:=TScCertificate(OOC00Q00Q0[0]);
if O0O00Q00Q0.OC0OOCO0Q0<>'' then begin
OCO00Q00Q0:=False;
O0Q00Q00Q0:=False;
OOO00Q00Q0:=O00O0Q00Q0.Extensions.O0CO0C0OQ0(OO00Q0OOQ0);
if OOO00Q00Q0<>nil then begin
for O0C00Q00Q0:=0 to OO00Q0OOQ0(OOO00Q00Q0).O000Q0OOQ0.OOO000QOQ0-1 do begin
OQO00Q00Q0:=OO00Q0OOQ0(OOO00Q00Q0).O000Q0OOQ0[O0C00Q00Q0];
if CompareText(OQO00Q00Q0.O0OC00OOQ0,'DNSName')=0 then begin
OCO00Q00Q0:=True;
if O0CC0Q00Q0(O0O00Q00Q0.OC0OOCO0Q0,OQO00Q00Q0.OOOC00OOQ0)then begin
O0Q00Q00Q0:=True;
break;
end;
end;
end;
end;
if not OCO00Q00Q0 then
if O0CC0Q00Q0(O0O00Q00Q0.OC0OOCO0Q0,O00O0Q00Q0.SubjectName.O00Q00OOQ0[OID_COMMON_NAME])then
O0Q00Q00Q0:=True;
if not O0Q00Q00Q0 then
Include(Result,csInvalidSubjectName);
end;
OOO00Q00Q0:=O00O0Q00Q0.Extensions.O0CO0C0OQ0(O0CQC0OOQ0);
if OOO00Q00Q0<>nil then begin
if not(OQ0QC0OOQ0 in O0CQC0OOQ0(OOO00Q00Q0).OQQCC0OOQ0)then
Include(Result,csInvalidKeyUsage);
end;
OOO00Q00Q0:=O00O0Q00Q0.Extensions.O0CO0C0OQ0(OCQCC0OOQ0);
if(OOO00Q00Q0<>nil)and OOO00Q00Q0.OOOO00OOQ0 then begin
OQQ00Q00Q0:=False;
OOQ00Q00Q0:=OCQCC0OOQ0(OOO00Q00Q0).OQCCC0OOQ0;
for O0C00Q00Q0:=0 to OOQ00Q00Q0.OOO000QOQ0-1 do
if OOQ00Q00Q0[O0C00Q00Q0].OCOO0OOOQ0=OID_KP_SERVER_AUTH then begin
OQQ00Q00Q0:=True;
break;
end;
if not OQQ00Q00Q0 then
Include(Result,csInvalidKeyUsage);
end;
if Assigned(O0O00Q00Q0.OOQ0OCO0Q0)then
O0O00Q00Q0.OOQ0OCO0Q0(nil,O00O0Q00Q0,OOC00Q00Q0,Result);
finally
OOC00Q00Q0.Free;
end;
end;
class function OCQC0Q00Q0.O0CC0Q00Q0(const OOCC0Q00Q0,OQCC0Q00Q0:string):boolean;
var
OCCC0Q00Q0,O0000Q00Q0:TStringList;
OO000Q00Q0:integer;
begin
OCCC0Q00Q0:=O0OOQ0QOQ0(OOCC0Q00Q0,'.');
O0000Q00Q0:=O0OOQ0QOQ0(OQCC0Q00Q0,'.');
try
Result:=OCCC0Q00Q0.Count=O0000Q00Q0.Count;
if not Result then
Exit;
for OO000Q00Q0:=0 to OCCC0Q00Q0.Count-1 do begin
Result:=OC00OCOOQ0(OCCC0Q00Q0[OO000Q00Q0],O0000Q00Q0[OO000Q00Q0]);
if not Result then
Exit;
end;
finally
OCCC0Q00Q0.Free;
O0000Q00Q0.Free;
end;
end;
initialization
{$IFDEF USE_CRYPTOAPI_STORAGE}
OC0O0Q00Q0:=TScCryptoAPIStorage.Create(nil);
{$IFDEF MSWINDOWS}
O0OO0Q00Q0:=TScCryptoAPIStorage.Create(nil);
{$ENDIF}
{$ELSE}
OC0O0Q00Q0:=OO0Q0CQ0Q0.Create(nil);
OC0O0Q00Q0.O0CCCCQ0Q0:='0';
{$ENDIF}
{$IFDEF ANDROID}
OC0O0Q00Q0.OOQCCCQ0Q0:='/system/etc/security/cacerts';
{$ELSE}
{$IFDEF LINUX}
OC0O0Q00Q0.OOQCCCQ0Q0:='/etc/ssl/certs';
{$ELSE}
{$IFDEF LINUX_BSD}
CryptoAPISystemRootStorage.Path:='/etc/ssl/certs';
{$ELSE}
{$IFDEF MSWINDOWS}
OC0O0Q00Q0.OQCOO0OCQ0:='Root';
O0OO0Q00Q0.OQCOO0OCQ0:='CA';
{$ELSE}
OC0O0Q00Q0.OQCCOC0CQ0:='/System/Library/Keychains/SystemRootCertificates.keychain';
{$ENDIF MSWINDOWS}
{$ENDIF LINUX_BSD}
{$ENDIF LINUX}
{$ENDIF ANDROID}
OQQO0Q00Q0:=TCriticalSection.Create;
finalization
FreeAndNil(OC0O0Q00Q0);
FreeAndNil(O0OO0Q00Q0);
FreeAndNil(OQQO0Q00Q0);
end.
