
//////////////////////////////////////////////////
//  ODBC Data Access Components
//  Copyright © 2008-2021 Devart. All right reserved.
//////////////////////////////////////////////////

{$IFNDEF CLR}

{$I ODBCDac.inc}
unit ODBCServicesUni;
{$ENDIF}

interface

uses
{$IFNDEF CLR}
  CLRClasses,
{$ELSE}
  System.Text, System.Runtime.InteropServices,
{$ENDIF}
  SysUtils, Classes, Variants, DB,
  CRTypes, MemData, {$IFNDEF FPC}MemDS{$ELSE}MemDataSet{$ENDIF},
  CRParser, CRAccess, CRServerEnumerator, DBAccess, DAScript, DASQLGenerator,
  {$IFNDEF STD}DADump,{$ENDIF}
{$IFNDEF UNIDACPRO}
  ODBCClasses, ODBCParser, ODBCCall;
{$ELSE}
  ODBCClassesUni, ODBCParserUni, ODBCCallUni;
{$ENDIF}

type
{ TCustomODBCSQLGenerator }

  TCustomODBCSQLGenerator = class(TDASQLGenerator)
  protected
    procedure GenerateLockSQL(ParamsInfo: TDAParamsInfo;
      const KeyAndDataFields: TKeyAndDataFields;
      const Index: integer = -1); override;
    procedure GenerateInsertSQL(ParamsInfo: TDAParamsInfo;
      const KeyAndDataFields: TKeyAndDataFields;
      const ModifiedFieldsOnly: boolean;
      const Index: integer = -1); override;

    function GenerateIndexName(const Name: string): string; override;
  public
    function DecodeFieldIndex(const FieldName: string): integer; override;
  end;

{ TCustomODBCDataSetUpdater }

  TCustomODBCDataSetUpdater = class(TDADataSetUpdater)
  protected
    // CLR cross-assembly
    procedure CheckUpdateQuery(const StatementType: TStatementType); override;

    function RefreshByLockAllowed: boolean; override;
    function SavepointAllowed: boolean; override;
    function BatchUpdateAllowed: boolean; override;
    procedure SetUpdateQueryOptions(const StatementType: TStatementType; const IsAutoGeneratedSQL: Boolean); override;
  end;

{ TCustomODBCDataSetService }

  TCustomODBCDataSetService = class(TDADataSetService)
  protected
    procedure CreateDataSetUpdater; override;
    procedure CreateSQLGenerator; override;
    function KeysFromSpecialColumns: boolean; virtual;
    function DetectCanModify: boolean; override;
    function GetRecCount: integer; override;
  public
    constructor Create(AOwner: TMemDataSet); override;

    function GetDBKeyList(const TableName, IndexName: string): string; override;
    function OpenNext: boolean; override;
  end;

  TCustomODBCFieldTypeMap = class(TDAFieldTypeMap)
  public
    class function GetDataType(FieldType: TFieldType; SubDataType: Word = 0): integer; override;
  end;

  TODBCScriptProcessor = class(TDAScriptProcessor)
  protected
    function GetParserClass: TSQLParserClass; override;
  end;

{$IFNDEF STD}

  TCustomODBCDumpProcessor = class(TDADumpProcessor)
  protected
    function CreateQuery: TCustomDADataSet; override;
  end;

{$ENDIF}

  TODBCServerEnumerator = class (TCRServerEnumerator)
  private
    FODBCEnv: IODBCEnvironment;
  public
    constructor Create; override;
    destructor Destroy; override;

    procedure GetServerList(List: TStrings); override;
  end;

implementation

uses
  CRProps, CRFunctions, DAConsts, DASQLMonitor,
{$IFNDEF UNIDACPRO}
  ODBCProps;
{$ELSE}
  ODBCPropsUni;
{$ENDIF}


{ TCustomODBCSQLGenerator }

procedure TCustomODBCSQLGenerator.GenerateLockSQL(ParamsInfo: TDAParamsInfo;
  const KeyAndDataFields: TKeyAndDataFields;
  const Index: integer = -1);

  procedure GenerateLockCondition;
  var
    AllFields: TKeyAndDataFields;
    i: integer;
  begin
    //LockSQL where clause should contains all fields to check that there are no changes in locked record
    if FDesignMode then  // Design-Time generation we should include key fields only (IS NULL issue)
      AllFields.DataFieldDescs := KeyAndDataFields.KeyFieldDescs
    else
      AllFields.DataFieldDescs := KeyAndDataFields.DataFieldDescs; //in Run-Time include all field (IS NULL issue)
    //Include ReadOnly Key Fields
    for i := 0 to High(KeyAndDataFields.KeyFieldDescs) do
      if KeyAndDataFields.KeyFieldDescs[i].ReadOnly then begin//This field is not included in DataFields
        SetLength(AllFields.DataFieldDescs, Length(AllFields.DataFieldDescs) + 1);
        AllFields.DataFieldDescs[High(AllFields.DataFieldDescs)] := KeyAndDataFields.KeyFieldDescs[i];
      end;
    SetLength(AllFields.KeyFieldDescs, 0);   //we should use DataFields to perform IsLargeDataTypeUsed check
    GenerateConditions(ParamsInfo, FCondSB, _stUpdate, AllFields);
  end;

var
  FieldDesc: TCRFieldDesc;
  Old: Boolean;
begin
  if High(KeyAndDataFields.DataFieldDescs) > 0 then begin
    FHeaderSB.Append('UPDATE ');
    FHeaderSB.Append(SQLInfo.NormalizeName(FTableInfo.TableNameFull, QuoteNames));
    FHeaderSB.Append(DALineSeparator + 'SET' + DALineSeparator + '  ');

    FieldDesc := TCRFieldDesc(KeyAndDataFields.DataFieldDescs[0]);

    FFldSB.Append(FieldDesc.ActualNameQuoted(SQLInfo, QuoteNames));
    FFldSB.Append(' = ');

    Old := TDBAccessUtils.GetLockMode(TDASQLGeneratorService(FService).Dataset) = lmOptimistic;
    AddParam(ParamsInfo, FFldSB, FieldDesc, _stLock, pdUnknown, Index, Old);

    FMiddleSB.Append(DALineSeparator + 'WHERE' + DALineSeparator + '  ');
    GenerateLockCondition; // FCondSB
  end;
end;

procedure TCustomODBCSQLGenerator.GenerateInsertSQL(ParamsInfo: TDAParamsInfo;
  const KeyAndDataFields: TKeyAndDataFields;
  const ModifiedFieldsOnly: boolean;
  const Index: integer = -1);
begin
  inherited GenerateInsertSQL(ParamsInfo, KeyAndDataFields, ModifiedFieldsOnly, Index);

  if FFldSB.Length = 0 then begin
    Clear;
    inherited GenerateInsertSQL(ParamsInfo, KeyAndDataFields, False, Index);
  end;
end;

function TCustomODBCSQLGenerator.GenerateIndexName(const Name: string): string;
begin
  Result := 'F_' + Name;
end;

function TCustomODBCSQLGenerator.DecodeFieldIndex(const FieldName: string): integer;
var
  e: integer;
begin
  Result := -1;
  if (Length(FieldName) >= 3) and (FieldName[1] = 'F') and (FieldName[2] = '_') then begin
    Val(Copy(FieldName, 3, MaxInt), Result, e);
    if e <> 0 then
      Result := -1;
  end;
end;

{ TCustomODBCDataSetUpdater }

procedure TCustomODBCDataSetUpdater.CheckUpdateQuery(const StatementType: TStatementType);
begin
  inherited;
end;

function TCustomODBCDataSetUpdater.RefreshByLockAllowed: boolean;
begin
  Result := False;
end;

function TCustomODBCDataSetUpdater.SavepointAllowed: boolean;
begin
  Result := False;
end;

function TCustomODBCDataSetUpdater.BatchUpdateAllowed: boolean;
begin
  Result := False;
end;

procedure TCustomODBCDataSetUpdater.SetUpdateQueryOptions(const StatementType: TStatementType; const IsAutoGeneratedSQL: Boolean);
var
  DestRecordSet, SourceRecordSet: TCRRecordSet;

  procedure CopyPropR(Prop: integer);
  var
    v: variant;
  begin
    SourceRecordSet.GetProp(Prop, v);
    DestRecordSet.SetProp(Prop, v);
  end;

begin
  CheckIRecordSet; // can be inactive
  SourceRecordSet := GetIRecordSet;
  DestRecordSet := TDBAccessUtils.GetIRecordSet(UpdateQuery as TCustomDADataSet);

  CopyPropR(prCommandTimeout);

  DestRecordSet.SetProp(prExtendedFieldsInfo, False);
end;

{ TCustomODBCDataSetService }

constructor TCustomODBCDataSetService.Create(AOwner: TMemDataSet);
begin
  inherited;
end;

procedure TCustomODBCDataSetService.CreateDataSetUpdater;
begin
  SetDataSetUpdater(TCustomODBCDataSetUpdater.Create(Self));
end;

procedure TCustomODBCDataSetService.CreateSQLGenerator;
begin
  SetSQLGenerator(TCustomODBCSQLGenerator.Create(TDASQLGeneratorService));
end;

function TCustomODBCDataSetService.KeysFromSpecialColumns: boolean;
begin
  Result := False;
end;

function TCustomODBCDataSetService.DetectCanModify: boolean;
begin
  Result := inherited DetectCanModify or
    not FDataSet.ReadOnly and FIsAnyFieldCanBeModified;
end;

function TCustomODBCDataSetService.GetRecCount: integer;
var
  St: string;
  UpdateQuery: TCustomDADataSet;
  MonitorClass: TDASQLMonitorClass;
  MessageID: cardinal;
begin
  Result := 0;
  St := FDataSet.FinalSQL;
  St := _SetOrderBy(St, '', TODBCParser);
  St := 'SELECT count(*) FROM (' + DALineSeparator + St + DALineSeparator + ') t';

  TCustomODBCDataSetUpdater(Updater).CheckUpdateQuery(stCustom);
  UpdateQuery := TCustomDADataSet(TCustomODBCDataSetUpdater(Updater).UpdateQuery);
  UpdateQuery.SQL.Text := St;
  UpdateQuery.Params.Assign(FDataSet.Params);

  MonitorClass := TDASQLMonitorClass(TDBAccessUtils.SQLMonitorClass(UsedConnection));
  if MonitorClass.HasMonitor or FDataSet.Debug then
    MonitorClass.SQLExecute(FDataSet, St, UpdateQuery.Params, 'Get RecordCount', MessageID, True);

  UpdateQuery.Open;
  if not UpdateQuery.EOF then
    Result := UpdateQuery.Fields[0].AsInteger;

  if MonitorClass.HasMonitor or FDataSet.Debug then
    MonitorClass.SQLExecute(FDataSet, St, UpdateQuery.Params, 'Get RecordCount', MessageID, False);
end;

function TCustomODBCDataSetService.GetDBKeyList(const TableName, IndexName: string): string;
var
  RecordSet: TODBCMetaDataRecordSet;
  RecBuf: IntPtr;
  Info: TSQLObjectInfo;
  SQLInfo: TSQLInfo;
  ICon: TODBCConnection;
  v: variant;
begin
  if not KeysFromSpecialColumns or (IndexName <> '') then begin
    Result := inherited GetDBKeyList(TableName, IndexName);
    Exit;
  end;

  BeginConnection;
  try
    ICon := TODBCConnection(TDBAccessUtils.GetIConnection(UsedConnection));
    SQLInfo := GetICommand.SQLInfo;

    SQLInfo.SplitObjectName(TableName, Info);
    Info.Name := SQLInfo.NormalizeName(Info.Name, False, True);
    Info.Schema := SQLInfo.NormalizeName(Info.Schema, False, True);
    if Info.Schema = '' then
      Info.Schema := ICon.GetCachedSchema;
    Info.Catalog := SQLInfo.NormalizeName(Info.Catalog, False, True);
    if Info.Catalog = '' then
      Info.Catalog := ICon.GetCachedCatalog;

    RecordSet := TODBCMetaDataRecordSet.Create;
    try
      RecordSet.SetConnection(ICon);

      with TODBCMetaDataCommand(RecordSet.GetCommand) do begin
        MetaDataKind := mkSpecialColumns;
        with MetaDataArgs do begin
          CatalogName := Info.Catalog;
          SchemaName := Info.Schema;
          ObjectName := Info.Name;
          Param1 := SQL_BEST_ROWID;
          Param2 := SQL_SCOPE_SESSION;
          Param3 := SQL_NULLABLE;
        end;
      end;

      RecordSet.Open;
      RecordSet.AllocRecBuf(RecBuf);
      try
        repeat
          RecordSet.GetNextRecord(RecBuf);
          if RecordSet.Eof then
            break;

          RecordSet.GetFieldAsVariant(RecordSet.Fields[1], RecBuf, v);
          if Result <> '' then
            Result := Result + ';';
          Result := Result + VarToStr(v);
        until False;
      finally
        RecordSet.FreeRecBuf(RecBuf);
      end;
      RecordSet.Close;
    finally
      RecordSet.Free;
    end;
  finally
    EndConnection;
  end;
end;

function TCustomODBCDataSetService.OpenNext: boolean;
begin
  if not FDataSet.Active then begin
    FDataSet.Open;
    Result := True;
  end
  else begin
    GetIRecordSet.SetProp(prOpenNext, True);
    TDBAccessUtils.SetLockDebug(FDataSet, True);
    try
      FDataSet.Close;

      Result := TODBCRecordSet(GetIRecordSet).CheckNextResult;

      if Result then begin
        FDataSet.FieldDefs.Updated := False;
        FDataSet.Open;
      end;
    finally
      TDBAccessUtils.SetLockDebug(FDataSet, False);
      GetIRecordSet.SetProp(prOpenNext, False);
    end;
  end;
end;

{ TCustomODBCFieldTypeMap }

class function TCustomODBCFieldTypeMap.GetDataType(FieldType: TFieldType; SubDataType: Word = 0): integer;
begin
  if FieldType = ftFixedChar then
    Result := dtFixedChar
  else if Integer(FieldType) = Integer(ftFixedWideChar) then
    Result := dtFixedWideChar
  else
    Result := inherited GetDataType(FieldType, SubDataType);
end;

{ TODBCScriptProcessor }

function TODBCScriptProcessor.GetParserClass: TSQLParserClass;
begin
  Result := TODBCParser;
end;

{$IFNDEF STD}

{ TCustomODBCDumpProcessor }

function TCustomODBCDumpProcessor.CreateQuery: TCustomDADataSet;
begin
  Result := GetConnection.CreateDataSet;
  Result.ReadOnly := True;
  Result.UniDirectional := True;
  TDBAccessUtils.CheckConnection(Result);
  TDBAccessUtils.GetIRecordSet(Result).SetProp(prExtendedFieldsInfo, False);
end;

{$ENDIF}

{ TODBCServerEnumerator }

constructor TODBCServerEnumerator.Create;
begin
  inherited;

  FODBCEnv := nil;
end;

destructor TODBCServerEnumerator.Destroy;
begin
  FODBCEnv := nil;

  inherited;
end;

procedure TODBCServerEnumerator.GetServerList(List: TStrings);
const
  BufSize = 256;
var
  Buf: IntPtr;
  Res, Len, Len2: smallint;
  s: string;
begin
  List.Clear;

  if FODBCEnv = nil then
    FODBCEnv := GetODBCEnvironment;
  if not FODBCEnv.IsInited then
    FODBCEnv.InitEnvironment;

  Buf := Marshal.AllocHGlobal(BufSize * SizeOf(char));
  try
  {$IFDEF USE_UNICODE_DRIVER}
    Res := FODBCEnv.Cli.SQLDataSourcesW(FODBCEnv.SQLHEnv, SQL_FETCH_FIRST, Buf, BufSize, Len, nil, 0, Len2);
  {$ELSE}
    Res := FODBCEnv.Cli.SQLDataSourcesA(FODBCEnv.SQLHEnv, SQL_FETCH_FIRST, Buf, BufSize, Len, nil, 0, Len2);
  {$ENDIF}
    repeat
      if Res = SQL_NO_DATA then
        exit;
      s := FromODBCString(Buf);
      List.Add(s);
    {$IFDEF USE_UNICODE_DRIVER}
      Res := FODBCEnv.Cli.SQLDataSourcesW(FODBCEnv.SQLHEnv, SQL_FETCH_NEXT, Buf, BufSize, Len, nil, 0, Len2);
    {$ELSE}
      Res := FODBCEnv.Cli.SQLDataSourcesA(FODBCEnv.SQLHEnv, SQL_FETCH_NEXT, Buf, BufSize, Len, nil, 0, Len2);
    {$ENDIF}
    until False;
  finally
    Marshal.FreeHGlobal(Buf);
  end;
end;

end.
