{$I MyDac.inc}
unit MyServicesUni;

interface

uses
  Variants, DateUtils, SysUtils, Classes, DB,
  CLRClasses, CRXml, CRTypes, MemData, CRAccess,
  {$IFDEF FPC}MemDataSet{$ELSE}MemDS{$ENDIF}, DBAccess, DADump, DASQLGenerator,
{$IFNDEF UNIDACPRO}
  MyClasses, MySQLGenerator;
{$ELSE}
  MyClassesUni, MySQLGeneratorUni;
{$ENDIF}

const
  prCheckRowVersion = 101;
  prLockRecordType  = 102;
  prAutoIncrementReadOnly = 103;
  prBackupTables    = 104;
  prBackupViews     = 105;
  prBackupData      = 106;
  prAddLock         = 107;
  prDisableKeys     = 108;
  prHexBlob         = 109;
  prUseExtSyntax    = 110;
  prUseDelayedIns   = 111;
  prCommitBatchSize = 112;
  prInsertType      = 113;
  prSaveBlobsAsHex  = 114;
  prBackupTriggers  = 115;
  prBackupStoredProcs = 116;

type
  TCustomMyDataSetService = class;

  TCustomMyDataSetUpdater = class(TDADataSetUpdater)
  protected
    {$IFDEF AUTOREFCOUNT}[weak]{$ENDIF}
    FDataSetService: TCustomMyDataSetService;

    function ReturnParamsAsFields: boolean; override;
    function GetIdentityFieldValue(var Value: variant): boolean; override;

    procedure CheckUpdateQuery(const StatementType: TStatementType); override;
    procedure SetUpdateQueryOptions(const StatementType: TStatementType; const IsAutoGeneratedSQL: Boolean); override;
    procedure CheckUpdateSQL(const SQL: string; const StatementTypes: TStatementTypes;
      UseGenerator: boolean = True); override;

    function IsRefreshQuickField(FieldDesc: TFieldDesc): boolean; override;
    procedure SaveMaxRefreshQuickValue(FieldDesc: TFieldDesc; const Value: variant); override;

    function PerformLock: boolean; override;
    function LockCompare(const Value1, Value2: variant): boolean; override;

  public
    constructor Create(AOwner: TDataSetService); override;
  end;

  TCustomMyDataSetService = class(TDADataSetService)
  protected
    FInGetRecCount: boolean;
    FUpdater: TCustomMyDataSetUpdater;

    FAutoIncrementReadOnly: boolean;
    FSaveBlobsAsHex: boolean;

    procedure CreateDataSetUpdater; override;
    procedure SetDataSetUpdater(Value: TDataSetUpdater); override;
    procedure CreateSQLGenerator; override;

    function GetIConnection: TMySQLConnection;
    function GetIRecordSet: TMySQLRecordSet;

    function DetectCanModify: boolean; override;

    procedure InitCursor; override;
    procedure FillFieldsDefaultValues; override;

    function GetRecCount: integer; override;
    procedure BreakExec; override;
    function Executing: boolean; override;

    procedure SetNumberRange(FieldDef: TFieldDef); override;

  { XML }
    procedure WriteFieldXMLDataType(Field: TField; FieldDesc: TFieldDesc; const FieldAlias: string; XMLWriter: XMLTextWriter); override;
    procedure WriteFieldXMLAttributeType(Field: TField; FieldDesc: TFieldDesc; const FieldAlias: string;
      XMLWriter: XMLTextWriter); override;
    function GetFieldXMLValue(Field: TField; FieldDesc: TFieldDesc): WideString; override;

  public
    constructor Create(AOwner: TMemDataSet); override;
    destructor Destroy; override;

    function SetProp(Prop: integer; const Value: variant): boolean; override;

    function OpenNext: boolean; override;

    class procedure GetStoredProcNames(Connection: TMySQLConnection; Query: TCustomDADataSet;
      Database: string; List: TStrings);
    class procedure GetTriggerNames(Connection: TMySQLConnection; Query: TCustomDADataSet;
      Database: string; List: TStrings; AllTriggers: boolean = False);
  end;

  TCustomMyFieldTypeMap = class(TDAFieldTypeMap)
    class function GetDataType(FieldType: TFieldType; SubDataType: Word = 0): integer; override;
  end;

  _TMyInsertType = (_itInsert, _itInsertIgnore, _itReplaceInto);

  TCustomMyDumpProcessor = class(TDADumpProcessor)
  private
    FUseUnicode: boolean;
    FCharset: string;
    FIConnection: TMySQLConnection;
    FQueryView: TCustomDADataSet;
  {$IFNDEF NEXTGEN}
    FTmpBuf: AnsiString;
  {$ENDIF}
    function GetIsView(const TableName: string; TablesList: TStringList = nil): boolean;
    procedure GetCurrentRow(const KeyAndDataFields: TKeyAndDataFields; CurrentRowSB: {$IFDEF NEXTGEN}StringBuilder{$ELSE}AnsiStringBuilder{$ENDIF});
    procedure BackupTable(const Query: string; TableName: string; TableNum, TableCount: integer; IsView: boolean);
    procedure BackupTablesAndData(const Query: string);
    procedure GetStoredProcNames(List: TStrings);
    procedure BackupStoredProc(const StoredProcName: string);
    procedure BackupStoredProcedures;
    procedure GetTriggerNames(List: TStrings);
    procedure BackupTrigger(const TableName, TriggerName: string);
    procedure BackupTriggers;

  protected
    FBackupTables: boolean;
    FBackupViews: boolean;
    FBackupData: boolean;
    FBackupTriggers: boolean;
    FBackupStoredProcs: boolean;
    FAddLock: boolean;
    FDisableKeys: boolean;
    FHexBlob: boolean;
    FUseExtSyntax: boolean;
    FUseDelayedIns: boolean;
    FCommitBatchSize: integer;
    FInsertType: _TMyInsertType;
    FFieldsAsString: boolean;

  {$IFDEF VER12P}
    FEncoding: Encoding;
    procedure Add(const Line: string); override;
  {$ENDIF}
  {$IFNDEF NEXTGEN}
    procedure AddAnsiLine(const Line: AnsiString);
  {$ENDIF}

    procedure Backup(Query: string); override;
    function CreateQuery: TCustomDADataSet; override;
    procedure AddSettings; override;
    procedure RestoreSettings; override;
    procedure BackupObjects(const Query: string); override;

  public
    constructor Create(Owner: TDADump); override;
    destructor Destroy; override;

    function SetProp(Prop: integer; const Value: variant): boolean; override;
    function GetProp(Prop: integer; var Value: variant): boolean; override;
  end;

implementation

uses
  Math, MemUtils, CRProps, CRFunctions, CRParser, DAConsts, DASQLMonitor,
{$IFNDEF UNIDACPRO}
  MyProps, MyCall, MyConsts;
{$ELSE}
  MyPropsUni, MyCallUni, MyConstsUni;
{$ENDIF}

{ TCustomMyFieldTypeMap }

class function TCustomMyFieldTypeMap.GetDataType(FieldType: TFieldType; SubDataType: Word = 0): integer;
begin
  Result := inherited GetDataType(FieldType, SubDataType);
  if (Result = dtDateTime) and (SubDataType = dtTime) then
    Result := dtTime;
end;

{ TCustomMyDataSetUpdater }

constructor TCustomMyDataSetUpdater.Create(AOwner: TDataSetService);
begin
  inherited;

  FDataSetService := TCustomMyDataSetService(AOwner);
end;

function TCustomMyDataSetUpdater.ReturnParamsAsFields: boolean;
begin
  Result := True;
end;

function TCustomMyDataSetUpdater.GetIdentityFieldValue(var Value: variant): boolean;
var
  v: variant;
  id: int64;
begin
  Result := False;
  BeginConnection;
  try
    FDataSetService.GetIConnection.GetProp(prLastInsertId, v);
    id := v;
    if id <> 0 then begin
      Value := id;
      Result := True;
    end;
  finally
    EndConnection;
  end;
end;

procedure TCustomMyDataSetUpdater.CheckUpdateQuery(const StatementType: TStatementType);
begin
  inherited;

  if UpdateQuery is TCustomDADataSet then begin
    TDBAccessUtils.SetFetchAll(TCustomDADataSet(UpdateQuery), True);
  end;
end;

procedure TCustomMyDataSetUpdater.SetUpdateQueryOptions(const StatementType: TStatementType; const IsAutoGeneratedSQL: Boolean);
var
  DestRecordSet, SourceRecordSet: TCRRecordSet;

  procedure CopyPropR(Prop: integer);
  var
    v: variant;
  begin
    SourceRecordSet.GetProp(Prop, v);
    DestRecordSet.SetProp(Prop, v);
  end;

begin
  SourceRecordSet := GetIRecordSet;
  DestRecordSet := TDBAccessUtils.GetIRecordSet(UpdateQuery as TCustomDADataSet);

  CopyPropR(prEnableBoolean);
end;

procedure TCustomMyDataSetUpdater.CheckUpdateSQL(const SQL: string;
  const StatementTypes: TStatementTypes; UseGenerator: boolean = True);
var
  ICommand: TCRCommand;
  ParamInfo: TDAParamInfo;
  Offset, i: integer;
  Field: TField;
  FieldDesc: TCRFieldDesc;
begin
  if stRefresh in StatementTypes then
    for i := 0 to FDataSet.Fields.Count - 1 do begin
      Field := FDataSet.Fields[i];
      FieldDesc := TCRFieldDesc(FDataSet.GetFieldDesc(Field));
      if Field.FieldKind in [fkCalculated, fkInternalCalc] then
        FieldDesc.FieldDescKind := fdkCalculated;
    end;

  inherited;

  if FParamsInfo.Count = 0 then
    Exit;

  if UseSQLGeneratorParams(StatementTypes) and
    not ((stRefresh in StatementTypes) and (TDBAccessUtils.GetFullRefresh(FDataSet) or FDataSet.ReadOnly)) then begin
    ICommand := TDBAccessUtils.GetICommand(UpdateQuery);
    for i := 0 to FParamsInfo.Count - 1 do begin
      ParamInfo := FParamsInfo.Items[i];
      Offset := FDataSetService.SQLGenerator.GetParamOffset(ParamInfo);
      ParamInfo.StartPosition := ParamInfo.StartPosition + Offset;
      ParamInfo.EndPosition := ParamInfo.EndPosition + Offset;
    end;
    ICommand.ParamsInfo.Assign(FParamsInfo);
  end;
end;

function TCustomMyDataSetUpdater.IsRefreshQuickField(FieldDesc: TFieldDesc): boolean;
begin
  Result := TMySQLFieldDesc(FieldDesc).IsCurrentTimestamp = True;
end;

procedure TCustomMyDataSetUpdater.SaveMaxRefreshQuickValue(FieldDesc: TFieldDesc; const Value: variant);
var
  Field: TMySQLFieldDesc;
  CurrValue: TDateTime;
begin
  CurrValue := 0;
  if (not VarIsEmpty(Value)) and (not VarIsNull(Value)) then
    CurrValue := Value;
  Field := TMySQLFieldDesc(GetIRecordSet.FindField(FieldDesc.Name));
  if (Field <> nil) and (Field.TableInfo <> nil) and (Field = TMyTableInfo(Field.TableInfo).TimestampField) then begin
    if TMyTableInfo(Field.TableInfo).MaxTimestamp < CurrValue then
      TMyTableInfo(Field.TableInfo).MaxTimestamp := CurrValue;
  end;
end;

function TCustomMyDataSetUpdater.PerformLock: boolean;
begin
//  if not TDBAccessUtils.GetFetchAll(FDataSet) then
//    DatabaseError(SLockVsFetchAll);

  Result := inherited PerformLock;
end;

function TCustomMyDataSetUpdater.LockCompare(const Value1, Value2: variant): boolean;
var
  DateTime1, DateTime2: TDateTime;
  Hour, Min, Sec1, MSec1, Sec2, MSec2: Word;
begin
  Result := inherited LockCompare(Value1, Value2);
  if not Result and (VarType(Value1) = varDate) and (VarType(Value2) = varDate) then begin
    DateTime1 := Value1;
    DecodeTime(DateTime1, Hour, Min, Sec1, MSec1);
    ReplaceTime(DateTime1, EncodeTime(Hour, Min, 0, 0));
    DateTime2 := Value2;
    DecodeTime(DateTime2, Hour, Min, Sec2, MSec2);
    ReplaceTime(DateTime2, EncodeTime(Hour, Min, 0, 0));
    Result := (DateTime1 = DateTime2) and (Abs(Sec1 * 1000 + MSec1 - (Sec2 * 1000 + MSec2)) < 1000);
  end;
end;

{ TCustomMyDataSetService }

constructor TCustomMyDataSetService.Create(AOwner: TMemDataSet);
begin
  inherited;

  FAutoIncrementReadOnly := True;
  FSaveBlobsAsHex := True;
end;

destructor TCustomMyDataSetService.Destroy;
begin
  FUpdater := nil;
  inherited;
end;

procedure TCustomMyDataSetService.CreateDataSetUpdater;
begin
  SetDataSetUpdater(TCustomMyDataSetUpdater.Create(Self));
end;

procedure TCustomMyDataSetService.SetDataSetUpdater(Value: TDataSetUpdater);
begin
  inherited;

  FUpdater := TCustomMyDataSetUpdater(Value);
end;

procedure TCustomMyDataSetService.CreateSQLGenerator;
begin
  SetSQLGenerator(TCustomMySQLGenerator.Create(TDASQLGeneratorService));
end;

function TCustomMyDataSetService.DetectCanModify: boolean;
begin
  Assert(GetIRecordSet <> nil, 'FIRecordSet must be setted to this time');

  Result := inherited DetectCanModify or
    not (FDataSet.ReadOnly or FDataSet.UniDirectional) and
    (FIsAnyFieldCanBeModified or
    (FDataSet.SQLInsert.Count > 0) or
    (FDataSet.SQLUpdate.Count > 0) or
    (FDataSet.SQLDelete.Count > 0));
end;

procedure TCustomMyDataSetService.InitCursor;
var
  Field: TField;
  FieldDesc: TMySQLFieldDesc;
  i: integer;
begin
  inherited;

  for i := FDataSet.Fields.Count - 1 downto 0 do begin
    Field := FDataSet.Fields[i];

    if Field.FieldKind = fkData then begin
      FieldDesc := TMySQLFieldDesc(FDataSet.GetFieldDesc(Field));

      if FieldDesc.IsAutoIncrement then begin
        if FDataSet.Options.SetFieldsReadOnly and FAutoIncrementReadOnly then
          Field.ReadOnly := True;

      {$IFNDEF FPC}
        Field.AutoGenerateValue := arAutoInc;
      {$ENDIF}
      end;
    end;
  end;
end;

procedure TCustomMyDataSetService.FillFieldsDefaultValues;

  // Must be sync with MyClasses ConvertToDateTime!!!
  function DateTimeFromStr(const Def: string; FieldDesc: TMySQLFieldDesc; var Res: TDateTime): boolean;

    function WordAt(Off: integer): word;
    begin
      Result := Byte(Def[Off + 1]) - $30 {Ord('0')};
      Result := Result * 10 + (Byte(Def[Off + 2]) - $30);
    end;

    function IntAt(Off: integer): integer;
    begin
      Result := Byte(Def[Off + 1]) - $30 {Ord('0')};
      Result := Result * 10 + (Byte(Def[Off + 2]) - $30);
      Result := Result * 10 + (Byte(Def[Off + 3]) - $30);
      Result := Result * 10 + (Byte(Def[Off + 4]) - $30);
    end;

    function HourAt(var Off: integer): cardinal;
    begin
      if Byte(Def[Off + 1]) = Byte('-') then
        Inc(Off);
      Result := 0;
      while Byte(Def[Off + 1]) <> Byte(':') do begin
        if Result >= 1000 then
          DatabaseErrorFmt('Wrong time format at field %s', [FieldDesc.Name]);

        Result := Result * 10 + cardinal(Byte(Def[Off + 1]) - $30 {Ord('0')});
        Inc(Off);
      end;
    end;

    function MSecAt(Off: integer; Decimals: integer): cardinal;
    var
      i: integer;
    begin
      Result := 0;
      if Decimals > 0 then begin
        for i := 1 to Decimals do
          Result := Result * 10 + cardinal(Byte(Def[Off + i]) - $30 {Ord('0')});
        for i := Decimals + 1 to 6 do
          Result := Result * 10;
      end;
    end;

    function Year2: integer;
    begin
      Result := WordAt(0);
      if Result >= 70 then
        Result := 1900 + Result
      else
        Result := 2000 + Result;
    end;

  const
    HoursPerDay = 24;

  var
    IsNegative: boolean;
    Hour: Cardinal;
    dt: TDateTime;
    Off: integer;
  begin
    Result := True;

    case FieldDesc.MySQLType of
      FIELD_TYPE_TIMESTAMP:
        case FieldDesc.Length of
          21..26: // YYYY-MM-DD HH:MM:SS.Z ..  YYYY-MM-DD HH:MM:SS.ZZZZZZ
            Result := TryEncodeDateTime(IntAt(0), WordAt(5), WordAt(8), WordAt(11), WordAt(14), WordAt(17),
              MSecAt(20, FieldDesc.Scale) div 1000, Res);
          19: // YYYY-MM-DD HH:MM:SS
            Result := TryEncodeDateTime(IntAt(0), WordAt(5), WordAt(8), WordAt(11), WordAt(14), WordAt(17), 0, Res);
          14: // YYYYMMDDHHMMSS
            Result := TryEncodeDateTime(IntAt(0), WordAt(4), WordAt(6), WordAt(8), WordAt(10), WordAt(12), 0, Res);
          12: // YYMMDDHHMMSS
            Result := TryEncodeDateTime(Year2, WordAt(2), WordAt(4), WordAt(6), WordAt(8), WordAt(10), 0, Res);
          10: // YYMMDDHHMM
            Result := TryEncodeDateTime(Year2, WordAt(2), WordAt(4), WordAt(6), WordAt(8), 0, 0, Res);
          8:  // YYYYMMDD
            Result := TryEncodeDate(IntAt(0), WordAt(4), WordAt(6), Res);
          6:  // YYMMDD
            Result := TryEncodeDate(Year2, WordAt(2), WordAt(4), Res);
          4:  // YYMM
            Result := TryEncodeDate(Year2, WordAt(2), 1, Res);
          2:  // YY
            Result := TryEncodeDate(Year2, 1, 1, Res);
          else
            Assert(False, 'Invalid FIELD_TYPE_TIMESTAMP FieldDesc.Length (' + IntToStr(FieldDesc.Length) + ')');
        end;
      FIELD_TYPE_DATETIME: begin // YYYY-MM-DD HH:MM:SS
        Result := TryEncodeDate(IntAt(0), WordAt(5), WordAt(8), Res);
        if Result then begin
          Result := TryEncodeTime(WordAt(11), WordAt(14), WordAt(17), 0, dt);
          if Res >= 0 then
            Res := Res + dt
          else
            Res := Res - dt;
        end;
      end;
      FIELD_TYPE_DATE, FIELD_TYPE_NEWDATE: begin // YYYY-MM-DD
        Result := TryEncodeDate(IntAt(0), WordAt(5), WordAt(8), Res);
      end;
      FIELD_TYPE_TIME: begin // HH:MM:SS
        IsNegative := Byte(Def[1]) = Byte('-');
        Off := 0;
        Hour := HourAt(Off); // don't replace - Off is var parameter
        Res := (Hour * 3600 + WordAt(Off + 1) * 60 + WordAt(Off + 4)) / SecsPerDay;
        if IsNegative then
          Res := - Res;
      end;
    end;
  end;

  function HexToStr(const Value: string): string;
  var
    Buf: TBytes;
    Len: Integer;
  begin
    Len := Length(Value) shr 1;
    SetLength(Buf, Len);
  {$IFDEF VER12P}
    HexToBinW(@Value[1], @Buf[0], Len);
  {$ELSE}
    HexToBinA(@Value[1], @Buf[0], Len);
  {$ENDIF}
    Result := string(Encoding.UTF8.GetString(Buf)); //for international symbols
  end;

  function TrimBinaryStr(const Str: string): string;
  var
    i: integer;
  begin
    Result:= Str;
    for i := 1 to Length(Str) do
      if (i + 2) <= Length(Str) then
        if (Str[i + 1] = '\') and (Str[i + 2] = '0') then begin
          Result:= Copy(Str, 1, i);
          Exit;
        end;
  end;

  function GetIsMariaDBServer1027(Connection: TMySQLConnection): boolean;
  begin
    Result := Connection.IsMariaDB and ((Connection.ServerPrimaryVer > 10) or
      (Connection.ServerPrimaryVer = 10) and (Connection.ServerMinorVer > 2) or
      (Connection.ServerPrimaryVer = 10) and (Connection.ServerMinorVer = 2) and (Connection.ServerReleaseVer >= 7));
  end;

var
  Connection: TMySQLConnection;
  IsMariaDBServer1027: boolean;
  NameField, DefField: TField;
  FieldDesc: TMySQLFieldDesc;
  TableName, Schema: string;
  MetaData: TDAMetaData;
  FldName, Def: string;
  Field: TField;
  dt: TDateTime;
  p: integer;
  v: variant;
begin
  if not FDataSet.Options.DefaultValues or (FDataSet.Fields.Count = 0) or (GetIRecordSet.UpdatingTableInfo = nil) then
    Exit;

  TableName := GetIRecordSet.UpdatingTableInfo.TableNameFull;
  p := Pos('.', TableName);
  Connection := GetIConnection;
  IsMariaDBServer1027 :=  GetIsMariaDBServer1027(Connection);

  if p > 0 then begin
    Schema := Copy(TableName, 1, p - 1);
    TableName := Copy(TableName, p + 1, Length(TableName));
  end
  else begin
    Connection.GetProp(prDatabase, v);
    Schema := v;
  end;

  MetaData := UsedConnection.CreateMetaData;
  try
    MetaData.MetaDataKind := 'Columns';
    MetaData.Restrictions.Text := 'table_schema=' + Schema +
      #13#10'table_name=' + TableName;

    MetaData.Open;
    NameField := MetaData.FieldByName('COLUMN_NAME');
    DefField := MetaData.FieldByName('DEFAULT_VALUE');
    while not MetaData.Eof do begin
      if not DefField.IsNull then begin
        FldName := NameField.AsString;
        FieldDesc := GetIRecordSet.FindField(FldName) as TMySQLFieldDesc;

        if FieldDesc <> nil then begin
          Field := FDataSet.GetField(FieldDesc);
          if Field <> nil then begin
            Def := DefField.AsString;
            if IsMariaDBServer1027 then begin
               Def := AnsiDequotedStr(Def, '''');
               if (UpperCase(Def) = 'NULL')then
                Def := '';
            end;

            if DefaultExpressionOldBehavior then begin
              case Field.DataType of
                ftBoolean:
                  Field.DefaultExpression := BoolToStr(Def <> '0', True);
                ftFloat, ftBCD, ftFMTBCD:
                  Field.DefaultExpression := StringReplace(Def, '.', {$IFDEF USE_FORMATSETTINGS}FormatSettings.{$ENDIF}DecimalSeparator, [rfReplaceAll]);
                ftDateTime:
                  if (Def <> '') and DateTimeFromStr(Def, FieldDesc, dt) then
                    Field.DefaultExpression := DateTimeToStr(dt);
                ftDate:
                  if (Def <> '') and DateTimeFromStr(Def, FieldDesc, dt) then
                    Field.DefaultExpression := DateToStr(dt);
                ftTime:
                  if (Def <> '') and DateTimeFromStr(Def, FieldDesc, dt) then
                    Field.DefaultExpression := TimeToStr(dt);
                else
                  Field.DefaultExpression := Def;
              end;
            end
            else begin
              if Def <> 'CURRENT_TIMESTAMP' then
                if (Field.DataType in [ftDateTime, ftDate, ftTime]) and
                  ((Def = '') or not DateTimeFromStr(Def, FieldDesc, dt)) then
                  Def := ''
                else begin
                  if (FieldDesc.DBType = 222) or (FieldDesc.DBType = 223) then {myBinary or myVarBinary}
                    if not Connection.IsMariaDB and (Connection.ServerPrimaryVer >= 8) then
                      Def := HexToStr(Copy(Def, 3, Length(Def))) //delete 0x from string represetation
                    else if IsMariaDBServer1027 and (FieldDesc.DBType = 222) then
                      Def := TrimBinaryStr(Def);
                  Def := AnsiQuotedStr(Def, '''');
                end;
              Field.DefaultExpression := Def;
            end;
          end;
        end;
      end;
      MetaData.Next;
    end;
  finally
    MetaData.Free;
  end;
end;

function TCustomMyDataSetService.GetRecCount: integer;
var
  UQ: TCustomDADataSet;
  i: integer;
  MonitorClass: TDASQLMonitorClass;
  MessageID: cardinal;
  s: string;
begin
  Result := 0;
  if (not IsFetchAll and FDataSet.Options.QueryRecCount) // DefaultResultSet with FetchAll = False
    and not ((FDataSet.Params.Count > 0) and (FDataSet.Params[0].ParamType = ptResult)) then begin // Current SQL does not have RETURN parameter

    FUpdater.CheckUpdateQuery(stCustom);
    UQ := FUpdater.UpdateQuery as TCustomDADataSet;

    s := Trim(FDataSet.SQLRecCount.Text);
    if s = '' then
      s := FSQLGenerator.GenerateRecCountSQL;
    if s = '' then
      Exit;
    UQ.SQL.Text := s;

    UQ.Macros.Assign(FDataSet.Macros);
    for i := 0 to FDataSet.Params.Count - 1 do
      UQ.Params[i].Assign(FDataSet.Params[i]);

    MonitorClass := TDASQLMonitorClass(TDBAccessUtils.SQLMonitorClass(UsedConnection));
    if not TDBAccessUtils.GetLockDebug(FDataSet) and (MonitorClass.HasMonitor or FDataSet.Debug) then
      MonitorClass.SQLExecute(FDataSet, s, UQ.Params, 'Get RecCount', MessageID, True);

    FInGetRecCount := True;
    try
      UQ.Execute;
      Result := UQ.Fields[0].AsInteger;
    finally
      FInGetRecCount := False;
    end;

    if not TDBAccessUtils.GetLockDebug(FDataSet) and (MonitorClass.HasMonitor or FDataSet.Debug) then
      MonitorClass.SQLExecute(FDataSet, s, UQ.Params, 'Get RecCount', MessageID, False);
  end
  else
    Result := inherited GetRecCount;
end;

procedure TCustomMyDataSetService.BreakExec;
var
  UQ: TCustomDADataSet;
begin
  if FInGetRecCount then
    if FUpdater.UpdateQuery <> nil then begin
      UQ := FUpdater.UpdateQuery as TCustomDADataSet;
      UQ.BreakExec;
    end;
end;

function TCustomMyDataSetService.Executing: boolean;
begin
  Result := FInGetRecCount;
end;

procedure TCustomMyDataSetService.SetNumberRange(FieldDef: TFieldDef);
var
  Field: TField;
  FieldDesc: TMySQLFieldDesc;
{$IFNDEF FPC}
  e: Extended;
{$ENDIF}

begin
  Field := FDataSet.FindField(FieldDef.Name);
  if (Field <> nil) and (Field is TNumericField) then begin
    FieldDesc := TMySQLFieldDesc(FDataSet.GetFieldDesc(Field));
    case FieldDesc.MySQLType of // Must be sync with ConvertMySQLTypeToInternalFormat
      // Integer fields
      FIELD_TYPE_DECIMAL, FIELD_TYPE_NEWDECIMAL: begin // DECIMAL
        if Field is TFloatField then begin
          TFloatField(Field).MaxValue :=
            IntPower(10, FieldDesc.Length - FieldDesc.Scale) -
            IntPower(10, - Integer(FieldDesc.Scale));
          TFloatField(Field).MinValue := - TFloatField(Field).MaxValue;
        end
        else
        if Field is TBCDField then begin
          TBCDField(Field).MaxValue :=
            IntPower(10, FieldDesc.Length - FieldDesc.Scale) -
            IntPower(10, - Integer(FieldDesc.Scale));
          TBCDField(Field).MinValue := - TBCDField(Field).MaxValue;
        end
        else
      {$IFNDEF FPC}
        if Field is TFMTBCDField then begin
          e :=
            IntPower(10, FieldDesc.Length - FieldDesc.Scale) -
            IntPower(10, - Integer(FieldDesc.Scale));
          TFMTBCDField(Field).MaxValue := FloatToStr(e);
          TFMTBCDField(Field).MinValue := FloatToStr(- e);
        end
        else
      {$ENDIF}
          Assert(False, Field.ClassName);
      end;
      FIELD_TYPE_TINY: // TINYINT
        if FieldDesc.IsUnsigned then begin
          TIntegerField(Field).MinValue := 0;
          TIntegerField(Field).MaxValue := 255;
        end
        else begin
          TIntegerField(Field).MinValue := -128;
          TIntegerField(Field).MaxValue := 127;
        end;

      FIELD_TYPE_SHORT: // SMALLINT
        if FieldDesc.IsUnsigned then begin
          TIntegerField(Field).MinValue := 0;
          TIntegerField(Field).MaxValue := 65535;
        end
        else begin
          TIntegerField(Field).MinValue := -32768;
          TIntegerField(Field).MaxValue := 32767;
        end;

      FIELD_TYPE_LONG, FIELD_TYPE_LONGLONG: // INT
        if Field is {$IFNDEF FPC}TIntegerField{$ELSE}TLongintField{$ENDIF} then
          if FieldDesc.IsUnsigned then begin
            TIntegerField(Field).MinValue := 0;
            TIntegerField(Field).MaxValue := 0; // 4294967295; - not supported by Delphi
          end
          else begin
            TIntegerField(Field).MinValue := -2147483647;
            TIntegerField(Field).MaxValue := 2147483647;
          end;

      // FIELD_TYPE_LONGLONG:; // BIGINT - does not need to set bounds

      FIELD_TYPE_INT24: begin // MEDIUMINT
        Assert(Field is {$IFNDEF FPC}TIntegerField{$ELSE}TLongintField{$ENDIF});
        if FieldDesc.IsUnsigned then begin
          TIntegerField(Field).MinValue := 0;
          TIntegerField(Field).MaxValue := 16777215;
        end
        else begin
          TIntegerField(Field).MinValue := -8388608;
          TIntegerField(Field).MaxValue := 8388607;
        end;
      end;

      // Float fields
      FIELD_TYPE_FLOAT: begin // FLOAT
        TFloatField(Field).Precision := FieldDesc.Length;
        TFloatField(Field).MinValue := -3.402823466E+38;
        TFloatField(Field).MaxValue :=  3.402823466E+38;
      end;
      FIELD_TYPE_DOUBLE: begin // DOUBLE
        TFloatField(Field).Precision := FieldDesc.Length;
        TFloatField(Field).MinValue := -1.7976931348623157E+308;
        TFloatField(Field).MaxValue :=  1.7976931348623157E+308;
      end;

      FIELD_TYPE_YEAR: begin
        Assert(Field is {$IFNDEF FPC}TIntegerField{$ELSE}TLongintField{$ENDIF});
        case FieldDesc.Length of
          2: begin
            TIntegerField(Field).MinValue := 0;
            TIntegerField(Field).MaxValue := 99;
          end;
          4: begin
            TIntegerField(Field).MinValue := 0;
            TIntegerField(Field).MaxValue := 255;
          end;
          else
            Assert(False);
        end;
      end;
    end;
  end;
end;

procedure TCustomMyDataSetService.WriteFieldXMLDataType(Field: TField; FieldDesc: TFieldDesc; const FieldAlias: string; XMLWriter: XMLTextWriter);
begin
  inherited;

  if FieldDesc is TMySQLFieldDesc then
    if TMySQLFieldDesc(FieldDesc).IsAutoIncrement
      and not (Field.Required and not Field.ReadOnly) // Already writed in MemDS
    then
      XmlWriter.WriteAttributeString('rs:maybenull', 'false');
end;

procedure TCustomMyDataSetService.WriteFieldXMLAttributeType(Field: TField; FieldDesc: TFieldDesc; const FieldAlias: string; XMLWriter: XMLTextWriter);
begin
  inherited;

  if FieldDesc is TMySQLFieldDesc then
    if TMySQLFieldDesc(FieldDesc).MySQLType = FIELD_TYPE_TIMESTAMP then
      XmlWriter.WriteAttributeString('rs:rowver', 'true');
end;

function TCustomMyDataSetService.GetFieldXMLValue(Field: TField; FieldDesc: TFieldDesc): WideString;
begin
  if (FieldDesc.DataType = dtBlob) and not FSaveBlobsAsHex then
    Result := TMemDSUtils.GetBlob(FDataSet, FieldDesc).AsWideString
  else
    Result := inherited GetFieldXMLValue(Field, FieldDesc);
end;

function TCustomMyDataSetService.SetProp(Prop: integer; const Value: variant): boolean;
begin
  Result := True;
  case Prop of
    prCheckRowVersion:
      TCustomMySQLGenerator(SQLGenerator).CheckRowVersion := Value;
    prLockRecordType:
      TCustomMySQLGenerator(SQLGenerator).LockRecordType := TLockRecordTypeI(Value);
    prAutoIncrementReadOnly:
      FAutoIncrementReadOnly := Value;
    prSaveBlobsAsHex:
      FSaveBlobsAsHex := Value;
  else
    Result := inherited SetProp(Prop, Value);
  end;
end;

// Open next rowset in statement. if rowset is not returned then OpenNext returns False. If statement has error, then exception is raised
function TCustomMyDataSetService.OpenNext: boolean;
begin
  if FDataSet.Prepared then
    DatabaseError(SOpenNextPreparedSQL);

  if not FDataSet.Active then begin
    FDataSet.Open;
    Result := True;
  end
  else begin
    BeginConnection;
    try
      if IsFetchAll then
        DatabaseError(SOpenNextVsFetchAll);

      GetIRecordSet.SetProp(prOpenNext, True);
      TDBAccessUtils.SetLockDebug(FDataSet, True);
      try
        FDataSet.Close;
        FDataSet.UnPrepare;

        Result := GetIRecordSet.CheckNextResult;

        if Result then begin
          FDataSet.FieldDefs.Updated := False;
          FDataSet.Open;
        end;
      finally
        TDBAccessUtils.SetLockDebug(FDataSet, False);
        GetIRecordSet.SetProp(prOpenNext, False);
      end;
    finally
      EndConnection;
    end;
  end;
end;

function TCustomMyDataSetService.GetIConnection: TMySQLConnection;
begin
  Result := TMySQLConnection(TDBAccessUtils.GetIConnection(UsedConnection));
  Assert(Result <> nil); //upd should be error
end;

function TCustomMyDataSetService.GetIRecordSet: TMySQLRecordSet;
begin
  Result := TMySQLRecordSet(inherited GetIRecordSet);
end;

class procedure TCustomMyDataSetService.GetStoredProcNames(Connection: TMySQLConnection; Query: TCustomDADataSet;
  Database: string; List: TStrings);
var
  Major, Minor, Release: integer;
begin
  List.Clear;

  Major := Connection.ServerPrimaryVer;
  Minor := Connection.ServerMinorVer;
  Release := Connection.ServerReleaseVer;
  if Major < 5 then
    Exit;

  if (Major = 5) and (Minor = 0) and (Release = 0) then
    Query.SQL.Text := 'SELECT name FROM mysql.proc ORDER BY name'
  else begin
    if Database = '' then
      Database := '''mysql'''
    else // Can't use LOWER(Database) (5.0.9 bug)
      Database := '''' + AnsiLowerCase(MySQLInfo.NormalizeName(Database, False, True)) + '''';

    if (Major = 5) and (Minor = 0) and (Release < 4) then
      Query.SQL.Text := 'SELECT name FROM mysql.proc WHERE LOWER(db) = ' + Database + ' ORDER BY name'
    else
      Query.SQL.Text := 'SELECT ROUTINE_NAME FROM information_schema.routines WHERE LOWER(routine_schema) = ' + Database + ' ORDER BY ROUTINE_NAME';
  end;

  Query.Open;
  while not Query.Eof do begin
    List.Add(VarToStr(Query.Fields[0].Value));
    Query.Next;
  end;
end;

class procedure TCustomMyDataSetService.GetTriggerNames(Connection: TMySQLConnection; Query: TCustomDADataSet;
  Database: string; List: TStrings; AllTriggers: boolean = False);
const
  fmtGetTriggersSQL = 'SELECT TRIGGER_SCHEMA, TRIGGER_NAME ' +
    'FROM information_schema.TRIGGERS ' +
    '%s ORDER BY TRIGGER_SCHEMA, TRIGGER_NAME ';
var
  WhereClause: string;
  s, Name: string;
begin
  List.Clear;

  if Connection.ServerPrimaryVer < 5 then
    Exit;

  if not AllTriggers then begin
    if Database = '' then
      Database := '''mysql'''
    else // Can't use LOWER(Database) (5.0.9 bug)
      Database := '''' + AnsiLowerCase(MySQLInfo.NormalizeName(Database, False, True)) + '''';

    WhereClause := 'WHERE LOWER(TRIGGER_SCHEMA) = ' + Database;
  end
  else
    WhereClause := '';

  Query.SQL.Text := Format(fmtGetTriggersSQL, [WhereClause]);

  Query.Open;
  while not Query.Eof do begin
    Name := VarToStr(Query.Fields[1].Value);
    if AllTriggers then begin
      s := VarToStr(Query.Fields[0].Value);
      if s <> '' then
        Name := s + '.' + Name;
    end;
    List.Add(Name);

    Query.Next;
  end;
end;

{ TCustomMyDumpProcessor }

constructor TCustomMyDumpProcessor.Create(Owner: TDADump);
begin
  inherited;

  FBackupData := True;
{$IFDEF VER12P}
  FEncoding := Encoding.Default;
{$ENDIF}
end;

destructor TCustomMyDumpProcessor.Destroy;
begin
  FQueryView.Free;
  inherited;
end;

function TCustomMyDumpProcessor.SetProp(Prop: integer; const Value: variant): boolean;
begin
  Result := True;
  case Prop of
    prBackupTables:
      FBackupTables := Value;
    prBackupViews:
      FBackupViews := Value;
    prBackupData:
      FBackupData := Value;
    prBackupTriggers:
      FBackupTriggers := Value;
    prBackupStoredProcs:
      FBackupStoredProcs := Value;
    prAddLock:
      FAddLock := Value;
    prDisableKeys:
      FDisableKeys := Value;
    prHexBlob:
      FHexBlob := Value;
    prUseExtSyntax:
      FUseExtSyntax := Value;
    prUseDelayedIns:
      FUseDelayedIns := Value;
    prCommitBatchSize:
      FCommitBatchSize := Value;
    prInsertType:
      FInsertType := _TMyInsertType(Value);
    prFieldsAsString:
      FFieldsAsString := Value;
  else
    Assert(False, IntToStr(Prop));
    Result := False;
  end;
end;

function TCustomMyDumpProcessor.GetProp(Prop: integer; var Value: variant): boolean;
begin
  Result := True;
  case Prop of
    prBackupTables:
      Value := FBackupTables;
    prBackupViews:
      Value := FBackupViews;
    prBackupData:
      Value := FBackupData;
    prBackupTriggers:
      Value := FBackupTriggers;
    prBackupStoredProcs:
      Value := FBackupStoredProcs;
    prAddLock:
      Value := FAddLock;
    prDisableKeys:
      Value := FDisableKeys;
    prHexBlob:
      Value := FHexBlob;
    prUseExtSyntax:
      Value := FUseExtSyntax;
    prUseDelayedIns:
      Value := FUseDelayedIns;
    prCommitBatchSize:
      Value := FCommitBatchSize;
    prInsertType:
      Value := Variant(FInsertType);
    prFieldsAsString:
      Value := FFieldsAsString;
  else
    Assert(False, IntToStr(Prop));
    Result := False;
  end;
end;

procedure TCustomMyDumpProcessor.Backup(Query: string);
{$IFDEF VER12P}
const
  Utf8BOM: array[1..3] of byte = ($EF, $BB, $BF);
  UnicodeBOM: array[1..2] of byte = ($FF, $FE);
{$ENDIF}
var
  v: variant;
begin
  FIConnection := TMySQLConnection(TDBAccessUtils.GetIConnection(GetConnection));
  FIConnection.GetProp(prUseUnicode, v);
  FUseUnicode := v;

  if FUseUnicode then
    FCharset := 'utf8'
  else begin
    FIConnection.GetProp(prCharset, v);
    FCharset := LowerCase(v);
  end;

{$IFDEF VER12P}
  if GetStream <> nil then begin
    if FUseUnicode then begin
      FEncoding := Encoding.Unicode;
      GetStream.WriteBuffer(UnicodeBOM, Length(UnicodeBOM));
    end
    else
    if LowerCase(FCharset) = 'utf8' then begin
      FEncoding := Encoding.UTF8;
      GetStream.WriteBuffer(Utf8BOM, Length(Utf8BOM));
    end
    else
      FEncoding := Encoding.Default;
  end;

  inherited;
{$ELSE}
  FIConnection.SetProp(prUseUnicode, False);
  try
    inherited;
  finally
    FIConnection.SetProp(prUseUnicode, FUseUnicode);
  end;
{$ENDIF}
end;

{$IFDEF VER12P}
procedure TCustomMyDumpProcessor.Add(const Line: string);
var
  buf: TBytes;
begin
  if GetStream = nil then
    inherited
  else begin
    buf := FEncoding.GetBytes(Line + #$D#$A);
    GetStream.WriteBuffer(buf[0], Length(buf));
  end;
end;
{$ENDIF}

{$IFNDEF NEXTGEN}
procedure TCustomMyDumpProcessor.AddAnsiLine(const Line: AnsiString);
{$IFDEF VER12P}
var
  ws: WideString;
{$ENDIF}
begin
  if GetStream = nil then begin
    if FUseUnicode then
      Add(string(CRFunctions.UTF8Decode(Line)))
    else
      Add(string(Line))
  end
  else begin
  {$IFDEF VER12P}
    if FUseUnicode then begin
      ws := CRFunctions.UTF8Decode(Line) + #$D#$A;
      GetStream.WriteBuffer(ws[1], Length(ws) * sizeof(WideChar));
    end
    else
  {$ENDIF}
    begin
      GetStream.WriteBuffer(Line[1], Length(Line));
      GetStream.WriteBuffer(AnsiString(#$D#$A), 2);
    end;
  end
end;
{$ENDIF}

function TCustomMyDumpProcessor.CreateQuery: TCustomDADataSet;
var
  RecordSet: TCRRecordSet;
begin
  Result := GetConnection.CreateDataSet;
  TDBAccessUtils.CheckConnection(Result);
  Result.ReadOnly := True;
  Result.UniDirectional := True;
  Result.Options.QueryRecCount := False;
  Result.Options.LongStrings := False; // To prevent MySQL bug

  RecordSet := TDBAccessUtils.GetIRecordSet(Result);
  RecordSet.SetProp(prNullForZeroDate, False);
  RecordSet.SetProp(prCreateConnection, False);
  RecordSet.SetProp(prEnableBoolean, False);
  RecordSet.SetProp(prBinaryAsString, False);
end;

procedure TCustomMyDumpProcessor.AddSettings;
begin
  if FCharset <> '' then begin
    Add('/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;');
    Add('/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;');
    Add('/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;');
    Add('/*!40101 SET NAMES ' + FCharset + ' */;')
  end;

  if FBackupTables or FBackupData or FBackupViews then begin
    Add('/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;');
    Add('/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=''NO_AUTO_VALUE_ON_ZERO'' */;');
  end;
end;

procedure TCustomMyDumpProcessor.RestoreSettings;
begin
  if FBackupTables or FBackupData or FBackupViews then begin
    Add('/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;');
    Add('/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;');
  end;

  if FCharset <> '' then begin
    Add('/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;');
    Add('/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;');
    Add('/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;');
  end;
end;

function TCustomMyDumpProcessor.GetIsView(const TableName: string; TablesList: TStringList = nil): boolean;
var
  v: variant;
  Database: string;
  ObjName: string;
  NewSQL, WhereSQL: string;
  i: integer;
begin
  Result := False;
  if (FIConnection.ServerPrimaryVer < 5) or (TableName = '') then
    Exit;

  MySQLInfo.SplitObjectName(TableName, Database, ObjName);
  Database := MySQLInfo.NormalizeName(Database, False, True);
  ObjName := MySQLInfo.NormalizeName(ObjName, False, True);

  if not FQueryView.Active then begin
    if Database = '' then begin
      FIConnection.GetProp(prDatabase, v);
      Database := v;
    end;

    NewSQL := 'SHOW TABLE STATUS FROM ' + QuoteName(Database);
    if (GetTables.Count <> 0) and Assigned(TablesList) and (TablesList.Count > 0) then begin
      WhereSQL := 'WHERE NAME IN (';
      for i := 0 to TablesList.Count - 1 do begin
        WhereSQL := WhereSQL +  AnsiQuotedStr(TablesList[i], '''');
        if (i = TablesList.Count - 1) then
          WhereSQL := WhereSQL + ')'
        else
          WhereSQL := WhereSQL + ',';
      end;
      NewSQL := NewSQL + DALineSeparator + WhereSQL;
    end;
    FQueryView.SQL.Text := NewSQL;
    FQueryView.Open;
  end;

  if FQueryView.LocateEx('Name', ObjName, [lxCaseInsensitive]) then
    Result := FQueryView.FieldByName('Engine').AsString = '';
end;

procedure TCustomMyDumpProcessor.GetCurrentRow(const KeyAndDataFields: TKeyAndDataFields;
  CurrentRowSB: {$IFDEF NEXTGEN}StringBuilder{$ELSE}AnsiStringBuilder{$ENDIF});
var
  OldCurrentRowSBLen: integer;

  procedure ProcessField(Field: TField);
  var
    SValue: {$IFDEF NEXTGEN}string{$ELSE}AnsiString{$ENDIF};
    sa: AnsiString;
    FieldDesc: TMySQLFieldDesc;
    Blob: TBlob;
    sbOffset: integer;
  {$IFDEF VER12P}
    ws: WideString;
  {$ENDIF}
    Piece: PPieceHeader;
    Value: variant;
  {$IFNDEF NEXTGEN}
    Len: integer;
  {$ENDIF}
  begin
    if CurrentRowSB.Length > OldCurrentRowSBLen then
      CurrentRowSB.Append(',');

    if Field.DataSet = FQuery then
      FieldDesc := FQuery.GetFieldDesc(Field) as TMySQLFieldDesc
    else
      FieldDesc := FQuery.GetFieldDesc(Field.FieldName) as TMySQLFieldDesc; // Just in case.

    Blob := nil;
    if FieldDesc.IsBlob then
      Blob := TMemDSUtils.GetBlob(FQuery, FieldDesc);

    if Field.IsNull then
      CurrentRowSB.Append('NULL')
    else begin
      if FHexBlob and
        ((FieldDesc.IsBinary and (FieldDesc.MySQLType in [FIELD_TYPE_VAR_STRING, FIELD_TYPE_VARCHAR, FIELD_TYPE_STRING])) or
         (FieldDesc.DataType = dtBlob)) then begin
        if FieldDesc.DataType = dtBlob then begin
          Piece := Blob.FirstPiece;
          SetLength(SValue, Integer(Blob.Size) * 2);
          sbOffset := 0;
          while Piece <> nil do begin
            BinToHex(PtrOffset(Piece, sizeof(TPieceHeader)), {$IFDEF NEXTGEN}PChar{$ELSE}PAnsiChar{$ENDIF}({$IFDEF NEXTGEN}PChar{$ELSE}PAnsiChar{$ENDIF}(SValue) + sbOffset), Piece.Used);
            sbOffset := sbOffset + Integer(Piece.Used) * 2;
            Piece := Piece.Next;
          end;
        end
        else begin
          // dtString, dtExtString, dtWideString, dtExtWideString, dtBytes, dtVarBytes, dtExtVarBytes
        {$IFDEF NEXTGEN}
          if FieldDesc.DataType in [dtBytes, dtVarBytes, dtExtVarBytes] then
            sa := AnsiString(Field.AsBytes)
          else
            sa := AnsiString(Field.AsString);
        {$ELSE}
          sa := AnsiString(Field.{$IFDEF VER12P}AsAnsiString{$ELSE}AsString{$ENDIF});
        {$ENDIF}

          SetLength(SValue, Length(sa) * 2);
          BinToHex(PAnsiChar(sa), {$IFDEF NEXTGEN}PChar{$ELSE}PAnsiChar{$ENDIF}(SValue), Length(sa));
        end;

        if Length(SValue) > 0 then begin
          CurrentRowSB.Append('0x');
          CurrentRowSB.Append(SValue);
        end
        else
          CurrentRowSB.Append('''''');
      end
      else begin
      {$IFDEF VER12P}
        if FUseUnicode and
          (FieldDesc.DataType in [dtWideString, dtExtWideString]) then begin
          ws := Field.AsString;
          ws := FIConnection.EscapeAndQuoteWideStr(ws, Length(ws));
          CurrentRowSB.Append(CRFunctions.UTF8Encode(ws));
        end
        else
      {$ENDIF}
      {$IFNDEF NEXTGEN}
        if (FieldDesc.DataType in [dtString, dtExtString]) then begin
          if Field.DataSize > Length(FTmpBuf) then
            SetLength(FTmpBuf, Field.DataSize);
          if not Field.GetData(PAnsiChar(FTmpBuf)) then
            Len := 0
          else
            Len := StrLen(PAnsiChar(FTmpBuf));

          if FieldDesc.MySQLType in [FIELD_TYPE_DECIMAL, FIELD_TYPE_TINY, FIELD_TYPE_SHORT,
            FIELD_TYPE_LONG, FIELD_TYPE_FLOAT,  FIELD_TYPE_DOUBLE,
            FIELD_TYPE_LONGLONG, FIELD_TYPE_INT24, FIELD_TYPE_YEAR, FIELD_TYPE_NEWDECIMAL]
          then
            CurrentRowSB.Append(FTmpBuf, 0, Len)
          else
          if FieldDesc.MySQLType in [FIELD_TYPE_TIMESTAMP, FIELD_TYPE_DATE, FIELD_TYPE_TIME,
            FIELD_TYPE_DATETIME, FIELD_TYPE_NEWDATE]
          then begin
            CurrentRowSB.Append('''');
            CurrentRowSB.Append(FTmpBuf, 0, Len);
            CurrentRowSB.Append('''');
          end
          else
            CurrentRowSB.Append(FIConnection.EscapeAndQuoteStr(FTmpBuf, Len));
        end
        else
      {$ENDIF}
        begin
          Value := Unassigned;
          if Blob = nil then
            Value := Field.AsVariant
          else begin
            TVarData(Value).VType := varSharedObject;
            TVarData(Value).VPointer := Blob;
          end;

          // Data already is encoded in Unicode, therefore there's no need to encode it once again
          FIConnection.AppendValueToSQL(CurrentRowSB, FieldDesc.DataType, Value, False,
            {$IFDEF VER12P}(Blob <> nil) and FUseUnicode{$ELSE}False{$ENDIF} {$IFDEF HAVE_COMPRESS}, False{$ENDIF});
        end;
      end;
    end;
  end;

var
  i: integer;
begin
  OldCurrentRowSBLen := CurrentRowSB.Length;

  if Length(KeyAndDataFields.DataFieldDescs) = 0 then begin
    for i := 0 to FQuery.FieldCount - 1 do
      ProcessField(FQuery.Fields[i]);
  end
  else
    for i := 0 to Length(KeyAndDataFields.DataFieldDescs) - 1 do
      ProcessField(FQuery.GetField(KeyAndDataFields.DataFieldDescs[i]));
end;

procedure TCustomMyDumpProcessor.BackupTable(const Query: string; TableName: string; TableNum, TableCount: integer; IsView: boolean);
var
  KeyAndDataFields: TKeyAndDataFields;
  InsSize, RecordCount: integer;
  s: string;
  CurrentRowSB: {$IFDEF NEXTGEN}StringBuilder{$ELSE}AnsiStringBuilder{$ENDIF};
  InsHeader: string;
  NeedInsHeader: boolean;
  FieldList, FieldName: string;
  i, j, p: integer;
  SQLSelect: string;
  ShortTableName: string;
  Database: string;
  ReplaceTableNameNeed: boolean;
  v: variant;
  Percent: Integer;
begin
  if (TableName <> '') and ((FBackupTables and not IsView) or (FBackupViews and IsView)) then begin
    ReplaceTableNameNeed := False;
    if TableName[1] = '`' then begin
      i := 0;
      for p := 2 to Length(TableName) - 1 do
        if TableName[p] = '`' then begin
          if TableName[p + 1] = '.' then
            i := p + 1;
          break;
        end;
    end
    else
      i := Pos('.', TableName);

    if i <> 0 then begin
      Database := SQLInfo.UnQuote(Copy(TableName, 1, i - 1));
      FIConnection.GetProp(prDatabase, v);
      if Database <> v then begin
        ReplaceTableNameNeed := True;
        ShortTableName := '`' + SQLInfo.UnQuote(Copy(TableName, i + 1, Length(TableName) - i)) + '`';
        TableName := '`' + Database + '`' + '.' + ShortTableName;
      end;
    end;

    if FOwner.Options.GenerateHeader then
      AddLineToSQL(SBHTableStruct, [TableName]);

    if FOwner.Options.AddDrop then begin
      if IsView then
        Add('DROP VIEW IF EXISTS ' + TableName + ';')
      else
        Add('DROP TABLE IF EXISTS ' + TableName + ';');
    end;

    FQuery.SQL.Text := 'SHOW CREATE TABLE ' + TableName;
    FQuery.Open;

  {$IFDEF VER12P}
    if FQuery.Fields[1].DataType = ftVarBytes then // for MySQL ver 4.x
      s := string(AnsiString(FQuery.Fields[1].{$IFDEF NEXTGEN}AsBytes{$ELSE}AsAnsiString{$ENDIF})) + ';'
    else
  {$ENDIF}
      s := FQuery.Fields[1].AsString + ';';

    if ReplaceTableNameNeed then
      s := StringReplace(s, ShortTableName, TableName, []);

    AddLineToSQL(s);
    Add('');

    DoBackupProgress(TableName, TableNum, TableCount, 0);
  end;

  if not FBackupData or IsView then
    Exit;

  if FOwner.Options.GenerateHeader then
    AddLineToSQL(SBHTableData, [TableName]);

  if FOwner.Options.AddDrop and not FBackupTables then
    Add('TRUNCATE TABLE ' + TableName + ';');

  RecordCount := 0;
  if Query = '' then begin
    FQuery.SQL.Text := 'SELECT COUNT(*) FROM ' + TableName;
    FQuery.Open;
    RecordCount := FQuery.Fields[0].AsInteger;
  end;

  DoBackupProgress(TableName, TableNum, TableCount, 0);

  if (Query <> '') or (RecordCount > 0) then begin
    if FAddLock and not FUseDelayedIns then
      Add('LOCK TABLES ' + TableName + ' WRITE;');
    if FDisableKeys then
      Add('/*!40000 ALTER TABLE ' + TableName + ' DISABLE KEYS */;');

    if Query = '' then
      SQLSelect := 'SELECT * FROM ' + TableName
    else begin
      SQLSelect := Query;
      FQuery.Options.QueryRecCount := True;
    end;

    FQuery.SQL.Text := SQLSelect;
    TDBAccessUtils.GetIRecordSet(FQuery).SetProp(prFieldsAsString, FFieldsAsString);
    TDBAccessUtils.GetIRecordSet(FQuery).SetProp(prNumberFieldsAsString, True);
    TDBAccessUtils.GetIRecordSet(FQuery).DataTypeMap.Enabled := False;

    FQuery.Open;
    if Query <> '' then
      RecordCount := FQuery.RecordCount;

    case FInsertType of
      _itInsert:
        if FUseDelayedIns then
          InsHeader := 'INSERT DELAYED INTO '
        else
          InsHeader := 'INSERT INTO ';
      _itInsertIgnore:
        if FUseDelayedIns then
          InsHeader := 'INSERT DELAYED IGNORE INTO '
        else
          InsHeader := 'INSERT IGNORE INTO ';
      _itReplaceInto:
        if FUseDelayedIns then
          InsHeader := 'REPLACE DELAYED INTO '
        else
          InsHeader := 'REPLACE INTO ';
    else
      Assert(False);
    end;

    TDBAccessUtils.GetKeyAndDataFields(FQuery, KeyAndDataFields, False);

    if (Query <> '') or FOwner.Options.CompleteInsert then begin
      FieldList := '';
      for j := 0 to Length(KeyAndDataFields.DataFieldDescs) - 1 do begin
        FieldName := QuoteName(KeyAndDataFields.DataFieldDescs[j].Name);
        if FieldList = '' then
          FieldList := FieldName
        else
          FieldList := FieldList + ', ' + FieldName;
      end;

      InsHeader := InsHeader + TableName + '(' + FieldList + ') VALUES';
    end
    else
      InsHeader := InsHeader + TableName + ' VALUES';

    CurrentRowSB := {$IFDEF NEXTGEN}StringBuilder{$ELSE}AnsiStringBuilder{$ENDIF}.Create;
    try
      if not FUseExtSyntax then begin
        while not FQuery.Eof do begin
          Percent := Trunc((FQuery.RecNo / RecordCount) * 100);
          if Percent > 99 then
            Percent := 99;

          if (FCommitBatchSize > 0) and (FQuery.RecNo mod FCommitBatchSize = 1) then
            Add('BEGIN;');

          CurrentRowSB.Length := 0;
        {$IFDEF VER12P}
          if FUseUnicode then
            CurrentRowSB.Append(CRFunctions.UTF8Encode(InsHeader))
          else
        {$ENDIF}
            CurrentRowSB.Append(AnsiString(InsHeader));
          CurrentRowSB.Append(' (');
          GetCurrentRow(KeyAndDataFields, CurrentRowSB);
          CurrentRowSB.Append(');');

          {$IFDEF NEXTGEN}Add{$ELSE}AddAnsiLine{$ENDIF}(CurrentRowSB.ToString);
          FQuery.Next;

          if (FCommitBatchSize > 0) and ((FQuery.RecNo mod FCommitBatchSize = 1) or FQuery.Eof) then
            Add('COMMIT;');
          DoBackupProgress(TableName, TableNum, TableCount, Percent);
        end;
      end
      else begin
        InsSize := 0;
        NeedInsHeader := True;
        while not FQuery.Eof do begin
          Percent := Trunc((FQuery.RecNo / RecordCount) * 100);
          if Percent > 99 then
            Percent := 99;

          if NeedInsHeader then begin
            if FCommitBatchSize > 0 then
              Add('BEGIN;');

            Add(InsHeader);
            InsSize := Length(InsHeader) + 2;
            NeedInsHeader := False;
          end;

          CurrentRowSB.Length := 0;
          CurrentRowSB.Append(' (');
          GetCurrentRow(KeyAndDataFields, CurrentRowSB);
          CurrentRowSB.Append(')');
          FQuery.Next;

          Inc(InsSize, CurrentRowSB.Length + 2);
          if FQuery.Eof or (InsSize > 16384 {default net_buffer_length value} - 2 * CurrentRowSB.Length) then begin
            NeedInsHeader := True;
            CurrentRowSB.Append(';');

            if FCommitBatchSize > 0 then
              CurrentRowSB.Append(#$D#$A'COMMIT;');
          end
          else
            CurrentRowSB.Append(',');

          {$IFDEF NEXTGEN}Add{$ELSE}AddAnsiLine{$ENDIF}(CurrentRowSB.ToString);
          DoBackupProgress(TableName, TableNum, TableCount, Percent);
        end
      end;
    finally
      CurrentRowSB.Free;
      TDBAccessUtils.GetIRecordSet(FQuery).SetProp(prFieldsAsString, False);
      TDBAccessUtils.GetIRecordSet(FQuery).SetProp(prNumberFieldsAsString, False);
    end;

    if FDisableKeys then
      Add('/*!40000 ALTER TABLE ' + TableName + ' ENABLE KEYS */;');
    if FAddLock and not FUseDelayedIns then
      Add('UNLOCK TABLES;');
    Add('');
  end
  else
    if FOwner.Options.AddDrop and not FBackupTables then
      Add('');

  DoBackupProgress(TableName, TableNum, TableCount, 100);
end;

procedure TCustomMyDumpProcessor.BackupTablesAndData(const Query: string);
var
  TablesList: TStringList;
  TableName: string;
  IsView: boolean;
  ExactNames: boolean;
  i: integer;
begin
  if FQueryView = nil then begin
    FQueryView := GetConnection.CreateDataSet;
    FQueryView.ReadOnly := True;
  end
  else
    FQueryView.Connection := GetConnection;

{$IFNDEF NEXTGEN}
  SetLength(FTmpBuf, dsMaxStringSize + 1);
{$ENDIF}
  TablesList := TStringList.Create;
  try
    if Query = '' then begin
        if GetTables.Count = 0 then begin
          GetConnection.GetTableNames(TablesList);
          ExactNames := True;
        end
        else begin
          TablesList.Assign(GetTables);
          ExactNames := False;
        end;

        for i := 0 to TablesList.Count - 1 do begin
          if ExactNames then
            TablesList[i] := QuoteName(TablesList[i])
          else
            TablesList[i] := SQLInfo.NormalizeName(TablesList[i], FOwner.Options.QuoteNames);

          TablesList.Objects[i] := TObject(GetIsView(TablesList[i], TablesList));
        end;

        for IsView := False to True do begin
          for i := 0 to TablesList.Count - 1 do begin
            if Boolean({$IFDEF FPC}Integer{$ENDIF}(TablesList.Objects[i])) <> IsView then
              Continue;

            if IsView then begin
              if not FBackupViews then
                Continue;
            end
            else
              if not FBackupTables and not FBackupData then
                Continue;

            TableName := TablesList[i];
            DoBackupProgress(TableName, i, TablesList.Count, 0);
            BackupTable(Query, TableName, i, TablesList.Count, IsView);
          end;
        end;
    end
    else begin
      FQuery.SQL.Text := Query;
      FQuery.AddWhere('0=1');
      FQuery.Open;

      if TDBAccessUtils.GetTablesInfo(FQuery).Count > 0 then begin
        TableName := QuoteName(TDBAccessUtils.GetTablesInfo(FQuery)[0].TableName);
        TablesList.Add(TableName);
        IsView := GetIsView(TableName, TablesList);
      end
      else begin
        TableName := '';
        IsView := False;
      end;

      BackupTable(Query, TableName, 0, 1, IsView);
    end;
  finally
    TablesList.Free;
    FQueryView.Close;
    FQuery.Close;
  {$IFNDEF NEXTGEN}
    SetLength(FTmpBuf, 0);
  {$ENDIF}
  end;
end;

procedure TCustomMyDumpProcessor.GetStoredProcNames(List: TStrings);
var
  Database: string;
  v: variant;
begin
  FIConnection.GetProp(prDatabase, v);
  Database := v;

  TCustomMyDataSetService.GetStoredProcNames(FIConnection, FQuery, Database, List);
end;

procedure TCustomMyDumpProcessor.BackupStoredProc(const StoredProcName: string);
var
  v: variant;
  Database: string;
  PType: string;
  s: string;
begin
  FIConnection.GetProp(prDatabase, v);
  Database := v;

  if FIConnection.ServerPrimaryVer >= 8 then //No more mysql.proc in MySQL 8.0
    FQuery.SQL.Text := 'SELECT ROUTINE_TYPE FROM information_schema.routines WHERE (LOWER(routine_schema) = ''' + AnsiLowerCase(Database) + ''') AND (routine_name = ''' + MySQLInfo.UnQuote(StoredProcName) + ''') ORDER BY ROUTINE_TYPE'
  else
    FQuery.SQL.Text := 'SELECT type FROM mysql.proc WHERE (name = ''' + MySQLInfo.UnQuote(StoredProcName) + ''') AND (LOWER(db) = ''' + AnsiLowerCase(Database) + ''')';

  FQuery.Execute;
  PType := FQuery.Fields[0].AsString;

  if FOwner.Options.GenerateHeader then
    AddLineToSQL(SBHStoredProcStruct, [StoredProcName]);

  Add('DELIMITER $$');
  if FOwner.Options.AddDrop then
    Add('DROP ' + PType + ' IF EXISTS ' + QuoteName(StoredProcName) + ' $$');

  FQuery.SQL.Text := 'SHOW CREATE ' + PType + ' ' + StoredProcName;
  FQuery.Execute;
  s := FQuery.Fields[2].AsString + ' $$';
  AddLineToSQL(s);
  Add('DELIMITER ;');
  Add('');
end;

procedure TCustomMyDumpProcessor.BackupStoredProcedures;
var
  StoredProcsList: TStringList;
  StoredProcName: string;
  ExactNames: boolean;
  OldBinaryAsString: variant;
  i: integer;
begin
  StoredProcsList := TStringList.Create;
  try
    TDBAccessUtils.GetIRecordSet(FQuery).GetProp(prBinaryAsString, OldBinaryAsString);
    TDBAccessUtils.GetIRecordSet(FQuery).SetProp(prBinaryAsString, True);
    try
      if GetStoredProcs.Count = 0 then begin
        GetStoredProcNames(StoredProcsList);
        ExactNames := True;
      end
      else begin
        StoredProcsList.Assign(GetStoredProcs);
        ExactNames := False;
      end;

      for i := 0 to StoredProcsList.Count - 1 do begin
        if ExactNames then
          StoredProcName := QuoteName(StoredProcsList[i])
        else
          StoredProcName := SQLInfo.NormalizeName(StoredProcsList[i], FOwner.Options.QuoteNames);

        DoBackupProgress(StoredProcName, i, StoredProcsList.Count, 0);

        BackupStoredProc(StoredProcName);
        Add('');
      end;

    finally
      TDBAccessUtils.GetIRecordSet(FQuery).SetProp(prBinaryAsString, OldBinaryAsString);
    end;
  finally
    StoredProcsList.Free;
  end;
end;

procedure TCustomMyDumpProcessor.GetTriggerNames(List: TStrings);
var
  Database: string;
  v: variant;
begin
  FIConnection.GetProp(prDatabase, v);
  Database := v;

  TCustomMyDataSetService.GetTriggerNames(FIConnection, FQuery, Database, List);
end;

procedure TCustomMyDumpProcessor.BackupTrigger(const TableName, TriggerName: string);
var
  s: string;
  Name: string;
begin
  if TableName <> '' then
    FQuery.SQL.Text := 'SHOW TRIGGERS LIKE ''' + TableName + ''''
  else
    FQuery.SQL.Text := 'SHOW TRIGGERS WHERE `trigger` = ''' + TriggerName + '''';
  FQuery.Execute;

  if FQuery.RecordCount = 0 then
    Exit;

  Add('DELIMITER $$');

  while not FQuery.Eof do begin
    Name := FQuery.Fields[0].AsString;
    s := FQuery.Fields[3].AsString + ' $$';

    if FOwner.Options.GenerateHeader then
      AddLineToSQL(SBHTriggerStruct, [Name]);

    if FOwner.Options.AddDrop and not FBackupTables then
      Add('DROP TRIGGER IF EXISTS ' + Name + ' $$');

    Add('CREATE TRIGGER ' + Name + ' ' +
      FQuery.Fields[4].AsString + ' ' + FQuery.Fields[1].AsString +
      ' ON ' + FQuery.Fields[2].AsString + ' FOR EACH ROW');
    AddLineToSQL(s);
    Add('');
    FQuery.Next;
  end;

  Add('DELIMITER ;');
  Add('');
end;

procedure TCustomMyDumpProcessor.BackupTriggers;
var
  TriggersList: TStringList;
  TableName, TriggerName: string;
  i, p: integer;
begin
  if (GetTables.Count > 0) and (GetTriggers.Count = 0) then begin
    for i := 0 to GetTables.Count - 1 do begin
      TableName := GetTables[i];
      p := Pos('.', TableName);
      if p <> 0 then
        TableName := MySQLInfo.UnQuote(Copy(TableName, p + 1, Length(TableName) - p));

      DoBackupProgress(TableName, i, GetTables.Count, 0);
      BackupTrigger(TableName, '');
    end;
  end
  else begin
    TriggersList := TStringList.Create;
    try
      if GetTriggers.Count = 0 then
        GetTriggerNames(TriggersList)
      else
        TriggersList.Assign(GetTriggers);

      for i := 0 to TriggersList.Count - 1 do begin
        TriggerName := TriggersList[i];
        p := Pos('.', TriggerName);
        if p <> 0 then
          TriggerName := MySQLInfo.UnQuote(Copy(TriggerName, p + 1, Length(TriggerName) - p));

        DoBackupProgress(TriggerName, i, TriggersList.Count, 0);
        BackupTrigger('', TriggerName);
      end;
    finally
      TriggersList.Free;
    end;
  end;
end;

procedure TCustomMyDumpProcessor.BackupObjects(const Query: string);
begin
  Assert(FIConnection <> nil);
  CheckQuery;

  try
    if FBackupStoredProcs then
      BackupStoredProcedures;

    if FBackupTables or FBackupData or FBackupViews then
      BackupTablesAndData(Query);

    if FBackupTriggers then
      BackupTriggers;
  finally
    FQuery.Close;
  end;
end;

end.
