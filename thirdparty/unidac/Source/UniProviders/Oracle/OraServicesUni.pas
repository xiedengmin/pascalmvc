
//////////////////////////////////////////////////
//  Oracle Data Access Components
//  Copyright (c) 1998-2021 Devart. All right reserved.
//////////////////////////////////////////////////

{$I Odac.inc}
unit OraServicesUni;

interface

uses
{$IFDEF MSWINDOWS}
  Windows, Registry,
{$ENDIF}
  Classes, SysUtils, Variants, DB,
{$IFDEF NEXTGEN}
  Generics.Collections,
{$ENDIF}
  CLRClasses, CRTypes, CRXml, CRAccess, MemData,
  {$IFNDEF FPC}MemDS{$ELSE}MemDataSet{$ENDIF},
  DBAccess, DADump, DASQLGenerator,
{$IFNDEF UNIDACPRO}
  OraCall, OraSQLGenerator;
{$ELSE}
  OraCallUni, OraSQLGeneratorUni;
{$ENDIF}

const
  prSequenceMode = 101; // integer

type
  TCustomOraDataSetService = class;

  TCustomOraFieldTypeMap = class(TDAFieldTypeMap)
    class function GetDataType(FieldType: TFieldType; SubDataType: Word = 0): integer; override;
    class function GetFieldType(DataType: Word): TFieldType; override;
  end;

  TCustomOraDataSetUpdater = class(TDADataSetUpdater)
  private
    function GetDataSetService: TCustomOraDataSetService;
  protected
    procedure GetSequenceNextVal;
    function GetIdentityFieldValue(var Value: variant): boolean; override;

    function UseParamType(Param: TDAParam): boolean; override;
    procedure SetUpdateQuery(Value: TComponent); override;
    procedure SetDefaultParamType(Param: TDAParam); override;

    function IsNeedInsertPreconnect: boolean; override;
    function IsNeedEditPreconnect: boolean; override;
    function IsPreconnected: boolean; override;

    function PrepareBatch(const SQL: string): string; override;

    procedure CheckUpdateQuery(const StatementType: TStatementType); override;
    procedure SetUpdateQueryOptions(const StatementType: TStatementType; const IsAutoGeneratedSQL: Boolean); override;
    procedure UpdateExecute(const StatementTypes: TStatementTypes); override;

    procedure PrepareAppend; override;
    function PerformAppend: boolean; override;

    property DataSetService: TCustomOraDataSetService read GetDataSetService;
  public
    constructor Create(AOwner: TDataSetService); override;

    function PerformSQL(const SQL: string; const StatementTypes: TStatementTypes): boolean; override;
    function GetDefaultExpressionValue(DefExpr: string; out Value: variant): boolean; override;
  end;

  TCustomOraDataSetService = class(TDADataSetService)
  private
    function GetUpdater: TCustomOraDataSetUpdater;
  protected
    FScrollableCursor: boolean;

    procedure CreateDataSetUpdater; override;
    procedure CreateSQLGenerator; override;

    function DetectHiddenFields: TFieldArray; override;
    function DetectCanModify: boolean; override;

    function GetRecCount: integer; override;

    function CompatibilityMode: boolean; virtual;
    function GetFieldClass(FieldType: TFieldType; DataType: Word): TFieldClass; override;
    function GetCurrentSchema: string; override;

  { XML }
    procedure WriteFieldXMLDataType(Field: TField; FieldDesc: TFieldDesc; const FieldAlias: string;
      XMLWriter: XMLTextWriter); override;
    function GetFieldXMLValue(Field: TField; FieldDesc: TFieldDesc): WideString; override;

    property Updater: TCustomOraDataSetUpdater read GetUpdater;
  public
    function SetProp(Prop: integer; const Value: variant): boolean; override;

    function GetDBKeyList(const TableName, IndexName: string): string; override;
    function OpenNext: boolean; override;
    function NeedParamValuesOnPrepare: boolean; override;
    procedure ResetTableKeyFields; override;
  end;

  TCustomDBOraSQLGenerator = class(TCustomOraSQLGenerator)
  public
    function GenerateSQL(ParamsInfo: TDAParamsInfo;
      const StatementType: _TStatementType;
      const ModifiedFieldsOnly: boolean;
      const Index: Integer = -1): string; override;
  end;

  TCustomOraDumpProcessor = class(TDADumpProcessor)
  protected
    function CreateQuery: TCustomDADataSet; override;
  end;

implementation

uses
  CRProps, CRFunctions, CRParser, MemUtils, DAConsts, DASQLMonitor,
{$IFNDEF UNIDACPRO}
  OraProps, OraClasses, OraParser;
{$ELSE}
  OraPropsUni, OraClassesUni, OraParserUni;
{$ENDIF}

{ TCustomOraFieldTypeMap }

const
  OraDataTypeMap: array [TFieldType] of word = (
  //ftUnknown, ftString, ftSmallint, ftInteger, ftWord
    dtUnknown, dtString, dtSmallint, dtInteger, dtWord,
  //ftBoolean, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime
    dtBoolean, dtFloat, dtCurrency, dtBCD, dtDate, dtTime, dtDateTime,
  //ftBytes, ftVarBytes, ftAutoInc, ftBlob, ftMemo, ftGraphic, ftFmtMemo
    dtBytes, dtVarBytes, 0,         dtBlob, dtMemo, 0,         0,
  //ftParadoxOle, ftDBaseOle, ftTypedBinary, ftCursor, ftFixedChar, ftWideString
    0,            0,          0,             dtCursor, dtFixedChar, dtWideString,
  //ftLargeint, ftADT,    ftArray, ftReference, ftDataSet, ftOraBlob, ftOraClob
    dtLargeInt, dtObject, dtArray, dtReference, dtTable,   dtOraBlob, dtOraClob,
  //ftVariant, ftInterface, ftIDispatch,  ftGuid,
    0,         0,           0,            dtGuid,
  //             ftTimeStamp,    ftFMTBcd,
    {$IFNDEF FPC}dtSQLTimeStamp,{$ELSE}0,{$ENDIF} dtFMTBcd
  {$IFDEF FPC}
    //ftFixedWideChar, ftWideMemo,
    , dtFixedWideChar, dtWideMemo
  {$ENDIF}
  {$IFDEF VER10P}
    //ftFixedWideChar, ftWideMemo, ftOraTimeStamp, ftOraInterval,
    , dtFixedWideChar, dtWideMemo, dtTimeStamp,    0
  {$IFDEF VER12P}
    //ftLongWord, ftShortint, ftByte,    ftExtended, ftConnection, ftParams, ftStream
    , dtUInt32,   dtInt8,     dtUInt8,   dtExtended, 0,            0,        0
  {$ENDIF}
  {$IFDEF VER14P}
    //ftTimeStampOffset, ftObject, ftSingle
    , 0,                 dtObject, dtSingle
  {$ENDIF}
  {$ENDIF}
  );

class function TCustomOraFieldTypeMap.GetDataType(FieldType: TFieldType; SubDataType: Word = 0): integer;
begin
{$IFNDEF FPC}
{$IFNDEF VER10P}
  if Integer(FieldType) = Integer(ftFixedWideChar) then
    Result := dtFixedWideChar
  else
{$ENDIF}
{$ENDIF}
    Result := OraDataTypeMap[FieldType];
end;

class function TCustomOraFieldTypeMap.GetFieldType(DataType: Word): TFieldType;
begin
  case DataType of
    dtOraBlob:
      Result := ftOraBlob;
    dtOraClob, dtWideOraClob:
      Result := ftOraClob;
    dtFixedChar:
      Result := ftFixedChar;
    dtFixedWideChar:
      Result := TFieldType(ftFixedWideChar);
  {$IFNDEF FPC}
    dtSQLTimeStamp:
      Result := ftTimeStamp;
  {$ENDIF}
    dtUndefined, dtTimeStamp, dtTimeStampTZ, dtTimeStampLTZ, dtBFile, dtLabel,
    dtIntervalYM, dtIntervalDS, dtNumber, dtXML:
      Result := ftUnknown;
  else
    Result := inherited GetFieldType(DataType);
  end;
end;

{ TCustomOraUpdater }

constructor TCustomOraDataSetUpdater.Create(AOwner: TDataSetService);
begin
  inherited;

  FOptionsForAutoGeneratedSQL := True;
end;

function TCustomOraDataSetUpdater.GetDataSetService: TCustomOraDataSetService;
begin
  Result := TCustomOraDataSetService(FDataSetService);
end;

function TCustomOraDataSetUpdater.GetIdentityFieldValue(var Value: variant): boolean;
var
  Command: TOCICommand;
  RowId: string;
begin
  Command := TOCICommand(TDBAccessUtils.GetICommand(TCustomDADataSet(UpdateQuery)));
  Assert(Command <> nil);
  RowId := Command.GetRowId;
  Result := RowID <> '';
  if Result then
    Value := RowID;
end;

procedure TCustomOraDataSetUpdater.CheckUpdateQuery(const StatementType: TStatementType);
begin
  inherited;

  TDBAccessUtils.GetICommand(UpdateQuery as TCustomDADataSet).SetProp(prStoreRowId, True);
end;

procedure TCustomOraDataSetUpdater.SetUpdateQueryOptions(const StatementType: TStatementType; const IsAutoGeneratedSQL: Boolean);
var
  DestCommand, SourceCommand: TCRCommand;

  procedure CopyPropC(Prop: integer);
  var
    v: variant;
  begin
    SourceCommand.GetProp(Prop, v);
    DestCommand.SetProp(Prop, v);
  end;

begin
  CheckIRecordSet; // can be inactive
  SourceCommand := GetICommand;
  DestCommand := TDBAccessUtils.GetICommand(UpdateQuery as TCustomDADataSet);

  CopyPropC(prCacheLobs);
  CopyPropC(prFieldsAsString);
  CopyPropC(prRawAsString);
  if IsAutoGeneratedSQL then
    DestCommand.SetProp(prTemporaryLobUpdate, False)
  else
    CopyPropC(prTemporaryLobUpdate);
end;

procedure TCustomOraDataSetUpdater.UpdateExecute(const StatementTypes: TStatementTypes);

  procedure ResetOutputParams(Params: TDAParams);
  var
    i: integer;
    Commnad: TCRCommand;
    ParamDesc: TParamDesc;
  begin
    // to fix bug with InputOutput NVARCHAR params for Oracle 10
    Commnad := TDBAccessUtils.GetICommand(UpdateQuery);
    if (Commnad <> nil) and (Commnad.Params.Count = Params.Count) then
      for i := 0 to Commnad.Params.Count - 1 do begin
        ParamDesc := Commnad.Params[i];
        if not TOraParamDesc(ParamDesc).GetCanBeOutput then
          if ParamDesc.GetName = Params[i].Name then
            Params[i].ParamType := ptInput;
      end;
  end;

var
  i: integer;
  Param: TDAParam;
  Params: TDAParams;
  Field: TField;
begin
  Params := TDBAccessUtils.GetParams(UpdateQuery);

  if NeedReturnParams or (stRefresh in StatementTypes) then
    for i := 0 to Params.Count - 1 do begin
      Param := Params[i];
      if Param.ParamType = ptUnknown then
        if not (Param.DataType in [ftOraBlob, ftOraClob]) then
          Param.ParamType := ptInputOutput;
    end;

  ResetOutputParams(Params);

  // Update ROWID value for successful Refresh after Update on Post or on
  // ApplyUpdaes (UROWID)
  if (stRefresh in StatementTypes) and ((FDataSet.State = dsEdit) or FDataSet.InCacheProcessing)
    and (DataSetService.IdentityField <> nil)
  then begin
    Param := Params.FindParam('OLD_ROWID');
    Field := FDataSet.GetField(DataSetService.IdentityField);
    if (Param <> nil) and (Field <> nil) then
      Param.Value := Field.Value;
  end;
  inherited;
end;

function TCustomOraDataSetUpdater.PerformSQL(const SQL: string; const StatementTypes: TStatementTypes): boolean;
var
  RowId: string;
  Command: TOCICommand;
  Connection: TOCIConnection;
begin
  BeginConnection;
  try
    Result := inherited PerformSQL(SQL, StatementTypes);

    if Result and (stUpdate in StatementTypes) then begin
      RowId := TOCICommand(TDBAccessUtils.GetICommand(TCustomDADataSet(UpdateQuery))).GetRowId;
      if (RowId <> '') and (RowId[1] = '*') then // UROWID was returned
        SetIdentityFieldValue; // for correct updates when UROWID was changed
    end;

    Connection := TOCIConnection(TDBAccessUtils.GetIConnection(UsedConnection));

    if Result and 
       (Connection.OCISvcCtx.Home.OCIVersion >= 8150) and (Connection.OCISvcCtx.Home.OCIVersion < 9000) and
       (stInsert in StatementTypes) and (DataSetService.IdentityField <> nil)
    then begin
      Command := TOCICommand(TDBAccessUtils.GetICommand(TCustomDADataSet(UpdateQuery)));
      if (Command.GetRowId = '')
        and (Connection.GetOracleVersion > 8000) and (Connection.GetOracleVersion < 8100)
      then begin
        TCustomDADataSet(UpdateQuery).SQL.Text := 'select 1 from sys.dual where 1=0';
        TCustomDADataSet(UpdateQuery).Execute;
        TCustomDADataSet(UpdateQuery).Close;
      end;
    end;
  finally
    EndConnection;
  end;
end;

function TCustomOraDataSetUpdater.GetDefaultExpressionValue(DefExpr: string; out Value: variant): boolean;
begin
  DefExpr := AnsiUpperCase(Trim(DefExpr));
  if (DefExpr = 'EMPTY_BLOB()') or (DefExpr = 'EMPTY_CLOB()') then begin
    Value := '';
    Result := True;
  end
  else
    Result := inherited GetDefaultExpressionValue(DefExpr, Value);
end;

procedure TCustomOraDataSetUpdater.PrepareAppend;
begin
  if (DataSetService.KeyGeneratorField <> nil) and (TCustomDBOraSQLGenerator(DataSetService.SQLGenerator).SequenceMode = _smInsert) then
    GetSequenceNextVal;
end;

function TCustomOraDataSetUpdater.PerformAppend: boolean;
var
  OldReturnParams: boolean;
begin
  OldReturnParams := FDataSet.Options.ReturnParams;
  if DataSetService.KeyGeneratorField <> nil then
    if ((FDataSet.SQLInsert.Count > 0) or ((GetUpdateObject <> nil)
      and (GetUpdateObject.InsertSQL.Count > 0))) and
      (TCustomDBOraSQLGenerator(DataSetService.SQLGenerator).SequenceMode = _smPost)
    then
      GetSequenceNextVal
    else
      FDataSet.Options.ReturnParams := True;

  try
    Result := inherited PerformAppend;
  finally
    FDataSet.Options.ReturnParams := OldReturnParams;
  end;
end;

procedure TCustomOraDataSetUpdater.GetSequenceNextVal;
var
  OldReturnParams: boolean;
begin
  if DataSetService.KeyGeneratorField <> nil then begin
    OldReturnParams := FDataSet.Options.ReturnParams;
    FDataSet.Options.ReturnParams := True;
    try
      if OCISQLInfo.QuotesNeeded(DataSetService.KeyGeneratorField.Name) then
        PerformSQL('begin' + DALineSeparator + '  SELECT ' +
          DataSetService.SQLGenerator.KeySequence + '.NEXTVAL INTO :' +
          IntToStr(DataSetService.KeyGeneratorField.FieldNo) + ' FROM Sys.Dual;' + DALineSeparator + 'end;', [stCustom])
      else
        PerformSQL('begin' + DALineSeparator + '  SELECT ' +
          DataSetService.SQLGenerator.KeySequence + '.NEXTVAL INTO :' +
          OCISQLInfo.QuoteIfNeed(DataSetService.KeyGeneratorField.Name) +' FROM Sys.Dual;' + DALineSeparator + 'end;', [stCustom]);
    finally
      FDataSet.Options.ReturnParams := OldReturnParams;
    end;
  end;
end;

function TCustomOraDataSetUpdater.PrepareBatch(const SQL: string): string;
begin
  Result := 'BEGIN' + #13#10 + SQL + #13#10 + 'END;'
end;

function TCustomOraDataSetUpdater.IsNeedEditPreconnect: boolean;
var
  vHasObjectFields: variant;
begin
  Result := not FDataSet.CachedUpdates and (GetLockMode = lmPessimistic);
  if not Result then begin
    GetIRecordSet.GetProp(prHasObjectFields, vHasObjectFields);
    Result := (vHasObjectFields = True);
  end;
end;

function TCustomOraDataSetUpdater.IsPreconnected: boolean;
var
  vHasObjectFields: variant;
begin
  Result := inherited IsPreconnected;
  if UsedConnection.Options.DisconnectedMode then begin         //in case of Object fields there is pre-connection during
    GetIRecordSet.GetProp(prHasObjectFields, vHasObjectFields); //InitRecord, so we should call EndConnection after post or cancel
    Result := Result or (vHasObjectFields = True);
  end;
end;

function TCustomOraDataSetUpdater.UseParamType(Param: TDAParam): boolean;
begin
  Result := Param.ParamType <> ptUnknown;
end;

procedure TCustomOraDataSetUpdater.SetUpdateQuery(Value: TComponent);
var
  RecordSet: TCRRecordSet;
begin
  inherited;

  if Value is TCustomDADataSet then begin
    TDBAccessUtils.CheckIRecordSet(TCustomDADataSet(Value));
    RecordSet := TDBAccessUtils.GetIRecordSet(TCustomDADataSet(Value));
  end
  else
    RecordSet := nil;
  TCustomOraSQLGenerator(GetDataSetService.SQLGenerator).IUpdateRecordSet := RecordSet;
end;

procedure TCustomOraDataSetUpdater.SetDefaultParamType(Param: TDAParam);
begin
  if Param.DataType in [ftOraBlob, ftOraClob] then
    Param.ParamType := ptInput
  else if NeedReturnParams then
    Param.ParamType := ptInputOutput
  else
    Param.ParamType := ptInput;
end;

function TCustomOraDataSetUpdater.IsNeedInsertPreconnect: boolean;
begin
  Result := (TCustomDBOraSQLGenerator(DataSetService.SQLGenerator).SequenceMode = _smInsert);
end;

{ TCustomOraDataSetService }

procedure TCustomOraDataSetService.CreateDataSetUpdater;
begin
  SetDataSetUpdater(TCustomOraDataSetUpdater.Create(Self));
end;

procedure TCustomOraDataSetService.CreateSQLGenerator;
begin
  SetSQLGenerator(TCustomDBOraSQLGenerator.Create(TDASQLGeneratorService));
end;

function TCustomOraDataSetService.GetUpdater: TCustomOraDataSetUpdater;
begin
  Result := TCustomOraDataSetUpdater(FUpdater);
end;

function TCustomOraDataSetService.DetectHiddenFields: TFieldArray;
var
  i: integer;
  FieldDesc: TCRFieldDesc;
  RecordSet: TOCIRecordSet;
  Field: TField;
  v: variant;
begin
  Result := nil;
  RecordSet := TOCIRecordSet(GetIRecordSet);
  RecordSet.GetProp(prHideRowId, v);
  if not v then
    exit;
  for i := 0 to RecordSet.Fields.Count - 1 do begin
    FieldDesc := TCRFieldDesc(RecordSet.Fields[i]);
    if CompareText(FieldDesc.ActualName, 'ROWID') = 0 then begin
      Field := FDataSet.GetField(FieldDesc);
      if Field <> nil then begin
        SetLength(Result, Length(Result) + 1);
        Result[Length(Result) - 1] := Field;
      end;
    end;
  end;
end;

function TCustomOraDataSetService.DetectCanModify: boolean;
begin
  Result :=
    (inherited DetectCanModify or
     not FDataSet.ReadOnly and
     FIsAnyFieldCanBeModified and
     (not CompatibilityMode or
      (FDataSet.SQLInsert.Count > 0) or
      (FDataSet.SQLUpdate.Count > 0) or
      (FDataSet.SQLDelete.Count > 0))) and
    not (FScrollableCursor); // can't modify scrollable cursor
end;

function TCustomOraDataSetService.SetProp(Prop: integer; const Value: variant): boolean;
begin
  Result := True;
  case Prop of
    prSequenceMode:
      TCustomDBOraSQLGenerator(SQLGenerator).SequenceMode := _TSequenceMode(Value);
    prScrollableCursor:
      FScrollableCursor := Value;
  else
    Result := inherited SetProp(Prop, Value);
  end;
end;

function TCustomOraDataSetService.GetDBKeyList(const TableName, IndexName: string): string;
var
  Connection: TOCIConnection;
begin
  if IndexName = '' then begin
    BeginConnection; // GetDBKeyList requires an active connection
    try
      Connection := TOCIConnection(TDBAccessUtils.GetIConnection(UsedConnection));
      Result := Connection.GetDBKeyList(TableName);
    finally
      EndConnection;
    end
  end
  else
    Result := inherited GetDBKeyList(TableName, IndexName);
end;

function TCustomOraDataSetService.OpenNext: boolean;
var
  Cursor: TCRCursor;
begin
  if not FDataSet.Active then begin
    FDataSet.Open;
    Result := True;
  end
  else begin
    Cursor := TOCICommand(GetIRecordSet.GetCommand).GetNextCursor;
    if Cursor <> nil then begin
      GetIRecordSet.SetProp(prOpenNext, True);
      TDBAccessUtils.SetLockDebug(FDataSet, True);
      try
        FDataSet.Close;
        TDBAccessUtils.SetCursor(FDataSet, Cursor);
        FDataSet.Open;
      finally
        TDBAccessUtils.SetLockDebug(FDataSet, False);
        GetIRecordSet.SetProp(prOpenNext, False);
      end;
      Result := True;
    end
    else
      Result := False;
  end;
end;

function TCustomOraDataSetService.NeedParamValuesOnPrepare: boolean;
begin
  Result := True;
end;

procedure TCustomOraDataSetService.ResetTableKeyFields;
var
  RecordSet: TOCIRecordSet;
begin
  if UpperCase(FDataSet.KeyFields) <> 'ROWID' then begin
    RecordSet := TOCIRecordSet(GetIRecordSet);
    if RecordSet <> nil then
      RecordSet.SetProp(prKeyFields, '');
    FDataSet.KeyFields := '';
  end;
end;

function TCustomOraDataSetService.GetRecCount: integer;
var
  St: string;
  UpdateQuery: TCustomDADataSet;
  MonitorClass: TDASQLMonitorClass;
  MessageID: cardinal;
begin
  Result := 0;
  St := Trim(FDataSet.SQLRecCount.Text);
  if St = '' then
    St := FSQLGenerator.GenerateRecCountSQL;

  Updater.CheckUpdateQuery(stCustom);
  UpdateQuery := TCustomDADataSet(Updater.UpdateQuery);
  UpdateQuery.SQL.Text := St;
  UpdateQuery.Params.Assign(FDataSet.Params);

  UpdateQuery.Prepare;
  if TOCICommand(TDBAccessUtils.GetICommand(UpdateQuery)).GetSQLType = SQL_SELECT then begin
    MonitorClass := TDASQLMonitorClass(TDBAccessUtils.SQLMonitorClass(UsedConnection));
    if MonitorClass.HasMonitor or FDataSet.Debug then
      MonitorClass.SQLExecute(FDataSet, St, UpdateQuery.Params, 'Get RecordCount', MessageID, True);

    UpdateQuery.Open;
    if not UpdateQuery.EOF then
      Result := UpdateQuery.Fields[0].AsInteger;

    if MonitorClass.HasMonitor or FDataSet.Debug then
      MonitorClass.SQLExecute(FDataSet, St, UpdateQuery.Params, 'Get RecordCount', MessageID, False);
  end;
end;

function TCustomOraDataSetService.CompatibilityMode: boolean;
begin
  Result := False;
end;

function TCustomOraDataSetService.GetFieldClass(FieldType: TFieldType; DataType: Word): TFieldClass;
{$IFDEF VER10P}
var
  Value: variant;
{$ENDIF}
begin
{$IFDEF VER10P}
  if FieldType = ftOraClob then
    if DataType = dtWideOraClob then
      Result := TWideMemoField
    else if DataType = dtOraClob then
      Result := TMemoField
    else begin
      TDBAccessUtils.GetIConnection(UsedConnection).GetProp(prUseUnicode, Value);
      if Boolean(Value) then
        Result := TWideMemoField
      else
        Result := TMemoField;
    end
  else
{$ENDIF}
    Result := inherited GetFieldClass(FieldType, DataType);
end;

function TCustomOraDataSetService.GetCurrentSchema: string;
begin
  Result := TOCIConnection(TDBAccessUtils.GetIConnection(UsedConnection)).GetCachedSchema;
  // to preserve character case
  Result := '"' + Result + '"'; // ???
end;

procedure TCustomOraDataSetService.WriteFieldXMLDataType(Field: TField; FieldDesc: TFieldDesc; const FieldAlias: string;
  XMLWriter: XMLTextWriter);
var
  Length: integer;
begin
  case FieldDesc.Datatype of
    dtNumber: begin
      Length := FieldDesc.Length;
      if FieldDesc.Scale <> 0 then
        Inc(Length);
    end;
    dtTimeStamp, dtTimeStampTZ, dtTimeStampLTZ, dtIntervalYM, dtIntervalDS:
      Length := 50;
  else
    Length := 0;
  end;

  case FieldDesc.Datatype of
    dtNumber, dtTimeStamp, dtTimeStampTZ, dtTimeStampLTZ, dtIntervalYM, dtIntervalDS: begin
      XmlWriter.WriteAttributeString('dt:type', 'string');
      XmlWriter.WriteAttributeString('dt:maxLength', IntToStr(Length));
      XmlWriter.WriteAttributeString('rs:dbtype', 'str');
    end;
    dtOraBlob, dtBFILE: begin
      XmlWriter.WriteAttributeString('dt:type', 'bin.hex');
      XmlWriter.WriteAttributeString('dt:maxLength', '2147483647');
      XmlWriter.WriteAttributeString('rs:long', 'true');
    end;
    dtOraClob, dtWideOraClob, dtCFILE, dtXML: begin
      XmlWriter.WriteAttributeString('dt:type', 'string');
      XmlWriter.WriteAttributeString('dt:maxLength', '2147483647');
      if FieldDesc.DataType <> dtWideOraClob then
        XmlWriter.WriteAttributeString('rs:dbtype', 'str');
      XmlWriter.WriteAttributeString('rs:long', 'true');
    end;
  else
    inherited;
    Exit;
  end;

  if Field.Required and not Field.ReadOnly then
    XmlWriter.WriteAttributeString('rs:maybenull', 'false');
end;

function TCustomOraDataSetService.GetFieldXMLValue(Field: TField; FieldDesc: TFieldDesc): WideString;
var
  Blob: TBlob;
  Piece: PPieceHeader;
  sbOffset: integer;
  StrValue: string;
begin
  case FieldDesc.DataType of
    dtOraBlob, dtBFILE: begin
      Blob := FDataSet.GetBlob(Field);
      Piece := Blob.FirstPiece;
      SetLength(StrValue, Blob.Size * 2);
      sbOffset := 1;
      while Piece <> nil do begin
        BinToHex(PtrOffset(Piece, sizeof(TPieceHeader)), PChar(@StrValue[sbOffset]), Piece.Used);
        sbOffset := sbOffset + Piece.Used * 2;
        Piece := Piece.Next;
      end;
      Result := WideString(StrValue);
    end;
    dtOraClob, dtWideOraClob, dtCFILE: begin
      Blob := FDataSet.GetBlob(Field);
      Result := Blob.AsWideString; // Unicode CLOBs support
    end;
  else
    Result := inherited GetFieldXMLValue(Field, FieldDesc);
  end;
end;

{ TCustomDBOraSQLGenerator }

function TCustomDBOraSQLGenerator.GenerateSQL(ParamsInfo: TDAParamsInfo;
  const StatementType: _TStatementType;
  const ModifiedFieldsOnly: boolean;
  const Index: Integer = -1): string;
var
  DataSet: TCustomDADataSet;
begin
  DataSet := TDASQLGeneratorService(FService).DataSet;
  if TCustomOraDataSetService(TDBAccessUtils.GetDataSetService(DataSet)).CompatibilityMode then
    Result := ''
  else
    Result := inherited GenerateSQL(ParamsInfo, StatementType, ModifiedFieldsOnly, Index);
end;

{ TCustomOraDumpProcessor }

function TCustomOraDumpProcessor.CreateQuery: TCustomDADataSet;
begin
  Result := GetConnection.CreateDataSet;
  Result.ReadOnly := True;
  Result.UniDirectional := True;
  Result.Options.QueryRecCount := True;
  TDBAccessUtils.CheckConnection(Result);
  TDBAccessUtils.GetIRecordSet(Result).SetProp(prFetchAll, False);
end;

end.

