//////////////////////////////////////////////////
//  Oracle Data Access Components Net
//  Copyright (c) 1998-2019 Devart. All right reserved.
//  OraNetCrypt (OCI Lite)
//////////////////////////////////////////////////
{$I Odac.inc}
unit OraNetAnoUni;
interface
{$IFDEF ODAC}
{$A+,C-,D-,G+,J-,L-,M-,O+,Y-,Z1}
{$ENDIF}
{$Q-,R-,W+}
uses
{$IFDEF UNIX}
cwstring,
{$ENDIF}
{$IFDEF MSWINDOWS}
Windows,
{$ENDIF}
Classes,Types,SysUtils,StrUtils,DateUtils,
CRTypes,CRFunctions,CLRClasses,CRSspi,MemUtils,
CRBigInteger,CRRNG,CRSymmetricAlgorithm,CRHashAlgorithm,CRCipher,CRHash,CRHMAC,
{$IFNDEF UNIDACPRO}
OraNet,OraNetClasses;
{$ELSE}
OraNetUni,OraNetClassesUni;
{$ENDIF}
type
OCC0CCC0Q0=class;
OOOQOQC0Q0=class
private
{$IFDEF AUTOREFCOUNT}[weak]{$ENDIF}
OQOQOQC0Q0:OO00OQCOQ0;
{$IFDEF AUTOREFCOUNT}[weak]{$ENDIF}
OCOQOQC0Q0:OCC0CCC0Q0;
O0QQOQC0Q0:TByteArr;
OOQQOQC0Q0:Word;
OQQQOQC0Q0:Cardinal;
OCQQOQC0Q0:TSecurityLevel;
O0CQOQC0Q0:Integer;
protected
function OOCQOQC0Q0(const OQCQOQC0Q0:string):Integer;
function OCCQOQC0Q0:Integer;
procedure O00COQC0Q0(PacketSize,OO0COQC0Q0:Word);
procedure OQ0COQC0Q0(PacketSize,OC0COQC0Q0,O0OCOQC0Q0:Word);
procedure OOOCOQC0Q0(OQOCOQC0Q0:Integer);
procedure OCOCOQC0Q0;virtual;
function O0QCOQC0Q0(const OOQCOQC0Q0:TStringArray;const OQQCOQC0Q0:string):Byte;
function O0CCOQC0Q0(const OOCCOQC0Q0:TStringArray;const OQCCOQC0Q0:TStringArray;OCCCOQC0Q0:boolean=true):TStringArray;
procedure OQO0OQC0Q0;virtual;
procedure OCO0OQC0Q0(O0Q0OQC0Q0:Byte);
function OOQ0OQC0Q0:Byte;
procedure OQQ0OQC0Q0(OCQ0OQC0Q0:Word);
function O0C0OQC0Q0:Word;
procedure OOC0OQC0Q0(OQC0OQC0Q0:Cardinal);
function OCC0OQC0Q0:Cardinal;
procedure O00OOQC0Q0(const OO0OOQC0Q0:string);
function O0OOOQC0Q0:string;
procedure OQOOOQC0Q0(const OCOOOQC0Q0:TWordArr);
function OOQOOQC0Q0:TWordArr;
procedure OQCOOQC0Q0;
function OCCOOQC0Q0:Cardinal;
procedure O00Q0QC0Q0(const OO0Q0QC0Q0:TBytes);
function OC0Q0QC0Q0:TBytes;
procedure OOOQ0QC0Q0(OQOQ0QC0Q0:Word);
function OCOQ0QC0Q0:Word;
procedure O0QQ0QC0Q0(PacketSize,OOQQ0QC0Q0:Word);
function OQQQ0QC0Q0(OCQQ0QC0Q0:Word):Word;
procedure OOCQ0QC0Q0(OQCQ0QC0Q0:Word);
class function OCCQ0QC0Q0(O00C0QC0Q0:OO00OQCOQ0):OQQCQCCOQ0;
function OO0C0QC0Q0:Integer;virtual;abstract;
procedure OQ0C0QC0Q0;virtual;abstract;
procedure OC0C0QC0Q0(O0OC0QC0Q0:Integer);virtual;abstract;
public
constructor Create(OQOC0QC0Q0:OCC0CCC0Q0);
class function OCOC0QC0Q0:Cardinal;
function O0QC0QC0Q0:Integer;virtual;
end;
OOQC0QC0Q0=class(OOOQOQC0Q0)
private
OQQC0QC0Q0:Integer;
protected
procedure OCOCOQC0Q0;override;
procedure OQO0OQC0Q0;override;
function OO0C0QC0Q0:Integer;override;
procedure OQ0C0QC0Q0;override;
procedure OC0C0QC0Q0(O0OC0QC0Q0:Integer);override;
public
function O0QC0QC0Q0:Integer;override;
end;
OOCC0QC0Q0=class(OOOQOQC0Q0)
private
OQCC0QC0Q0:Boolean;
protected
procedure OCOCOQC0Q0;override;
procedure OQO0OQC0Q0;override;
function OO0C0QC0Q0:Integer;override;
procedure OQ0C0QC0Q0;override;
procedure OC0C0QC0Q0(O0OC0QC0Q0:Integer);override;
public
function O0QC0QC0Q0:Integer;override;
end;
OOQ00QC0Q0=class(OOOQOQC0Q0)
private
OQQ00QC0Q0:TBytes;
OCQ00QC0Q0:TWordArr;
O0C00QC0Q0:TWordArr;
OOC00QC0Q0:Integer;
OQC00QC0Q0:Integer;
protected
procedure OQO0OQC0Q0;override;
function OO0C0QC0Q0:Integer;override;
procedure OQ0C0QC0Q0;override;
procedure OC0C0QC0Q0(O0OC0QC0Q0:Integer);override;
function OQ0O0QC0Q0:TByteArr;
public
constructor Create(OQOC0QC0Q0:OCC0CCC0Q0);
function O0QC0QC0Q0:Integer;override;
end;
OC0O0QC0Q0=class(OOOQOQC0Q0)
private
O0OO0QC0Q0:TStringArray;
OOOO0QC0Q0:Boolean;
OQOO0QC0Q0:Word;
OCOO0QC0Q0:string;
O0QO0QC0Q0:boolean;
protected
procedure OQO0OQC0Q0;override;
function OO0C0QC0Q0:Integer;override;
procedure OQ0C0QC0Q0;override;
procedure OC0C0QC0Q0(O0OC0QC0Q0:Integer);override;
public
constructor Create(OQOC0QC0Q0:OCC0CCC0Q0);
function O0QC0QC0Q0:Integer;override;
property O0CO0QC0Q0:boolean read O0QO0QC0Q0 write O0QO0QC0Q0;
end;
OCC0CCC0Q0=class
private
{$IFDEF AUTOREFCOUNT}[weak]{$ENDIF}
O00OCCC0Q0:OO00OQCOQ0;
OO0OCCC0Q0:Word;
OQ0OCCC0Q0:Word;
OC0OCCC0Q0:Word;
O0OOCCC0Q0:Byte;
OOOOCCC0Q0:Byte;
OQOOCCC0Q0:Integer;
OCOOCCC0Q0:TBytes;
O0QOCCC0Q0:TBytes;
OOQOCCC0Q0:TBytes;
OQQOCCC0Q0:boolean;
OCQOCCC0Q0:TCRObjectList;
O0COCCC0Q0:THashAlgorithm;
OOCOCCC0Q0:TSymmetricAlgorithm;
OQCOCCC0Q0:TSymmetricAlgorithm;
OCCOCCC0Q0:Boolean;
O00QQCC0Q0:Boolean;
function OO0QQCC0Q0:OC0O0QC0Q0;
function OQ0QQCC0Q0:OOQC0QC0Q0;
function OC0QQCC0Q0:OOCC0QC0Q0;
function O0OQQCC0Q0:OOQ00QC0Q0;
protected
procedure OOOQQCC0Q0;
procedure OCOQQCC0Q0(O0QQQCC0Q0:OC0O0QC0Q0;const OOQQQCC0Q0,OQQQQCC0Q0:string);
public
constructor Create(O0CQQCC0Q0:OO00OQCOQ0);
destructor Destroy;override;
function OQCQQCC0Q0:Boolean;
procedure OCCQQCC0Q0(O00CQCC0Q0,OO0CQCC0Q0,OQ0CQCC0Q0:Word;OC0CQCC0Q0,O0OCQCC0Q0:Byte);
procedure OOOCQCC0Q0;
procedure OC00QCC0Q0(const O0O0QCC0Q0:TBytes);
procedure OOO0QCC0Q0(const OQO0QCC0Q0:TBytes);
procedure OCO0QCC0Q0(const O0Q0QCC0Q0:TBytes);
procedure OOQ0QCC0Q0(const OQQ0QCC0Q0:TBytes);
function OOC0QCC0Q0:TBytes;
function OQC0QCC0Q0:TBytes;
procedure OCC0QCC0Q0(O00OQCC0Q0,OO0OQCC0Q0:Word;OQ0OQCC0Q0:Byte);
function OC0OQCC0Q0:OQQCQCCOQ0;
function OOOOQCC0Q0(const OQOOQCC0Q0:TBytes;const OCOOQCC0Q0:Integer):Integer;
function OOQOQCC0Q0(const OQQOQCC0Q0:TBytes;const OCQOQCC0Q0:Integer):Integer;
procedure OQCOQCC0Q0;
property OCCOQCC0Q0:Boolean read OCCOCCC0Q0;
property O00QOQC0Q0:Boolean read O00QQCC0Q0 write O00QQCC0Q0;
property OO0QOQC0Q0:OC0O0QC0Q0 read OO0QQCC0Q0;
property OQ0QOQC0Q0:OOQC0QC0Q0 read OQ0QQCC0Q0;
property OC0QOQC0Q0:OOCC0QC0Q0 read OC0QQCC0Q0;
property O0OQOQC0Q0:OOQ00QC0Q0 read O0OQQCC0Q0;
end;
{$IFDEF MSWINDOWS}
OOCO0QC0Q0=class(TCRNTLMAuth)
private
OQCO0QC0Q0:OO00OQCOQ0;
protected
procedure OCCO0QC0Q0(const O00QCQC0Q0:TBytes);
function O0OQCQC0Q0:TBytes;
procedure OOOQCQC0Q0(const OQOQCQC0Q0:TBytes);
procedure O0CQCQC0Q0(var OOCQCQC0Q0:TBytes;OQCQCQC0Q0:Integer;OCCQCQC0Q0:boolean);
procedure O0OCCQC0Q0(var OOOCCQC0Q0:TBytes);
public
constructor Create(O0CQQCC0Q0:OO00OQCOQ0);
procedure O0QCCQC0Q0;
end;
{$ENDIF}
implementation
uses
{$IFNDEF UNIDACPRO}
OraNetCrypt;
{$ELSE}
OraNetCryptUni;
{$ENDIF}
constructor OOOQOQC0Q0.Create(OQOC0QC0Q0:OCC0CCC0Q0);
begin
inherited Create;
OCOQOQC0Q0:=OQOC0QC0Q0;
OQOQOQC0Q0:=OQOC0QC0Q0.O00OCCC0Q0;
O0CQOQC0Q0:=-1;
end;
function OOOQOQC0Q0.OOCQOQC0Q0(const OQCQOQC0Q0:string):Integer;
begin
Result:=0;
if OQCQOQC0Q0<>'' then
if OQCQOQC0Q0='ACCEPTED' then
Result:=0
else if OQCQOQC0Q0='REQUESTED' then
Result:=2
else if OQCQOQC0Q0='REQUIRED' then
Result:=3
else if OQCQOQC0Q0='REJECTED' then
Result:=1
else
Result:=-1;
end;
function OOOQOQC0Q0.OCCQOQC0Q0:Integer;
begin
Result:=8+OO0C0QC0Q0;
end;
procedure OOOQOQC0Q0.O00COQC0Q0(PacketSize,OO0COQC0Q0:Word);
begin
case OO0COQC0Q0 of
0,1:
;
2:
if PacketSize>1 then
O00QCQOOQ0(-6312);
3,6:
if PacketSize>2 then
O00QCQOOQ0(-6312);
4,5:
if PacketSize>4 then
O00QCQOOQ0(-6312);
7:
if PacketSize<10 then
O00QCQOOQ0(-6312);
else
O00QCQOOQ0(-6313);
end;
end;
procedure OOOQOQC0Q0.OQ0COQC0Q0(PacketSize,OC0COQC0Q0,O0OCOQC0Q0:Word);
begin
if OC0COQC0Q0=O0OCOQC0Q0 then
O00COQC0Q0(PacketSize,O0OCOQC0Q0)
else
O00QCQOOQ0(-6314);
end;
procedure OOOQOQC0Q0.OOOCOQC0Q0(OQOCOQC0Q0:Integer);
begin
OC0C0QC0Q0(OQOCOQC0Q0);
OQO0OQC0Q0;
end;
procedure OOOQOQC0Q0.OCOCOQC0Q0();
begin
end;
function OOOQOQC0Q0.O0QCOQC0Q0(const OOQCOQC0Q0:TStringArray;const OQQCOQC0Q0:string):Byte;
var
OCQCOQC0Q0:Byte;
begin
Result:=0;
for OCQCOQC0Q0:=0 to Length(OOQCOQC0Q0)-1 do
if OQQCOQC0Q0=OOQCOQC0Q0[OCQCOQC0Q0]then begin
Result:=OCQCOQC0Q0;
Exit;
end;
O00QCQOOQ0(-6309);
end;
function OOOQOQC0Q0.O0CCOQC0Q0(const OOCCOQC0Q0:TStringArray;const OQCCOQC0Q0:TStringArray;OCCCOQC0Q0:boolean=true):TStringArray;
var
O000OQC0Q0,OO00OQC0Q0:Integer;
OQ00OQC0Q0:boolean;
OC00OQC0Q0:boolean;
O0O0OQC0Q0:boolean;
OOO0OQC0Q0:boolean;
begin
OQ00OQC0Q0:=Length(OOCCOQC0Q0)=0;
OC00OQC0Q0:=False;
O0O0OQC0Q0:=False;
if OQ00OQC0Q0 then
if OCCCOQC0Q0 then
OC00OQC0Q0:=True
else
O0O0OQC0Q0:=True
else if Length(OOCCOQC0Q0)=1 then
if OOCCOQC0Q0[0]='ALL' then
OC00OQC0Q0:=True
else if OOCCOQC0Q0[0]='NONE' then
O0O0OQC0Q0:=True;
SetLength(Result,0);
if OC00OQC0Q0 then
if OQCCOQC0Q0[0]='' then begin
SetLength(Result,Length(OQCCOQC0Q0)-1);
for O000OQC0Q0:=1 to Length(OQCCOQC0Q0)-1 do
Result[O000OQC0Q0-1]:=OQCCOQC0Q0[O000OQC0Q0];
end
else
Result:=OQCCOQC0Q0
else if(O0O0OQC0Q0)then
Exit
else begin
for O000OQC0Q0:=0 to Length(OOCCOQC0Q0)-1 do begin
if OOCCOQC0Q0[O000OQC0Q0]='' then
O00QCQOOQ0(12649);
OOO0OQC0Q0:=False;
for OO00OQC0Q0:=0 to Length(OQCCOQC0Q0)-1 do
if OQCCOQC0Q0[OO00OQC0Q0]=UpperCase(OOCCOQC0Q0[O000OQC0Q0])then begin
OOO0OQC0Q0:=True;
break;
end;
if not OOO0OQC0Q0 then
O00QCQOOQ0(12649);
end;
Result:=OOCCOQC0Q0;
end;
end;
procedure OOOQOQC0Q0.OQO0OQC0Q0;
begin
raise Exception.Create('ValidateResponse');
end;
procedure OOOQOQC0Q0.OCO0OQC0Q0(O0Q0OQC0Q0:Byte);
begin
O0QQ0QC0Q0(1,2);
OQOQOQC0Q0.OOCOCQCOQ0(O0Q0OQC0Q0);
end;
function OOOQOQC0Q0.OOQ0OQC0Q0:Byte;
begin
OQQQ0QC0Q0(2);
Result:=OQOQOQC0Q0.OQC0QQCOQ0;
end;
procedure OOOQOQC0Q0.OQQ0OQC0Q0(OCQ0OQC0Q0:Word);
begin
O0QQ0QC0Q0(2,3);
OQOQOQC0Q0.OO0QQQCOQ0(OCQ0OQC0Q0);
end;
function OOOQOQC0Q0.O0C0OQC0Q0:Word;
begin
OQQQ0QC0Q0(3);
Result:=OQOQOQC0Q0.OO0OQQCOQ0;
end;
procedure OOOQOQC0Q0.OOC0OQC0Q0(OQC0OQC0Q0:Cardinal);
begin
O0QQ0QC0Q0(4,4);
OQOQOQC0Q0.OOOQQQCOQ0(OQC0OQC0Q0);
end;
function OOOQOQC0Q0.OCC0OQC0Q0:Cardinal;
begin
OQQQ0QC0Q0(4);
Result:=OQOQOQC0Q0.OC0OQQCOQ0;
end;
procedure OOOQOQC0Q0.O00OOQC0Q0(const OO0OOQC0Q0:string);
var
OQ0OOQC0Q0:TBytes;
OC0OOQC0Q0:Integer;
begin
OQ0OOQC0Q0:=Encoding.UTF8.GetBytes(OO0OOQC0Q0);
OC0OOQC0Q0:=Length(OQ0OOQC0Q0);
O0QQ0QC0Q0(OC0OOQC0Q0,0);
if OC0OOQC0Q0>0 then
OQOQOQC0Q0.OOQ0CQCOQ0(@OQ0OOQC0Q0[0],OC0OOQC0Q0);
end;
function OOOQOQC0Q0.O0OOOQC0Q0:string;
var
OOOOOQC0Q0:Word;
begin
OOOOOQC0Q0:=OQQQ0QC0Q0(0);
Result:=OQOQOQC0Q0.OCQOQQCOQ0(OOOOOQC0Q0);
end;
procedure OOOQOQC0Q0.OQOOOQC0Q0(const OCOOOQC0Q0:TWordArr);
var
O0QOOQC0Q0:Integer;
begin
O0QQ0QC0Q0(10+Length(OCOOOQC0Q0)*2,1);
OQOQOQC0Q0.OOOQQQCOQ0($DEADBEEF);
OQOQOQC0Q0.OO0QQQCOQ0(3);
OQOQOQC0Q0.OOOQQQCOQ0(Length(OCOOOQC0Q0));
for O0QOOQC0Q0:=0 to Length(OCOOOQC0Q0)-1 do
OQOQOQC0Q0.OO0QQQCOQ0(OCOOOQC0Q0[O0QOOQC0Q0]);
end;
function OOOQOQC0Q0.OOQOOQC0Q0:TWordArr;
var
OQQOOQC0Q0:Cardinal;
OCQOOQC0Q0:Cardinal;
O0COOQC0Q0:Word;
OOCOOQC0Q0:Cardinal;
begin
OQQQ0QC0Q0(1);
OCQOOQC0Q0:=OQOQOQC0Q0.OC0OQQCOQ0;
O0COOQC0Q0:=OQOQOQC0Q0.OO0OQQCOQ0;
if(OCQOOQC0Q0<>$DEADBEEF)or(O0COOQC0Q0<>3)then
O00QCQOOQ0(-6310);
OOCOOQC0Q0:=OQOQOQC0Q0.OC0OQQCOQ0;
SetLength(Result,OOCOOQC0Q0);
for OQQOOQC0Q0:=0 to OOCOOQC0Q0-1 do
Result[OQQOOQC0Q0]:=OQOQOQC0Q0.OO0OQQCOQ0;
end;
procedure OOOQOQC0Q0.OQCOOQC0Q0;
begin
O0QQ0QC0Q0(4,5);
OQOQOQC0Q0.OOOQQQCOQ0(OCOC0QC0Q0);
end;
function OOOQOQC0Q0.OCCOOQC0Q0:Cardinal;
begin
OQQQ0QC0Q0(5);
Result:=OQOQOQC0Q0.OC0OQQCOQ0;
end;
procedure OOOQOQC0Q0.O00Q0QC0Q0(const OO0Q0QC0Q0:TBytes);
var
OQ0Q0QC0Q0:Integer;
begin
OQ0Q0QC0Q0:=Length(OO0Q0QC0Q0);
O0QQ0QC0Q0(OQ0Q0QC0Q0,1);
if OQ0Q0QC0Q0>0 then
OQOQOQC0Q0.OOQ0CQCOQ0(@OO0Q0QC0Q0[0],OQ0Q0QC0Q0);
end;
function OOOQOQC0Q0.OC0Q0QC0Q0:TBytes;
var
O0OQ0QC0Q0:Word;
begin
O0OQ0QC0Q0:=OQQQ0QC0Q0(1);
Result:=OQOQOQC0Q0.O0OOQQCOQ0(O0OQ0QC0Q0);
end;
procedure OOOQOQC0Q0.OOOQ0QC0Q0(OQOQ0QC0Q0:Word);
begin
O0QQ0QC0Q0(2,6);
OQOQOQC0Q0.OO0QQQCOQ0(OQOQ0QC0Q0);
end;
function OOOQOQC0Q0.OCOQ0QC0Q0:Word;
begin
OQQQ0QC0Q0(6);
Result:=OQOQOQC0Q0.OO0OQQCOQ0;
end;
procedure OOOQOQC0Q0.O0QQ0QC0Q0(PacketSize,OOQQ0QC0Q0:Word);
begin
O00COQC0Q0(PacketSize,OOQQ0QC0Q0);
OQOQOQC0Q0.OO0QQQCOQ0(PacketSize);
OQOQOQC0Q0.OO0QQQCOQ0(OOQQ0QC0Q0);
end;
function OOOQOQC0Q0.OQQQ0QC0Q0(OCQQ0QC0Q0:Word):Word;
var
O0CQ0QC0Q0:Word;
begin
Result:=OQOQOQC0Q0.OO0OQQCOQ0;
O0CQ0QC0Q0:=OQOQOQC0Q0.OO0OQQCOQ0;
OQ0COQC0Q0(Result,O0CQ0QC0Q0,OCQQ0QC0Q0);
end;
procedure OOOQOQC0Q0.OOCQ0QC0Q0(OQCQ0QC0Q0:Word);
begin
OQOQOQC0Q0.OO0QQQCOQ0(OOQQOQC0Q0);
OQOQOQC0Q0.OO0QQQCOQ0(OQCQ0QC0Q0);
OQOQOQC0Q0.OOOQQQCOQ0(0);
end;
class function OOOQOQC0Q0.OCCQ0QC0Q0(O00C0QC0Q0:OO00OQCOQ0):OQQCQCCOQ0;
begin
SetLength(Result,3);
Result[0]:=O00C0QC0Q0.OO0OQQCOQ0;
Result[1]:=O00C0QC0Q0.OO0OQQCOQ0;
Result[2]:=O00C0QC0Q0.OC0OQQCOQ0;
end;
class function OOOQOQC0Q0.OCOC0QC0Q0:Cardinal;
begin
Result:=$0A200000;
end;
function OOOQOQC0Q0.O0QC0QC0Q0:Integer;
begin
OCQQOQC0Q0:=slRejected;
Result:=1;
end;
procedure OOQC0QC0Q0.OCOCOQC0Q0;
begin
if O0CQOQC0Q0<>0 then begin
case O0CQOQC0Q0 of
OC0QQOCOQ0:begin
OCOQOQC0Q0.OQCOCCC0Q0:=OC0QCCCOQ0.Create(5,OCOQOQC0Q0.O0QOCCC0Q0,False);
OCOQOQC0Q0.OQCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
OQOQQOCOQ0:begin
OCOQOQC0Q0.OQCOCCC0Q0:=OC0QCCCOQ0.Create(32,OCOQOQC0Q0.O0QOCCC0Q0,False);
OCOQOQC0Q0.OQCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
O0OQQOCOQ0:begin
OCOQOQC0Q0.OQCOCCC0Q0:=OC0QCCCOQ0.Create(7,OCOQOQC0Q0.O0QOCCC0Q0,False);
OCOQOQC0Q0.OQCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
OOOQQOCOQ0:begin
OCOQOQC0Q0.OQCOCCC0Q0:=OC0QCCCOQ0.Create(16,OCOQOQC0Q0.O0QOCCC0Q0,False);
OCOQOQC0Q0.OQCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
OOQQQOCOQ0:begin
OCOQOQC0Q0.OQCOCCC0Q0:=O0C00CCOQ0.Create(16);
OCOQOQC0Q0.OQCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
OQQQQOCOQ0:begin
OCOQOQC0Q0.OQCOCCC0Q0:=O0C00CCOQ0.Create(24);
OCOQOQC0Q0.OQCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
OCQQQOCOQ0:begin
OCOQOQC0Q0.OQCOCCC0Q0:=OOQCCCCOQ0.Create(16,OCOQOQC0Q0.O0QOCCC0Q0,False);
OCOQOQC0Q0.OQCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
O0CQQOCOQ0:begin
OCOQOQC0Q0.OQCOCCC0Q0:=OOQCCCCOQ0.Create(24,OCOQOQC0Q0.O0QOCCC0Q0,False);
OCOQOQC0Q0.OQCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
OOCQQOCOQ0:begin
OCOQOQC0Q0.OQCOCCC0Q0:=OOQCCCCOQ0.Create(32,OCOQOQC0Q0.O0QOCCC0Q0,False);
OCOQOQC0Q0.OQCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
else begin
OCOQOQC0Q0.OQCOCCC0Q0:=nil;
O00QCQOOQ0(12649);
end;
end;
end;
end;
procedure OOQC0QC0Q0.OQO0OQC0Q0;
begin
end;
function OOQC0QC0Q0.OO0C0QC0Q0:Integer;
begin
Result:=17+Length(O0QQOQC0Q0);
end;
procedure OOQC0QC0Q0.OQ0C0QC0Q0;
begin
OOCQ0QC0Q0(3);
OQCOOQC0Q0;
O00Q0QC0Q0(O0QQOQC0Q0);
OCO0OQC0Q0(1);
end;
procedure OOQC0QC0Q0.OC0C0QC0Q0(O0OC0QC0Q0:Integer);
var
OCQC0QC0Q0:Integer;
begin
OQQQOQC0Q0:=OCCOOQC0Q0;
OQQC0QC0Q0:=OOQ0OQC0Q0;
O0CQOQC0Q0:=-1;
for OCQC0QC0Q0:=0 to Length(O0QQOQC0Q0)-1 do
if O0QQOQC0Q0[OCQC0QC0Q0]=OQQC0QC0Q0 then begin
O0CQOQC0Q0:=OQQC0QC0Q0;
break;
end;
end;
function OOQC0QC0Q0.O0QC0QC0Q0:Integer;
var
O0CC0QC0Q0:Integer;
begin
Result:=inherited O0QC0QC0Q0;
OOQQOQC0Q0:=2;
OCQQOQC0Q0:=EncryptionLevel;
if OCQQOQC0Q0=slRejected then begin
SetLength(O0QQOQC0Q0,1);
O0QQOQC0Q0[0]:=0;
end
else if OCQQOQC0Q0=slRequired then begin
SetLength(O0QQOQC0Q0,High(OQCQQOCOQ0));
for O0CC0QC0Q0:=0 to Length(O0QQOQC0Q0)-1 do
O0QQOQC0Q0[O0CC0QC0Q0]:=OQCQQOCOQ0[O0CC0QC0Q0+1];
end
else begin
SetLength(O0QQOQC0Q0,High(OQCQQOCOQ0)+1);
for O0CC0QC0Q0:=0 to Length(O0QQOQC0Q0)-1 do
O0QQOQC0Q0[O0CC0QC0Q0]:=OQCQQOCOQ0[O0CC0QC0Q0];
end;
if OCQQOQC0Q0=slRequired then
Result:=Result or 16;
end;
procedure OOCC0QC0Q0.OCOCOQC0Q0;
begin
if OQCC0QC0Q0 then begin
case O0CQOQC0Q0 of
O00CQOCOQ0:begin
OCOQOQC0Q0.O0COCCC0Q0:=THash_MD5.Create;
OCOQOQC0Q0.OOCOCCC0Q0:=OC0QCCCOQ0.Create(5,OCOQOQC0Q0.O0QOCCC0Q0,True);
OCOQOQC0Q0.OOCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
OO0CQOCOQ0:begin
OCOQOQC0Q0.O0COCCC0Q0:=THash_SHA1.Create;
OCOQOQC0Q0.OOCOCCC0Q0:=OC0QCCCOQ0.Create(5,OCOQOQC0Q0.O0QOCCC0Q0,True);
OCOQOQC0Q0.OOCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
OQ0CQOCOQ0:begin
OCOQOQC0Q0.O0COCCC0Q0:=THash_SHA2_512.Create;
OCOQOQC0Q0.OOCOCCC0Q0:=OOQCCCCOQ0.Create(16,OCOQOQC0Q0.O0QOCCC0Q0,True);
OCOQOQC0Q0.OOCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
OC0CQOCOQ0:begin
OCOQOQC0Q0.O0COCCC0Q0:=THash_SHA2_256.Create;
OCOQOQC0Q0.OOCOCCC0Q0:=OOQCCCCOQ0.Create(16,OCOQOQC0Q0.O0QOCCC0Q0,True);
OCOQOQC0Q0.OOCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
O0OCQOCOQ0:begin
OCOQOQC0Q0.O0COCCC0Q0:=THash_SHA2_384.Create;
OCOQOQC0Q0.OOCOCCC0Q0:=OOQCCCCOQ0.Create(16,OCOQOQC0Q0.O0QOCCC0Q0,True);
OCOQOQC0Q0.OOCOCCC0Q0.Key:=OCOQOQC0Q0.OOQOCCC0Q0;
end;
else begin
OCOQOQC0Q0.O0COCCC0Q0:=nil;
O00QCQOOQ0(12649);
end;
end;
end;
end;
procedure OOCC0QC0Q0.OQO0OQC0Q0;
begin
end;
function OOCC0QC0Q0.OO0C0QC0Q0:Integer;
begin
Result:=12+Length(O0QQOQC0Q0);
end;
procedure OOCC0QC0Q0.OQ0C0QC0Q0;
begin
OOCQ0QC0Q0(2);
OQCOOQC0Q0;
O00Q0QC0Q0(O0QQOQC0Q0);
end;
procedure OOCC0QC0Q0.OC0C0QC0Q0(O0OC0QC0Q0:Integer);
var
OCQC0QC0Q0:Integer;
OCCC0QC0Q0:Byte;
O0000QC0Q0:Word;
OO000QC0Q0:Word;
OQ000QC0Q0:Integer;
OC000QC0Q0:TBytes;
O0O00QC0Q0:TBytes;
OOO00QC0Q0:TBytes;
OQO00QC0Q0:TBytes;
OCO00QC0Q0:TBytes;
O0Q00QC0Q0:OOOOOCCOQ0;
begin
{$IFNDEF VER9P}
SetLength(OC000QC0Q0,0);
SetLength(O0O00QC0Q0,0);
SetLength(OOO00QC0Q0,0);
SetLength(OQO00QC0Q0,0);
SetLength(OCO00QC0Q0,0);
{$ENDIF}
OQQQOQC0Q0:=OCCOOQC0Q0;
OCCC0QC0Q0:=OOQ0OQC0Q0;
O0CQOQC0Q0:=-1;
for OCQC0QC0Q0:=Low(OOOCQOCOQ0)to High(OOOCQOCOQ0)do
if OOOCQOCOQ0[OCQC0QC0Q0]=OCCC0QC0Q0 then begin
O0CQOQC0Q0:=OCCC0QC0Q0;
break;
end;
OQCC0QC0Q0:=O0CQOQC0Q0>0;
if O0OC0QC0Q0=8 then begin
O0000QC0Q0:=O0C0OQC0Q0;
OO000QC0Q0:=O0C0OQC0Q0;
if(O0000QC0Q0<=0)or(OO000QC0Q0<=0)then
raise Exception.Create('Bad parameters from server');
OC000QC0Q0:=OC0Q0QC0Q0;
O0O00QC0Q0:=OC0Q0QC0Q0;
OOO00QC0Q0:=OC0Q0QC0Q0;
OQO00QC0Q0:=OC0Q0QC0Q0;
OQ000QC0Q0:=(OO000QC0Q0+7)div 8;
if(Length(OOO00QC0Q0)<>OQ000QC0Q0)or(Length(O0O00QC0Q0)<>OQ000QC0Q0)then
raise Exception.Create('DiffieHellman negotiation out of synch');
O0Q00QC0Q0:=OOOOOCCOQ0.Create(OC000QC0Q0,O0O00QC0Q0,O0000QC0Q0,OO000QC0Q0);
try
OCO00QC0Q0:=O0Q00QC0Q0.OC0C0CCOQ0();
OCOQOQC0Q0.OC00QCC0Q0(OCO00QC0Q0);
OCOQOQC0Q0.O0QOCCC0Q0:=OQO00QC0Q0;
OCOQOQC0Q0.OCO0QCC0Q0(O0Q00QC0Q0.O0QC0CCOQ0(OOO00QC0Q0,Length(OOO00QC0Q0)));
finally
O0Q00QC0Q0.Free;
end;
end;
end;
function OOCC0QC0Q0.O0QC0QC0Q0:Integer;
var
O0CC0QC0Q0:Integer;
begin
Result:=inherited O0QC0QC0Q0;
OOQQOQC0Q0:=3;
OCQQOQC0Q0:=DataIntegrityLevel;
if OCQQOQC0Q0=slRejected then begin
SetLength(O0QQOQC0Q0,1);
O0QQOQC0Q0[0]:=0;
end
else if OCQQOQC0Q0=slRequired then begin
SetLength(O0QQOQC0Q0,High(OOOCQOCOQ0));
for O0CC0QC0Q0:=0 to Length(O0QQOQC0Q0)-1 do
O0QQOQC0Q0[O0CC0QC0Q0]:=OOOCQOCOQ0[O0CC0QC0Q0+1];
end
else begin
SetLength(O0QQOQC0Q0,High(OOOCQOCOQ0)+1);
for O0CC0QC0Q0:=0 to Length(O0QQOQC0Q0)-1 do
O0QQOQC0Q0[O0CC0QC0Q0]:=OOOCQOCOQ0[O0CC0QC0Q0];
end;
if OCQQOQC0Q0=slRequired then
Result:=Result or 16;
end;
constructor OOQ00QC0Q0.Create(OQOC0QC0Q0:OCC0CCC0Q0);
begin
inherited;
SetLength(OQQ00QC0Q0,8);
OQQ00QC0Q0[0]:=0;
OQQ00QC0Q0[1]:=0;
OQQ00QC0Q0[2]:=16;
OQQ00QC0Q0[3]:=28;
OQQ00QC0Q0[4]:=102;
OQQ00QC0Q0[5]:=236;
OQQ00QC0Q0[6]:=40;
OQQ00QC0Q0[7]:=234;
end;
procedure OOQ00QC0Q0.OQO0OQC0Q0;
var
OCC00QC0Q0,O00O0QC0Q0:Integer;
begin
for OCC00QC0Q0:=0 to Length(O0C00QC0Q0)-1 do begin
for O00O0QC0Q0:=0 to Length(OCQ00QC0Q0)-1 do
if O0C00QC0Q0[OCC00QC0Q0]=OCQ00QC0Q0[O00O0QC0Q0]then begin
Inc(OOC00QC0Q0);
break;
end;
if O00O0QC0Q0=Length(OCQ00QC0Q0)then
O00QCQOOQ0(-6320);
end;
if OOC00QC0Q0<>OQC00QC0Q0 then
O00QCQOOQ0(-6321);
end;
function OOQ00QC0Q0.OO0C0QC0Q0:Integer;
begin
Result:=26+Length(OQQ00QC0Q0)+Length(OCQ00QC0Q0)*2;
end;
procedure OOQ00QC0Q0.OQ0C0QC0Q0;
begin
OOCQ0QC0Q0(3);
OQCOOQC0Q0;
O00Q0QC0Q0(OQQ00QC0Q0);
OQOOOQC0Q0(OCQ00QC0Q0);
end;
procedure OOQ00QC0Q0.OC0C0QC0Q0(O0OC0QC0Q0:Integer);
var
OO0O0QC0Q0:Word;
begin
OQQQOQC0Q0:=OCCOOQC0Q0;
OO0O0QC0Q0:=OCOQ0QC0Q0;
if OO0O0QC0Q0<>31 then
O00QCQOOQ0(-6306);
O0C00QC0Q0:=OOQOOQC0Q0;
end;
function OOQ00QC0Q0.OQ0O0QC0Q0:TByteArr;
begin
Result:=OQQ00QC0Q0;
end;
function OOQ00QC0Q0.O0QC0QC0Q0:Integer;
begin
Result:=inherited O0QC0QC0Q0;
OOQQOQC0Q0:=4;
OOC00QC0Q0:=0;
OQC00QC0Q0:=2;
SetLength(OCQ00QC0Q0,4);
OCQ00QC0Q0[0]:=4;
OCQ00QC0Q0[1]:=1;
OCQ00QC0Q0[2]:=2;
OCQ00QC0Q0[3]:=3;
end;
constructor OC0O0QC0Q0.Create(OQOC0QC0Q0:OCC0CCC0Q0);
begin
inherited;
O0QO0QC0Q0:=False;
end;
procedure OC0O0QC0Q0.OQO0OQC0Q0;
begin
end;
function OC0O0QC0Q0.OO0C0QC0Q0:Integer;
var
OOQO0QC0Q0:Integer;
begin
Result:=20;
if O0QO0QC0Q0 then
for OOQO0QC0Q0:=0 to Length(O0OO0QC0Q0)-1 do
Result:=Result+9+Length(O0OO0QC0Q0[OOQO0QC0Q0]);
end;
procedure OC0O0QC0Q0.OQ0C0QC0Q0;
var
OQQO0QC0Q0:Integer;
OCQO0QC0Q0:Integer;
begin
OCQO0QC0Q0:=3;
if O0QO0QC0Q0 then
OCQO0QC0Q0:=OCQO0QC0Q0+Length(O0QQOQC0Q0)*2;
OOCQ0QC0Q0(OCQO0QC0Q0);
OQCOOQC0Q0;
OQQ0OQC0Q0($E0E1);
OOOQ0QC0Q0(OQOO0QC0Q0);
if O0QO0QC0Q0 then
for OQQO0QC0Q0:=0 to Length(O0QQOQC0Q0)-1 do begin
OCO0OQC0Q0(O0QQOQC0Q0[OQQO0QC0Q0]);
O00OOQC0Q0(O0OO0QC0Q0[OQQO0QC0Q0]);
end;
end;
procedure OC0O0QC0Q0.OC0C0QC0Q0(O0OC0QC0Q0:Integer);
begin
OQQQOQC0Q0:=OCCOOQC0Q0;
OQOO0QC0Q0:=OCOQ0QC0Q0;
if(OQOO0QC0Q0=$FAFF)and(O0OC0QC0Q0>2)then begin
OOQ0OQC0Q0;
OCOO0QC0Q0:=O0OOOQC0Q0;
if O0OC0QC0Q0>4 then begin
OCCOOQC0Q0;
OCC0OQC0Q0;
OCC0OQC0Q0;
end;
OOOO0QC0Q0:=True;
Exit;
end;
if OQOO0QC0Q0=$FBFF then begin
OOOO0QC0Q0:=False;
Exit;
end;
O00QCQOOQ0(-6307);
end;
function OC0O0QC0Q0.O0QC0QC0Q0:Integer;
begin
Result:=inherited O0QC0QC0Q0;
OOQQOQC0Q0:=1;
OQOO0QC0Q0:=$FCFF;
{$IFDEF MSWINDOWS}
SetLength(O0QQOQC0Q0,1);
SetLength(O0OO0QC0Q0,1);
O0QQOQC0Q0[0]:=OQQCQOCOQ0[1];
O0OO0QC0Q0[0]:=OCQCQOCOQ0[1];
{$ENDIF}
end;
constructor OCC0CCC0Q0.Create(O0CQQCC0Q0:OO00OQCOQ0);
begin
inherited Create;
O00OCCC0Q0:=O0CQQCC0Q0;
OCQOCCC0Q0:=TCRObjectList.Create;
OOOQQCC0Q0;
end;
destructor OCC0CCC0Q0.Destroy;
begin
OQCOCCC0Q0.Free;
O0COCCC0Q0.Free;
OOCOCCC0Q0.Free;
OCQOCCC0Q0.Free;
inherited;
end;
function OCC0CCC0Q0.OO0QQCC0Q0:OC0O0QC0Q0;
begin
Result:=OC0O0QC0Q0(OCQOCCC0Q0[1]);
end;
function OCC0CCC0Q0.OQ0QQCC0Q0:OOQC0QC0Q0;
begin
Result:=OOQC0QC0Q0(OCQOCCC0Q0[2]);
end;
function OCC0CCC0Q0.OC0QQCC0Q0:OOCC0QC0Q0;
begin
Result:=OOCC0QC0Q0(OCQOCCC0Q0[3]);
end;
function OCC0CCC0Q0.O0OQQCC0Q0:OOQ00QC0Q0;
begin
Result:=OOQ00QC0Q0(OCQOCCC0Q0[4]);
end;
procedure OCC0CCC0Q0.OOOQQCC0Q0;
var
OQOQQCC0Q0:OOOQOQC0Q0;
begin
OCQOCCC0Q0.Add(nil);
OQOOCCC0Q0:=1;
OQOQQCC0Q0:=OC0O0QC0Q0.Create(Self);
OQOOCCC0Q0:=OQOOCCC0Q0 or OQOQQCC0Q0.O0QC0QC0Q0;
OCQOCCC0Q0.Add(OQOQQCC0Q0);
OQOQQCC0Q0:=OOQC0QC0Q0.Create(Self);
OQOOCCC0Q0:=OQOOCCC0Q0 or OQOQQCC0Q0.O0QC0QC0Q0;
OCQOCCC0Q0.Add(OQOQQCC0Q0);
OQOQQCC0Q0:=OOCC0QC0Q0.Create(Self);
OQOOCCC0Q0:=OQOOCCC0Q0 or OQOQQCC0Q0.O0QC0QC0Q0;
OCQOCCC0Q0.Add(OQOQQCC0Q0);
OQOQQCC0Q0:=OOQ00QC0Q0.Create(Self);
OQOOCCC0Q0:=OQOOCCC0Q0 or OQOQQCC0Q0.O0QC0QC0Q0;
OCQOCCC0Q0.Add(OQOQQCC0Q0);
if(OQOOCCC0Q0 and 16>0)and(OQOOCCC0Q0 and 8>0)then
OQOOCCC0Q0:=OQOOCCC0Q0 and-17;
end;
procedure OCC0CCC0Q0.OCOQQCC0Q0(O0QQQCC0Q0:OC0O0QC0Q0;const OOQQQCC0Q0,OQQQQCC0Q0:string);
begin
end;
function OCC0CCC0Q0.OQCQQCC0Q0:Boolean;
begin
Result:=(O0OOCCC0Q0 and 5=1)and(OOOOCCC0Q0 and 8=0)
end;
procedure OCC0CCC0Q0.OCCQQCC0Q0(O00CQCC0Q0,OO0CQCC0Q0,OQ0CQCC0Q0:Word;OC0CQCC0Q0,O0OCQCC0Q0:Byte);
begin
OO0OCCC0Q0:=O00CQCC0Q0;
OQ0OCCC0Q0:=OO0CQCC0Q0;
OC0OCCC0Q0:=OQ0CQCC0Q0;
O0OOCCC0Q0:=OC0CQCC0Q0;
OOOOCCC0Q0:=O0OCQCC0Q0;
end;
procedure OCC0CCC0Q0.OOOCQCC0Q0;
var
OQOCQCC0Q0:Integer;
OCOCQCC0Q0:Integer;
O0QCQCC0Q0:Integer;
OOQCQCC0Q0:Integer;
OQQCQCC0Q0:boolean;
OCQCQCC0Q0:boolean;
O0CCQCC0Q0:OQQCQCCOQ0;
OOCCQCC0Q0:OQQCQCCOQ0;
OQCCQCC0Q0:Integer;
OCCCQCC0Q0:OOOQOQC0Q0;
O000QCC0Q0:Cardinal;
OO00QCC0Q0:OC0O0QC0Q0;
{$IFDEF MSWINDOWS}
OQ00QCC0Q0:OOCO0QC0Q0;
{$ENDIF}
begin
{$IFNDEF VER9P}
SetLength(OOCCQCC0Q0,0);
{$ENDIF}
OCOCQCC0Q0:=0;
for OQOCQCC0Q0:=1 to 4 do begin
OCCCQCC0Q0:=OOOQOQC0Q0(OCQOCCC0Q0[OQOCQCC0Q0]);
OCOCQCC0Q0:=OCOCQCC0Q0+OCCCQCC0Q0.OCCQOQC0Q0;
end;
OQCCQCC0Q0:=13+OCOCQCC0Q0;
OCC0QCC0Q0(OQCCQCC0Q0,4,0);
OCCCQCC0Q0:=OOOQOQC0Q0(OCQOCCC0Q0[4]);
OCCCQCC0Q0.OQ0C0QC0Q0;
OCCCQCC0Q0:=OOOQOQC0Q0(OCQOCCC0Q0[1]);
OCCCQCC0Q0.OQ0C0QC0Q0;
OCCCQCC0Q0:=OOOQOQC0Q0(OCQOCCC0Q0[2]);
OCCCQCC0Q0.OQ0C0QC0Q0;
OCCCQCC0Q0:=OOOQOQC0Q0(OCQOCCC0Q0[3]);
OCCCQCC0Q0.OQ0C0QC0Q0;
O00OCCC0Q0.OQ0CCQCOQ0(0);
O0CCQCC0Q0:=OC0OQCC0Q0;
for OQOCQCC0Q0:=0 to O0CCQCC0Q0[2]-1 do begin
OOCCQCC0Q0:=OOOQOQC0Q0.OCCQ0QC0Q0(O00OCCC0Q0);
O000QCC0Q0:=OOCCQCC0Q0[2];
case O000QCC0Q0 of
0:
;
12648:
OOCO0QOOQ0(12648,'ORA-12648: Encryption or data integrity algorithm list empty'#$A);
12649:
OOCO0QOOQ0(12649,'ORA-12649: Unknown encryption or data integrity algorithm'#$A);
12650:
OOCO0QOOQ0(12650,'ORA-12650: No common encryption or data integrity algorithm'#$A);
12651:
OOCO0QOOQ0(12651,'ORA-12651: Encryption or data integrity algorithm unacceptable'#$A);
12657:
OOCO0QOOQ0(12657,'ORA-12657: No algorithms installed'#$A);
12660:
OOCO0QOOQ0(12660,'ORA-12660: Encryption or crypto-checksumming parameters incompatible'#$A);
else
O00QCQOOQ0(OOCCQCC0Q0[2]);
end;
OCCCQCC0Q0:=OOOQOQC0Q0(OCQOCCC0Q0[OOCCQCC0Q0[0]]);
OCCCQCC0Q0.OOOCOQC0Q0(OOCCQCC0Q0[1]);
end;
for OQOCQCC0Q0:=1 to 4 do begin
OCCCQCC0Q0:=OOOQOQC0Q0(OCQOCCC0Q0[OQOCQCC0Q0]);
OCCCQCC0Q0.OCOCOQC0Q0;
end;
OO00QCC0Q0:=OC0O0QC0Q0(OCQOCCC0Q0[1]);
OQQCQCC0Q0:=False;
OCQCQCC0Q0:=False;
if OO00QCC0Q0.OOOO0QC0Q0 then
if OO00QCC0Q0.OCOO0QC0Q0='KERBEROS5' then
OQQCQCC0Q0:=True
else if OO00QCC0Q0.OCOO0QC0Q0='NTS' then
OCQCQCC0Q0:=True;
O0QCQCC0Q0:=0;
OOQCQCC0Q0:=0;
if Length(OCOOCCC0Q0)<>0 then begin
O0QCQCC0Q0:=O0QCQCC0Q0+12+Length(OCOOCCC0Q0);
Inc(OOQCQCC0Q0);
end;
if OQQCQCC0Q0 then begin
O0QCQCC0Q0:=O0QCQCC0Q0+37;
Inc(OOQCQCC0Q0);
end
else if OCQCQCC0Q0 then begin
O0QCQCC0Q0:=O0QCQCC0Q0+130;
Inc(OOQCQCC0Q0);
end;
if O0QCQCC0Q0>0 then begin
O0QCQCC0Q0:=O0QCQCC0Q0+13;
OCC0QCC0Q0(O0QCQCC0Q0,OOQCQCC0Q0,0);
if Length(OCOOCCC0Q0)<>0 then begin
OCCCQCC0Q0:=OOOQOQC0Q0(OCQOCCC0Q0[3]);
OCCCQCC0Q0.OOCQ0QC0Q0(1);
OO00QCC0Q0.O00Q0QC0Q0(OCOOCCC0Q0);
end;
if OQQCQCC0Q0 then begin
OO00QCC0Q0.OOCQ0QC0Q0(4);
OO00QCC0Q0.OQCOOQC0Q0;
OO00QCC0Q0.OOC0OQC0Q0(9);
OO00QCC0Q0.OOC0OQC0Q0(2);
OO00QCC0Q0.OCO0OQC0Q0(1);
end
else if OCQCQCC0Q0 then begin
{$IFDEF MSWINDOWS}
OQ00QCC0Q0:=OOCO0QC0Q0.Create(O00OCCC0Q0);
try
OQ00QCC0Q0.O0QCCQC0Q0;
finally
OQ00QCC0Q0.Free;
end;
{$ENDIF}
end;
O00OCCC0Q0.OQ0CCQCOQ0(0);
if OQQCQCC0Q0 then begin
end;
end;
OCCOCCC0Q0:=(OQCOCCC0Q0<>nil)or(O0COCCC0Q0<>nil);
if O0COCCC0Q0<>nil then
O00OCCC0Q0.OQO0CQCOQ0(O0COCCC0Q0.HashSize,OQCOCCC0Q0<>nil)
else
O00OCCC0Q0.OQO0CQCOQ0(0,OQCOCCC0Q0<>nil);
end;
procedure OCC0CCC0Q0.OC00QCC0Q0(const O0O0QCC0Q0:TBytes);
begin
OCOOCCC0Q0:=O0O0QCC0Q0;
end;
procedure OCC0CCC0Q0.OOO0QCC0Q0(const OQO0QCC0Q0:TBytes);
begin
O0QOCCC0Q0:=OQO0QCC0Q0;
end;
procedure OCC0CCC0Q0.OCO0QCC0Q0(const O0Q0QCC0Q0:TBytes);
begin
OOQOCCC0Q0:=O0Q0QCC0Q0;
end;
procedure OCC0CCC0Q0.OOQ0QCC0Q0(const OQQ0QCC0Q0:TBytes);
var
OCQ0QCC0Q0:Integer;
O0C0QCC0Q0:Integer;
begin
if(Length(OQQ0QCC0Q0)<>0)and(Length(OOQOCCC0Q0)<>0)then begin
if Length(OQQ0QCC0Q0)<Length(OOQOCCC0Q0)then
O0C0QCC0Q0:=Length(OQQ0QCC0Q0)
else
O0C0QCC0Q0:=Length(OOQOCCC0Q0);
for OCQ0QCC0Q0:=0 to O0C0QCC0Q0-1 do
OOQOCCC0Q0[OCQ0QCC0Q0]:=OOQOCCC0Q0[OCQ0QCC0Q0]xor OQQ0QCC0Q0[OCQ0QCC0Q0];
if OQCOCCC0Q0<>nil then begin
OQCOCCC0Q0.Key:=OOQOCCC0Q0;
OQQOCCC0Q0:=True;
end;
if O0COCCC0Q0<>nil then begin
OOCOCCC0Q0.Key:=OOQOCCC0Q0;
OQQOCCC0Q0:=True;
end;
end;
end;
function OCC0CCC0Q0.OOC0QCC0Q0:TBytes;
begin
Result:=O0QOCCC0Q0;
end;
function OCC0CCC0Q0.OQC0QCC0Q0:TBytes;
begin
Result:=OOQOCCC0Q0;
end;
procedure OCC0CCC0Q0.OCC0QCC0Q0(O00OQCC0Q0,OO0OQCC0Q0:Word;OQ0OQCC0Q0:Byte);
begin
O00OCCC0Q0.OOOQQQCOQ0($DEADBEEF);
O00OCCC0Q0.OO0QQQCOQ0(O00OQCC0Q0);
O00OCCC0Q0.OOOQQQCOQ0(OOOQOQC0Q0.OCOC0QC0Q0);
O00OCCC0Q0.OO0QQQCOQ0(OO0OQCC0Q0);
O00OCCC0Q0.OOCOCQCOQ0(OQ0OQCC0Q0);
end;
function OCC0CCC0Q0.OC0OQCC0Q0:OQQCQCCOQ0;
var
O0OOQCC0Q0:Cardinal;
begin
O0OOQCC0Q0:=O00OCCC0Q0.OC0OQQCOQ0;
if O0OOQCC0Q0<>$DEADBEEF then
O00QCQOOQ0(2514);
SetLength(Result,4);
Result[0]:=O00OCCC0Q0.OO0OQQCOQ0;
Result[1]:=O00OCCC0Q0.OC0OQQCOQ0;
Result[2]:=O00OCCC0Q0.OO0OQQCOQ0;
Result[3]:=O00OCCC0Q0.OQC0QQCOQ0;
end;
function OCC0CCC0Q0.OOOOQCC0Q0(const OQOOQCC0Q0:TBytes;const OCOOQCC0Q0:Integer):Integer;
var
O0QOQCC0Q0:TBytes;
begin
Result:=OCOOQCC0Q0-10;
if O0COCCC0Q0<>nil then begin
O0COCCC0Q0.Initialize;
O0COCCC0Q0.TransformBlock(OQOOQCC0Q0,10,Result);
if OOCOCCC0Q0 is OC0QCCCOQ0 then
O0QOQCC0Q0:=OC0QCCCOQ0(OOCOCCC0Q0).OCOCCCCOQ0(O0COCCC0Q0.HashSize)
else if OOCOCCC0Q0 is OOQCCCCOQ0 then
O0QOQCC0Q0:=OOQCCCCOQ0(OOCOCCC0Q0).OCOOCCCOQ0(O0COCCC0Q0.HashSize)
else
SetLength(O0QOQCC0Q0,O0COCCC0Q0.HashSize);
O0COCCC0Q0.TransformFinalBlock(O0QOQCC0Q0,0,Length(O0QOQCC0Q0));
O0QOQCC0Q0:=O0COCCC0Q0.Hash;
Move(O0QOQCC0Q0[0],OQOOQCC0Q0[Result+10],Length(O0QOQCC0Q0));
Result:=Result+Length(O0QOQCC0Q0);
end;
if OQCOCCC0Q0<>nil then
if OQCOCCC0Q0 is O0C00CCOQ0 then
Result:=O0C00CCOQ0(OQCOCCC0Q0).OCCO0CCOQ0(@OQOOQCC0Q0[10],Result)
else if OQCOCCC0Q0 is OC0QCCCOQ0 then
Result:=OC0QCCCOQ0(OQCOCCC0Q0).O0OCCCCOQ0(@OQOOQCC0Q0[10],Result)
else if OQCOCCC0Q0 is OOQCCCCOQ0 then
Result:=OOQCCCCOQ0(OQCOCCC0Q0).OCQ0CCCOQ0(@OQOOQCC0Q0[10],Result);
Result:=Result+10;
if(O0COCCC0Q0<>nil)or(OQCOCCC0Q0<>nil)then begin
if OQQOCCC0Q0 then
OQOOQCC0Q0[Result]:=1
else
OQOOQCC0Q0[Result]:=0;
Inc(Result);
end;
end;
function OCC0CCC0Q0.OOQOQCC0Q0(const OQQOQCC0Q0:TBytes;const OCQOQCC0Q0:Integer):Integer;
var
O0COQCC0Q0:Integer;
OOCOQCC0Q0:TBytes;
begin
Result:=OCQOQCC0Q0;
if(O0COCCC0Q0<>nil)or(OQCOCCC0Q0<>nil)then begin
Dec(Result);
O0COQCC0Q0:=OQQOQCC0Q0[Result];
if(OQQOCCC0Q0 and(O0COQCC0Q0<>1))or(not OQQOCCC0Q0 and(O0COQCC0Q0<>0))then
OOCO0QOOQ0(03113,'ORA-03113: end-of-file on communication channel'#$A);
end;
Result:=Result-10;
if OQCOCCC0Q0<>nil then begin
if OQCOCCC0Q0 is O0C00CCOQ0 then
Result:=O0C00CCOQ0(OQCOCCC0Q0).OCQO0CCOQ0(@OQQOQCC0Q0[10],Result)
else if OQCOCCC0Q0 is OC0QCCCOQ0 then
Result:=OC0QCCCOQ0(OQCOCCC0Q0).OC0CCCCOQ0(@OQQOQCC0Q0[10],Result)
else if OQCOCCC0Q0 is OOQCCCCOQ0 then
Result:=OOQCCCCOQ0(OQCOCCC0Q0).OQQ0CCCOQ0(@OQQOQCC0Q0[10],Result);
if Result<0 then
OOCO0QOOQ0(03113,'ORA-03113: end-of-file on communication channel'#$A);
end;
if O0COCCC0Q0<>nil then begin
Result:=Result-O0COCCC0Q0.HashSize;
if Result<0 then
OOCO0QOOQ0(12656,'ORA-12656: Cryptographic checksum mismatch'#$A);
O0COCCC0Q0.Initialize;
O0COCCC0Q0.TransformBlock(OQQOQCC0Q0,10,Result);
if OOCOCCC0Q0 is OC0QCCCOQ0 then
OOCOQCC0Q0:=OC0QCCCOQ0(OOCOCCC0Q0).OOOCCCCOQ0(O0COCCC0Q0.HashSize)
else if OOCOCCC0Q0 is OOQCCCCOQ0 then
OOCOQCC0Q0:=OOQCCCCOQ0(OOCOCCC0Q0).OQOOCCCOQ0(O0COCCC0Q0.HashSize)
else
SetLength(OOCOQCC0Q0,O0COCCC0Q0.HashSize);
O0COCCC0Q0.TransformFinalBlock(OOCOQCC0Q0,0,Length(OOCOQCC0Q0));
OOCOQCC0Q0:=O0COCCC0Q0.Hash;
for O0COQCC0Q0:=0 to O0COCCC0Q0.HashSize-1 do
if OOCOQCC0Q0[O0COQCC0Q0]<>OQQOQCC0Q0[Result+10+O0COQCC0Q0]then
OOCO0QOOQ0(12656,'ORA-12656: Cryptographic checksum mismatch'#$A);
end;
Result:=Result+10;
end;
procedure OCC0CCC0Q0.OQCOQCC0Q0;
begin
if OQCOCCC0Q0<>nil then
if OQCOCCC0Q0 is O0C00CCOQ0 then
O0C00CCOQ0(OQCOCCC0Q0).OOQO0CCOQ0
else if OQCOCCC0Q0 is OC0QCCCOQ0 then
OC0QCCCOQ0(OQCOCCC0Q0).OCCQCCCOQ0;
if OOCOCCC0Q0<>nil then
if OOCOCCC0Q0 is OC0QCCCOQ0 then
OC0QCCCOQ0(OOCOCCC0Q0).OCCQCCCOQ0
else if OOCOCCC0Q0 is OOQCCCCOQ0 then
OOQCCCCOQ0(OOCOCCC0Q0).OCO0CCCOQ0;
end;
{$IFDEF MSWINDOWS}
constructor OOCO0QC0Q0.Create(O0CQQCC0Q0:OO00OQCOQ0);
begin
inherited Create;
OQCO0QC0Q0:=O0CQQCC0Q0;
end;
procedure OOCO0QC0Q0.OCCO0QC0Q0(const O00QCQC0Q0:TBytes);
const
OO0QCQC0Q0:array[0..75]of byte=(
0,1,0,7,0,0,0,0,0,4,0,5,2,0,0,0,0,4,0,4,0,0,0,9,0,4,
0,4,0,0,0,2,0,20,0,1,2,0,0,0,4,0,0,0,2,0,0,0,0,0,0,
0,0,0,0,0,0,4,0,1,0,0,0,0,0,4,0,1,55,0,0,0,0,55,0,1
);
var
OQ0QCQC0Q0:TBytes;
OC0QCQC0Q0:Integer;
begin
OC0QCQC0Q0:=High(OO0QCQC0Q0)+1;
SetLength(OQ0QCQC0Q0,OC0QCQC0Q0+Length(O00QCQC0Q0));
Move(OO0QCQC0Q0[0],OQ0QCQC0Q0[0],OC0QCQC0Q0);
Move(O00QCQC0Q0[0],OQ0QCQC0Q0[OC0QCQC0Q0],Length(O00QCQC0Q0));
O0CQCQC0Q0(OQ0QCQC0Q0,OC0QCQC0Q0,true);
OQCO0QC0Q0.O0CCQQCOQ0(OQ0QCQC0Q0);
end;
function OOCO0QC0Q0.O0OQCQC0Q0:TBytes;
begin
Result:=OQCO0QC0Q0.O0OOQQCOQ0(33);
if Length(Result)>0 then
Result:=OQCO0QC0Q0.OQOOQQCOQ0;
end;
procedure OOCO0QC0Q0.OOOQCQC0Q0(const OQOQCQC0Q0:TBytes);
const
OCOQCQC0Q0:array[0..22]of byte=(
0,154,0,0,6,0,0,0,0,0,222,173,190,239,0,144,0,0,0,0,0,1,0
);
O0QQCQC0Q0:array[0..19]of byte=(
0,1,0,2,0,0,0,0,0,4,0,1,55,0,0,0,0,55,0,1
);
var
OOQQCQC0Q0:TBytes;
OQQQCQC0Q0:Integer;
OCQQCQC0Q0:Integer;
begin
OQQQCQC0Q0:=High(OCOQCQC0Q0)+1-10;
OCQQCQC0Q0:=High(O0QQCQC0Q0)+1;
SetLength(OOQQCQC0Q0,OQQQCQC0Q0+OCQQCQC0Q0+Length(OQOQCQC0Q0));
Move(OCOQCQC0Q0[10],OOQQCQC0Q0[0],OQQQCQC0Q0);
Move(O0QQCQC0Q0[0],OOQQCQC0Q0[OQQQCQC0Q0],OCQQCQC0Q0);
Move(OQOQCQC0Q0[0],OOQQCQC0Q0[OQQQCQC0Q0+OCQQCQC0Q0],Length(OQOQCQC0Q0));
O0CQCQC0Q0(OOQQCQC0Q0,OQQQCQC0Q0+OCQQCQC0Q0,false);
OQCO0QC0Q0.O0CCQQCOQ0(OOQQCQC0Q0);
end;
procedure OOCO0QC0Q0.O0CQCQC0Q0(var OOCQCQC0Q0:TBytes;OQCQCQC0Q0:Integer;OCCQCQC0Q0:boolean);
var
O00CCQC0Q0:Integer;
OO0CCQC0Q0:Integer;
OQ0CCQC0Q0:Integer;
OC0CCQC0Q0:Integer;
begin
O00CCQC0Q0:=Length(OOCQCQC0Q0);
if OCCQCQC0Q0 then begin
OQCO0QC0Q0.OQQ0QQCOQ0((O00CCQC0Q0+13)div 256,14);
OQCO0QC0Q0.OQQ0QQCOQ0((O00CCQC0Q0+13)mod 256,15);
end
else begin
OOCQCQC0Q0[4]:=O00CCQC0Q0 div 256;
OOCQCQC0Q0[5]:=O00CCQC0Q0 mod 256;
end;
OO0CCQC0Q0:=OQCQCQC0Q0-8;
OC0CCQC0Q0:=O00CCQC0Q0-OQCQCQC0Q0;
Marshal.WriteInt32(@OOCQCQC0Q0[OO0CCQC0Q0],OC0CCQC0Q0);
OQ0CCQC0Q0:=OQCQCQC0Q0-4;
OOCQCQC0Q0[OQ0CCQC0Q0]:=OC0CCQC0Q0 div 256;
OOCQCQC0Q0[OQ0CCQC0Q0+1]:=OC0CCQC0Q0 mod 256;
end;
procedure OOCO0QC0Q0.O0OCCQC0Q0(var OOOCCQC0Q0:TBytes);
var
OQOCCQC0Q0:Integer;
begin
OQOCCQC0Q0:=Length(OOOCCQC0Q0);
OOOCCQC0Q0[3]:=OQOCCQC0Q0 div 256;
OOOCCQC0Q0[4]:=OQOCCQC0Q0 mod 256;
end;
procedure OOCO0QC0Q0.O0QCCQC0Q0;
var
OOQCCQC0Q0:TBytes;
OQQCCQC0Q0:TBytes;
begin
{$IFNDEF VER9P}
SetLength(OQQCCQC0Q0,0);
{$ENDIF}
if Initialize<>0 then
Exit;
if StartAuthentication(OOQCCQC0Q0)<>0 then
Exit;
OCCO0QC0Q0(OOQCCQC0Q0);
OQQCCQC0Q0:=O0OQCQC0Q0;
if FinishAuthentication(OQQCCQC0Q0,OOQCCQC0Q0)<>0 then
Exit;
OOOQCQC0Q0(OOQCCQC0Q0);
end;
{$ENDIF}
end.
